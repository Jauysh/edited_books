# ИНФОРМАТИКА
# Учебник для 11-го класса
## Содержание




Введение                                                                                5
1. СОСТАВНЫЕ ТИПЫ ДАННЫХ
   1.1. Простые и составные типы данных                     •              •            6
   1.2. Тип данных массив                                   •              •           10
   1.3. Типы данных строка символов                         •              •           26
   1.4. Типы данных запись                                  •              •           40
   1.5. Оператор with                                       •              •           49
   1.6. Типы данных множество                               •              •           52
   1.7. Общие сведения о файлах                             •              •           62
   1.8. Файлы с последовательным доступом                   •              •           71
   1.9. Текстовые файлы                                     •              •           78
2. ИНФОРМАЦИЯ
   2.1. Количество информации                               •              •           92
   2.2. Кодирование и декодирование информации              •              •           95
   2.3. Часто используемые коды                             •              •           97
   2.4. Информация непрерывных сообщений                                   •          103
   2.5. Квантование изображений                                            •          106
   2.6. Представление и передача информации                                •          109
3. АРИФМЕТИЧЕСКИЕ ОСНОВЫ
   ВЫЧИСЛИТЕЛЬНОЙ ТЕХНИКИ
   3.1. Системы счисления                                                  •          114
   3.2. Перевод чисел из одной системы счисления в другую                  •          117
   3.3. Перевод чисел из двоичной системы счисления в
        восьмеричную, шестнадцатеричную и обратно                          •          119
   3.4. Арифметические операции в двоичной системе
         счисления                                                         •          122
   3.5. Представление натуральных чисел в компьютере                       •          124
   3.6. Представление целых чисел                                          •          125
   3.7. Представление вещественных чисел                                   •          128
4. БУЛЕВА АЛГЕБРА
   4.1. Логические переменные и выражения                                  •          133
   4.2. Логические функции                                                 •          137
   4.3. Часто используемые логические функции                              •          139

                                                                                                 
    1. ЛОГИЧЕСКИЕ СХЕМЫ
       5.1. Логические элементы                                             •         142
       5.2. Классификация логических схем                                   •         147
       5.3. Сумматор                                                        •         147
       5.4. Часто используемые комбинационные схемы                         •         151
       5.5. RS-триггер                                                      •         154
       5.6. Часто используемые последовательностные схемы                   •         157
       5.7. Генераторы импульсов                                            •         160

    2. УСТРОЙСТВО И РАБОТА КОМПЬЮТЕРА
       6.1. Функциональная схема компьютера                 •               •         163
       6.2. Форматы команд                                                  •         165
       6.3. Типы команд                                                     •         168
       6.4. Машинный язык и язык ассемблера                                 •         170
       6.5. Аппаратные и программные ресурсы компьютера     •               •         172
       6.6. Внешняя память на магнитных лентах и дисках     •               •         174
       6.7. Внешняя память на оптических дисках             •               •         178
       6.8. Видеомонитор и клавиатура                       •               •         182
       6.9. Принтеры                                        •               •         184
       6.10. Классификация компьютеров                      •               •         187
       6.11. Микропроцессор                                                 •         189

    3. КОМПЬЮТЕРНЫЕ СЕТИ
       7.1. Введение в компьютерные сети                    •               •         192
       7.2. Технологии взаимодействия в компьютерной сети   •               •         195
       7.3. Топология и архитектура компьютерных сетей                      •         197
       7.4. Глобальная сеть ИНТЕРНЕТ                        •               •         201
       7.5. Сервисы ИНТЕРНЕТа                               •               •         206

    4. МОДУЛИ ПО ВЫБОРУ
       8.1. Техника обработки аудио-видео информации        •               •         211
       8.2. Визуальное программирование                     •               •         216
       8.3. Языки разметки гипертекста                      •               •         221





# Глава 1
## СОСТАВНЫЕ ТИПЫ ДАННЫХ
### 1.1. Простые и составные типы данных
Мы уже знаем, что информация, которую может обрабатывать компьютер, должна быть представлена в виде данных. Данные состоят из цифр, букв, знаков, чисел, строк символов и т. д.
  
В машинном коде данные представляются в виде последовательностей двоичных цифр. Например, на уровне процессора натуральное число 1039 в двоичной системе счисления представляется как:
`10000001111`

Чтобы избавить пользователя от всех деталей, связанных с внутренним представлением данных, языки программирования используют различные типы данных. Напомним, что тип данных означает множество значений и множество операций, которые могут быть выполнены с этими значениями.

В предыдущих классах вы изучили следующие типы данных:

*   `integer/int`, предназначенный для компьютерной обработки целых чисел;
*   `real/float`, предназначенный для обработки вещественных чисел;
*   `boolean/bool` используется при обработке значений истинности;
*   `char/char`, предназначенный для представления и обработки символов;
*   `перечисляемый (enum)`, который включает упорядоченный набор значений, определенных идентификаторами;
*   `интервальный (только на языке ПАСКАЛЬ)`, который включает подмножество значений типа integer, boolean, char или перечисляемого.

С точки зрения языков программирования, целые числа, вещественные числа, значения истинности, символы, упорядоченные значения, заданные идентификаторами, называются простыми данными, а вышеперечисленные типы – простыми типами данных.

В общем, простых данных недостаточно для представления и эффективной обработки с помощью компьютера информации из окружающего мира.

Например, в случае обработки текстов операции удаления, копирования и перемещения выполняются не только на уровне символов (простой тип данных char), но также на уровне слов, предложений, строк, абзацев и даже целых страниц. Очевидно, что слово или предложение можно представить как последовательность символов, то есть через структуру, состоящую из последовательности простых данных типа char. Для описания таких структур языки программирования высокого уровня используют типы данных, называемые строками символов. Следовательно, буквы латинского алфавита A, a, B, b, C, c,…, Z, z представлены на компьютере простыми данными типа char, а слова, образованные из них, например Liceu, Patrie, Informatica и т. д. ― с помощью составных данных типа строка символов.

Другой пример, иллюстрирующий необходимость использования составных данных, – это обработка информации о ежедневном потреблении электроэнергии в домашнем хозяйстве. Объем потребления, в кВт·ч, может быть представлен на компьютере вещественным числом (простой тип данных `real` или `float`). Однако если мы хотим проанализировать изменения суточного потребления электроэнергии в течение месяца, нам придется представить соответствующие данные в виде одномерной таблицы, состоящей из одной строки:

| День месяца | 1    | 2    | 3    | ... | 31   |
|-------------|------|------|------|-----|------|
| Ежедневное потребление, кВт·ч | 13,4 | 18,6 | 9,4 | ... | 15,0 |


В первой ячейке этой таблицы будет содержаться потребление, в кВт·ч, в первый день месяца; во второй ячейке ― потребление во второй день месяца и так далее до ячейки 31, в зависимости от количества дней в рассматриваемом месяце.

При анализе суточного потребления электроэнергии в течение года нам придется использовать таблицу, состоящую из 12 строк и 31 столбца, то есть двумерную таблицу:

| День месяца | 1    | 2    | 3    | ... | 31   |
|-------------|------|------|------|-----|------|
| Январь      | 13,4 | 18,6 | 9,4  | ... | 15,0 |
| Февраль     | 12,9 | 14,3 | 21,7 | ... | ...  |
| ...         | ...  | ...  | ...  | ... | ...  |
| Декабрь     | 11,7 | 10,4 | 3,4  | ... | 25,3 |


Первая строка такой таблицы будет содержать потребление для каждого из дней января; вторая строка ― потребление для каждого дня февраля и так далее до строки, соответствующей декабрю.

Можно заметить, что приведенные выше таблицы представляют собой составные данные, состоящие из простых данных типа real / float. Обычно на компьютере соответствующие таблицы представляются с помощью специальных типов составных данных, называемых массивами.

Подчеркнем, что массивы содержат только данные в ячейках, без имен строки столбцов. На компьютере эти имена представлены другими величинами, называемыми индексами. Очевидно, что в случае одномерных массивов требуется только один индекс, а в случае двумерных массивов ― два.

Например, в случае одномерного массива, который представляет на компьютере ежедневное потребление электроэнергии в течение месяца, в качестве индекса используется целая величина, которая может принимать только значения 1, 2, 3,…, 31.

В случае двумерного массива, который представляет ежедневное потребление электроэнергии в течение года, необходимы два индекса: один для строк и один для столбцов. Перечисляемый тип, который принимает значения Ianuarie, Februarie, Martie, …, Decembrie, используется в качестве индекса для строк. Для индекса столбца используется целочисленная величина, которая принимает значения 1, 2, 3,… 31.

Данные, сформированные путем агрегирования (объединения в единое целое) простых данных, называются составными данными. Типы данных, используемые для определения таких данных, называются составными типами данных.
   
В дополнение к строкам символов и массивам, вышеописанным в общих чертах, языки программирования предлагают специалистам возможность использовать и другие составные типы данных, наиболее часто используемые,
― записи, множества и файлы.

##Вопросы и упражнения
1.   Объясните значения термина тип данных. Приведите примеры.
2.   В чем отличие между простыми и составными типами данных?
3.   Приведите примеры простых типов данных и составных типов данных.
4. ОБРАТИТЕ ВНИМАНИЕ! Определите, какой тип, простой или составной, имеют данные в нижеследующих примерах:

 1.	   `138`
 2.	   `3.14`
 3.	   `Munteanu Elena`
 4. 	 `Clasa a 11-a`
 5.	   `12   |   6   | 231  |  5`
 6.	   `32.51    |   149,28 | 318,56 | 20013.9 |  0.4536  |  721.3`
 7.	           
|   4  |  635 |  -8  | +27  |

|  72  |   41 |  319 | 432  |

|  16  |  -20 |   45 | 1830 |

В случае составных данных укажите тип простых данных, входящих в их состав.
Примеры ответов:

* Простое данное типа целое число.
* Составное данное типа одномерный массив, состоящий из целых чисел.

5.	 ТВОРИТЕ! Составьте одномерную таблицу, содержащую ежемесячные платежи за электроэнергию, потребленную вашей семьей в течение последнего календарного года. Используйте для этой цели информацию в счетах на оплату, выставленных компанией-поставщиком электроэнергии. Какие типы данных вы будете применять для представления информации в этой таблице на компьютере?


6. ИССЛЕДУЙТЕ! На сайте Национального банка Молдовы размещена информация о средних официальных курсах валютного обмена (обменном курсе). Например, в январе 2019 года средний официальный обменный курс единой валюты Европейского союза составлял: 1 евро = 19,6501 молдавских леев. Составьте:
* одномерную таблицу, содержащую официальные среднемесячные курсы этой валюты за последний календарный год;
* двумерную таблицу, содержащую официальные среднемесячные обменные курсы этой валюты за последние три года.

Какие типы данных вы будете использовать для представления информации в этих таблицах на компьютере?


7. ТВОРИТЕ! После посещения знаменитых Криковских подвалов, во время которого ученый-информатик имел возможность путешествовать по подземным галереям этого важного туристического объекта, ученый сконструировал робота, который находит кратчайший путь из одного выставочного зала в другой. В памяти компьютера, управляющего действиями робота, план галерей представлен прямоугольником, разделенным на квадраты (см. рисунок ниже).

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|---|
| 1 | x | x | x | x | x | x | x | x | x |
| 2 | x |   |   | x |   |   |   |   | x |
| 3 | x |   | x |   |   | x |   | x | x |
| 4 | x |   |   |   | x |   |   |   | x |
| 5 | x |   | x |   | x |   | x |   | x |
| 6 | x |   |   |   |   |   | x |   | x |
| 7 | x |  Вход | x | x | x | x | x |  Выход | x |
                   
Закрашенные квадраты представляют препятствия (стены галерей и выставочных залов, стенды с экспонатами), не закрашенные ― свободные пространства. Робот может выполнять только команды ВВЕРХ, ВНИЗ, НАПРАВО, НАЛЕВО, согласно которым он перемещается в один из соседних квадратов. Если в этом квадрате есть препятствие, например стена или стенд, робот останавливается и не реагирует ни на какие команды. Разработайте структуру данных, необходимую для представления плана Криковских подвалов на компьютере. Убедитесь, что продуманная структура содержит всю информацию о плане: препятствия, свободные пространства, квадраты, в которых находятся начальное положение робота, вход и выход.

8. УЧИТЕСЬ УЧИТЬСЯ! Вы уже знаете, что составные данные получаются путем агрегирования (объединения в единое целое) простых данных. Языки ПАСКАЛЬ и C++ позволяют агрегировать не только простые данные, но и составные. Например, в ячейках таблицы можно хранить не только простые данные (целые числа, действительные числа, символы и т. д.), но и составные данные, такие как строки.

Дан список учеников лицейского класса:
* Мунтяну Ион
* Флоря Елена
* …
* Присэкару Александра

Разработайте структуру данных, необходимую для представления такого списка на компьютере. Убедитесь, что продуманная структура позволяет сортировать список учащихся по алфавиту.




###     1.2. Тип данных массив

В языке программирования C++ тип данных одномерный массив определяется конструкцией вида:

**typedef** <Тип компонентов> <Имя типа массив> [<Количество компонентов>];
где <Тип компонентов> – это тип компонентов массива, который может быть практически любым типом данных, а <Количество компонентов> указывает количество компонентов массива.

Индексы компонентов массива могут принимать только последовательные целочисленные значения, начиная с нуля: 0, 1, 2,…, <Количество компонентов> - 1.

Примеры:
1.	itypedef int Vector[5];
    Vector V;
2.	typedef char Simbol[10];
    Simbol S;
3.	typedef float Acceleratie[45];
    Acceleratie A;

Структура данных из рассмотренных примеров представлена на рисунке 1.1*.
```
typedef int Vector [5]
Индексы      0   1   2   3   4
Компоненты  int int int int int

typedef char Simbol [10]
Индексы     0    1    2    3    4    5    6    7    8    9
Компоненты char char char char char char char char char char

typedef float Acceleratie [45]
Индексы        0     1      2   ...    43        44               
Компоненты   float float  float ...   float     float
```
Рис. 1.1* Структура данных типа Vector, Simbol и Acceleratie

Каждый компонент переменной одномерного массива можно указать явно, определив имя переменной, за которым следует соответствующий индекс, заключенный в квадратные скобки. Индексы должны быть целочисленными выражениями.

Примеры:
```
1.	V[1], V[4];	
2.	S[0], S[5], S[9];	
3.	A[0], A[44], A[23];
```
Над компонентами данных одномерного массива могут выполняться все операции, допустимые над их базовым типом. Следующая программа отображает на экране сумму компонентов переменной одномерного массива V. Значения компонентов V[0], V[1], ..., V[4] считываются с клавиатуры.

```cpp
// Программа P78
// Сумма компонентов переменной V типа Vector
// Фиксированное количество компонентов
#include <iostream>
using namespace std;

int main() {
    typedef int Vector[5];
    Vector V;
    int i, S;

    cout << "Введите 5 целых чисел:" << endl;
    for (i = 0; i < 5; i++) cin >> V[i];

    cout << "Были введены:" << endl;
    for (i = 0; i < 5; i++) cout << V[i] << ' ';
    cout << endl;

    S = 0;
    for (i = 0; i < 5; i++) S = S + V[i];

    cout << "Сумма= " << S;
    return 0;
}
```

Чтобы расширить область действия программы, рекомендуется указывать количество компонентов данных типа массив через константы. Это дает большую гибкость программам на C++, поскольку они могут применяться для обработки массивов, количество компонентов которых на момент написания программы неизвестно.

Например, программа P78 может быть изменена таким образом, чтобы она вычисляла сумму n целых чисел, n ≤ 100. Конкретное количество значений n, которые будут сохранены в одномерном массиве V, считывается с клавиатуры.

```cpp
// Программа P79
// Сумма компонентов переменной V типа Vector
// Переменное количество компонентов
#include <iostream>
using namespace std;

int main() {
    const int nmax = 100;
    typedef int Vector[nmax];
    Vector V;
    int n, i, S;

    cout << "Введите n= ";
    cin >> n;
    cout << "Введите " << n << " целых чисел:" << endl;
    for (i = 0; i < n; i++) cin >> V[i];

    cout << "Были введены:" << endl;
    for (i = 0; i < n; i++) cout << V[i] << ' ';
    cout << endl;

    S = 0;
    for (i = 0; i < n; i++) S = S + V[i];

    cout << "Сумма= " << S;
    return 0;
}
```

В информатике одномерные массивы часто используются для сортировки данных в определенном порядке, например в порядке возрастания. Для такой сортировки используется следующий метод:
1. каждый компонент массива, начиная с первого, последовательно сравнивается с каждым из следующих за ним компонентов;
2. если в результате сравнения компонентов выясняется, что текущий компонент больше того, с которым он сравнивается, компоненты меняются местами;
3. процесс обхода массива продолжается до сравнения последнего и предпоследнего компонентов.

На обыденном языке информатиков такая сортировка называется пузырьковой сортировкой, потому что компоненты массива меняют свое положение, как пузырьки в жидкости: самые легкие поднимаются на поверхность, а самые тяжелые уходят на дно.

Например, в следующей программе пузырьковый метод используется для сортировки компонентов массива A в порядке возрастания. Компоненты этого массива считываются с клавиатуры, а фактическая сортировка выполняется в таблице B.

``` cpp
// Программа P80
// Сортировка пузырьковым методом
#include <iostream>
using namespace std;

int main() {
    const int nmax = 100;
    typedef int Tablou[nmax];
    Tablou A, B;
    int n, i, j, x;

    cout << "Введите количество компонентов n= ";
    cin >> n;

    cout << "Введите компоненты массива A:\n";
    for (i = 0; i < n; i++) 
        cin >> A[i];

    // Копируем массив A в B
    for (i = 0; i < n; i++) 
        B[i] = A[i];

    // Сортировка пузырьком
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (B[i] > B[j]) {
                x = B[i];
                B[i] = B[j];
                B[j] = x;
            }

    cout << "Исходный массив:\n";
    for (i = 0; i < n; i++) 
        cout << A[i] << " ";
    cout << endl;

    cout << "Отсортированный массив:\n";
    for (i = 0; i < n; i++) 
        cout << B[i] << " ";
    cout << endl;

    return 0;
}
```

Тип данных двумерный массив определяется грамматической конструкцией вида:

typedef <Тип компонентов > <Имя типа массив>[<Количество строк>] [<Количество столбцов>];

В качестве примера на рис. 1.2* представлена структура данных типа Matrice:

```cpp
typedef double Matrice[3][4];
```

|       | 0       | 1       | 2       | 3       |
|-------|---------|---------|---------|---------|
| **0** | double  | double  | double  | double  |
| **1** | double  | double  | double  | double  |
| **2** | double  | double  | double  | double  |

Рис. 1.2 *. Структура данных типа Matrice

Компоненты переменных типа двумерный массив явно указываются именем переменной, за которым следуют соответствующие индексы в квадратных скобках.
   
Например, при наличии объявления переменной M
```cpp
Matrice M;
```

обозначение M[1,1] указывает компонент из строки с номером 1 и столбца с номером 1 (см. рис. 1.2*); обозначение M[1,2] указывает компонент из строки 1 и столбца 2; обозначение M[i,j] указывает компонент из строки i и столбца j.

Следующая программа отображает на экране сумму компонентов переменной M типа Matrice. Значения компонентов M[0,0], M[0,1], ..., M[2,3] считываются с клавиатуры.

```cpp
// Программа P81
// Сумма компонентов переменной M типа Matrice
#include <iostream>
using namespace std;

int main() {
    typedef double Matrice[3][4];
    Matrice M;
    int i, j;
    double S;

    cout << "Введите компоненты M[i,j]: " << endl;
    for (i = 0; i < 3; i++)
        for (j = 0; j < 4; j++) {
            cout << "M[" << i << ',' << j << "] = ";
            cin >> M[i][j];
        }

    cout << "Были введены:" << endl;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++)
            cout << M[i][j] << ' ';
        cout << endl;
    }

    S = 0;
    for (i = 0; i < 3; i++)
        for (j = 0; j < 4; j++)
            S += M[i][j];

    cout << "Сумма = " << S << endl;

    return 0;
}
```

В момент объявления компоненты массива можно инициализировать, например:
```cpp
int T[4]={2,5,9,-4};
int M[3][2]={{9,7}, {-12,8}, {0,-4}};
```
   
Подчеркнем, что в языке C++ индексы компонентов массива могут принимать только последовательные целочисленные значения, начиная с нуля: 0, 1, 2,…, <Количество компонентов> – 1. Иногда это может создавать определенные неудобства.

Таким образом, в случае примера суточного потребления электроэнергии в течение месяца (см. предыдущий параграф) соответствующая таблица может быть представлена на компьютере с помощью следующего типа данных одномерный массив:
```cpp
typedef float Consum[31];
Consum C;
```

Индекс массива C может принимать только значения 0, 1, 2,… 30, а компоненты массива специфицируются как C[0], C[1],…, C[30]. Очевидно, что индекс последнего дня месяца, т. е. 31-го не будет соответствовать какому-либо компоненту массива, а попытка использовать спецификацию C[31] в определенных ситуациях может вызвать ошибку выполнения. Несомненно, мы могли бы пронумеровать дни месяца не начиная с «1», а с «0», но это может сделать программы на C++ менее интуитивно понятными.

Чтобы избежать таких ситуаций, рекомендуется увеличить количество компонентов массива на одну единицу по сравнению с количеством, требуемым для представления составных данных на компьютере.
   
Например, в случае ежедневного потребления электроэнергии в течение месяца мы можем использовать следующий тип данных:
```cpp
typedef float Consum[32];
Consum C;
```
где первый день месяца будет соответствовать компоненту C[1], второй день ― компоненту C[2], третий день ― компоненту C[3] и так далее, а компонент C[0] останется неиспользованным.
   
Аналогичным образом можно использовать следующие типы данных для представления в компьютере ежедневного потребления электроэнергии в течение года:
```cpp
typedef float Consum[13][32];
Consum C;
```
где дни января будут соответствовать компонентам C[1,1],…, C[1,31]; дни февраля ― компонентам C[2,1],…, C[2,31], дни декабря ― компонентам C[12,1],…, C[12,31]. Очевидно, что некоторые компоненты таблицы C, особенно в строке и столбце 0, останутся неиспользованными. Однако поскольку читабельность и правильность программ гораздо важнее, чем неиспользование определенных компонентов, большинство информатиков считают, что этот прием не ухудшает качество программ на C++.



### Вопросы и упражнения
1. ОБРАТИТЕ ВНИМАНИЕ! Определите тип индексов и тип компонент в следующих объявлениях:

```cpp
typedef int P[5];

enum Culoare { Galben, Verde, Albastru, Violet };
typedef Culoare R[3];

typedef bool S[4][3];

typedef double T[2][5];
```
Нарисуйте структуры данных типа P, R, S и T (см. вышеприведенные соответствующие рисунки).

4. ПРОАНАЛИЗИРУЙТЕ! Определите, какие из нижеприведенных объявлений корректны:
```cpp

int a[30];
char a[10];
float a[10];  // C++ does not support non-integer indices like 1.10..10.00
char a[50];
```

5. УПРАЖНЯЙТЕСЬ! Даны объявления:
```cpp
typedef double Vector[5];
Vector x, y;
```
Напишите арифметическое выражение, значением которого является:
а. сумма первых трех компонентов переменной х;
б. сумма всех компонентов переменной у;
в. произведение всех компонентов переменной х;
г. абсолютное значение третьего компонента переменной у;
д. сумма первых компонентов переменных х и у.

6. ПРОАНАЛИЗИРУЙТЕ! Даны описания и операторы:

| № | Объявления       | Оператор                     | Результат          |
|---|-----------------|-------------------------------|------------------|
| 1 | unsigned char a[5]; | for (i=0; i<5; i++) a[i]=i; | a) 1 1 1 1 1<br>b) 0 0 0 0 0<br>c) 0 1 2 3 4<br>d) 1 2 3 4 0 |
| 2 | int v[4];        | for (i=0; i<5; i++) v[i]=2*i; | a) 2 4 6 8 10<br>b) 0 2 4 6 8<br>c) 0 1 2 3 4<br>d) 1 2 3 4 5 |

Выберите из списков справа варианты, содержащие правильные результаты выполнения соответствующих операторов.

7. РЕШИТЕ! Даны объявления:
```cpp
enum Zi { L, Ma, Mi, J, Vi, S, D };
typedef double Venit[7];
Venit v;
```
Компоненты переменной v представляют собой ежедневный доход предприятия. Напишите программу, которая:
а. вычисляет еженедельный доход предприятия;
б. подсчитывает средний ежедневный доход;
в. определяет день, когда был получен наибольший доход;
г. определяет день, когда был получен наименьший доход.

8. РЕШИТЕ! Даны объявления:
```cpp
typedef int Ora;
typedef int Temperatura[24];
Temperatura t;
```
Компоненты переменной t представляют собой значения температуры, измеряемой каждый час в течение 24 часов. Напишите программу, которая:
а. вычисляет среднюю температуру;
б. определяет минимальное и максимальное значения температуры;
в. определяет час (часы), в который была зарегистрирована максимальная температура;
г. определяет час (часы), в который была зарегистрирована минимальная температура.
д. вычисляет количество дней, в течение которых была зафиксирована тeмпература ниже нуля градусов;
е. вычисляет количество дней, в которые были зарегистрированы температуры выше средней за неделю.

9. Даны объявления:
```cpp
enum Oras { Chisinau, Orhei, Balti, Tighina, Tiraspol };
enum Zi { L, Ma, Mi, J, Vi, S, D };

typedef double Consum[5][7];
Consum C;

Oras r;
Zi z;
```

Компонент C[r, z] / C[r][z] в C++ переменной C представляет собой потребление электроэнергии города r в день z. Напишите программу, которая:
a. вычисляет количество электроэнергии, потребляемой каждым городом за неделю;
б. вычисляет количество электроэнергии, потребляемой данными городами ежедневно;
в. определяет город с максимальным еженедельным потреблением электро-энергии;
г. определяет город с минимальным еженедельным потреблением электро-энергии;
д. определяет день, в который города потребили наибольшее количество электроэнергии;
е. определяет день с наименьшим потреблением электроэнергии.


10. Даны объявления:
```cpp
typedef float Vector[5];
typedef bool Matrice[3][4];
typedef float Linie[4];
typedef Linie Tabel[3];

Vector V;
Matrice M;
Linie L;
Tabel T;
float x;
int i;
```

Какие из следующих операторов присваивания корректны?
```cpp
a)  T[3] = T[1];
b)  M = T;
c)  L = V;
d)  L[3] = x;
e)  x = i;
f)  i = x;
g)  L[3] = i;
h)  i = M[1][2];
i)  x = V[4];
j)  L[3] = V[4];
k)  T[1] = 4;
l)  T[2] = V;
m)  L = T[3];
n)  T[1][2] = M[1][2];
o)  T[2][1] = M[1][2];
p)  M[1] = 4;
q)  M[1][3] = L[2];
r)  x = T[1][2];
s)  x = M[1];
t)  L = M[1];
u)  V[5] = M[3][4];
v)  L = M[3][4];
```


11. РЕШИТЕ! С клавиатуры считываются компоненты одномерного массива, состоящего из n целых чисел, n≤10. Напишите программу, которая:

а. отображает на экране компоненты массива с интервалом в 5 позиций;
б. отображает на экране компоненты в порядке, обратном их введению в компьютер;
в. сортирует компоненты массива в порядке убывания;
г. отображает на экране только четные компоненты;
д. отображает на экране среднее арифметическое четных компонентов;
е. отображает на экране только нечетные компоненты;
ж. отображает на экране только те компоненты, которые больше x и не делятся на y (значения x и y считываются с клавиатуры);
з. отображает на экране только те компоненты, которые больше x и меньше y (значения x и y считываются с клавиатуры);
и. отображает на экране позиции (индексы) отрицательных нечетных компонентов;
к. отображает на экране позиции (индексы) компонентов, которые содержат только две значащие цифры;
л. заменяет первый компонент данного массива на компонент этого массива с минимальным значением;
м. заменяет компонент с минимальным значением данного массива на его первый компонент;
н. создает новый массив, состоящий только из четных компонентов массива, введенного с клавиатуры;
о. создает новый массив, состоящий только из делимых на 3 компонентов массива, введенного с клавиатуры.
п. создает новый массив, состоящий только из тех компонентов массива, вводимых с клавиатуры, которые имеют не более четырех делителей.

12. РЕШИТЕ! Человек намеревается купить n различных продуктов, пронумерованных i = 1, 2, 3,…, n. Каждый из этих продуктов можно купить в любом из k доступных магазинов, отмеченных j = 1, 2, 3,… , k. Очевидно, что покупатель выбирает магазины с самыми низкими ценами. Разработайте программу, которая определяет для каждого продукта i магазин j, в котором он должен быть приобретен, а также общую стоимость покупок C, сделанных таким образом.

Входные данные: двумерный массив P, в котором компонент P[i][j] представляет цену продукта i в магазине j.

Выходные данные: общая стоимость покупок C и одномерный массив M, в котором компонент M[i] представляет магазин j, в котором будет приобретен продукт i.

Ограничения: 1 ≤ n ≤ 10, 1 ≤ k ≤ 5. Цены указываются вещественными чиcлами с двумя цифрами после десятичной точки.

13. ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Разработайте структуры данных типа массив, необходимые для представления в программах ПАСКАЛЬ/C++ массивов, содержащих информацию о суточном потреблении электроэнергии в течение месяца и соответственно за год, описанных в этом параграфе. Проанализируйте, как количество компонентов в объявлениях массива влияет на понимание пользователями программ.

14. УЧИТЕСЬ УЧИТЬСЯ! Двумерные массивы с одинаковым количеством строк и столбцов называются квадратными массивами. Набор компонентов, у которых индекс строки равен индексу столбца, образует главную диагональ квадратного массива. Очевидно, что этот набор можно обозначить воображаемой линией, соединяющей компонент в верхнем левом углу с компонентом в правом нижнем углу квадратного массива. Аналогичным образом может быть определена вторичная диагональ квадратного массива, которая также может быть обозначена воображаемой линией, соединяющей компонент в нижнем левом углу с компонентом в правом верхнем углу.

Разработайте программу, которая считывает с клавиатуры квадратный массив с n строками, 2 ≤ n ≤ 10, и отображает на экране сумму компонентов, которые находятся:
а. на главной диагонали;
б. на вторичной диагонали;
в. над главной диагональю;
г. ниже главной диагонали;
д. над вторичной диагональю;
е. ниже вторичной диагонали.

Считается, что компоненты квадратного массива являются целыми числами, которые вводятся с клавиатуры.

15. ИЗУЧИТЕ! Язык C++ предоставляет альтернативный тип двумерных массивов, определенных в библиотеке <array>. Изучите эту библиотеку и перепишите программы из этого параграфа, используя возможности, которые она предлагает. Чем эти два способа определения массивов похожи и различны?

### 1.3. Типы данных строка символов
Особое значение имеют методы представления и обработки строк символов, поскольку многие объекты реального мира описываются не только числами, но и самыми разнообразными текстами. Обычно в современных средах разработки программ строки символов могут быть представлены несколькими структурами данных. Далее мы изучим следующие типы данных, используемые для представления строк символов:
* одномерные массивы с компонентами типа char (символы);
* string-и.

Напоминаем, что в случае языков программирования английское слово string имеет значение строки, ряда, последовательности символов.


#### Строки символов типа одномерный массив
В программах C++ строки символов могут быть представлены с помощью одномерных массивов с компонентами типа char. Такие типы объявляются грамматическими конструкциями вида:
```cpp
typedef char <Имя типа строка символов> [nmax];
```
где nmax указывает максимальное количество символов, которое могут иметь строки этого типа.

Набор значений типа данных <Имя типа строка символов> состоит из строк, содержащих до nmax символов. Поскольку во внутреннем представлении один из компонентов одномерного массива, представляющего строку, используется для обозначения конца строки, длина строки будет составлять не более nmax–1 значащих символов.

Примеры:
1.	 
```cpp
typedef char Nume[20];
Nume N;
```
2.	 
```cpp
typedef char Prenume[10];
Prenume P;
```
3.	 
```cpp
typedef char Companie[45];
Companie C;
```
Как было отмечено ранее, во внутреннем представлении конец строки указывается специальным символом, а именно символом escape '\0'.

Например, если переменная P типа Prenume содержит строку символов "Ion", соответствующий массив имеет вид:
```cpp
0   1   2   3    4   5   6   7   8    9
I   o   n   \0
```
Если та же переменная P содержит строку символов "Cristina", соответствующий массив будет иметь вид:
```cpp
0   1   2   3    4   5   6   7   8    9
C   r   i   s    t   i   n   a   \0
```
Поэтому, несмотря на то что в объявлении типа данных Prenume указано 10 символов, строки этого типа могут содержать до 9 значащих символов.
  
В принципе, строки, представленные одномерными массивами, могут обрабатываться путем прямого доступа к их компонентам.

Например, если вы хотите ввести строку "Ion" в переменную P, для этой цели можно использовать следующие операторы:
```cpp
P[0]=   'I';
P[1]=   'o';
P[2]=   'n';
P[3]=   '\0';
```
Подчеркнем, что указание конца строки с помощью escape-символа '\0' обязательно. В противном случае возникнут ошибки выполнения.

Значения строковых переменных ― одномерных массивов можно отобразить на экране с помощью оператора передачи данных << в потоке вывода cout.

Пример:
```cpp
// Программа P82_a
// Строки символов типа одномерный массив
#include <iostream>
using namespace std;

int main()
{
    typedef char Nume[20];
    Nume N;
    typedef char Prenume[10];
    Prenume P;

    N[0]='L'; N[1]='u'; N[2]='p'; N[3]='u'; N[4] = '\0';
    P[0]='I'; P[1]='o'; P[2]='n'; P[3]='\0';

    cout << N << endl;
    cout << P << endl;

    return 0;
}

```

Результаты, отображаемые на экране:
```
Lupu
Ion
```   
При чтении строк символов с клавиатуры необходимо иметь в виду, что стандартный ввод рассматривается как источник, обеспечивающий непрерывный поток символов cin. Чтобы иметь возможность извлечь нужные строки из этого потока, программа должна знать, какой символ их разделяет. Обычно в качестве разделителя используются так называемые белые символы (пробел, табуляция, конец строки), но программист может использовать и другие символы.

Оператор >> используется для чтения строк, разделенных белыми символами. Оператор << используется для отображения/вывода строк.

Пример:
```cpp
// Программа P82_b
// Считывание строк символов
// Разделители: пробел либо конец строки
#include <iostream>
using namespace std;
int main()
{
    typedef char Nume[20];
    Nume N;
    typedef char Prenume[10];
    Prenume P;
    cin >> N; // считывается строка символов N
    cin >> P; // считывается строка символов P
    cout << N << endl; // вывод строки символов              N
    cout << P << endl; // вывод строки символов              P
    return 0;
}

```
Предположим, что пользователь после запуска программы на выполнение вводит с клавиатуры:
```
Маркова<ENTER>
Кристина<ENTER>
```
В этом случае введенный cin имеет следующий вид:
```
Маркова<ENTER>Кристина<ENTER>
```   
 где символ  представляет его курсор. Изначально курсор находится в начале потока, то есть перед буквой M.
   
В процессе выполнения оператора cin>>N программа, начиная с текущей позиции курсора, обходит входной поток слева направо, смещая курсор после каждого прочитанного символа и помещая этот символ в переменную N. Как только курсор достигает разделителя конец строки <ENTER>, оператор cin>>N записывает в переменную N escape-символ '\0' и заканчивает считывание первой строки символов. После выполнения команды cin>>N переменная N примет значение "Маркова", а курсор окажется перед символом К.

Аналогичным образом оператор cin>>P продолжает обход входного потока, перемещая курсор и помещая считанные символы один за другим в переменную P. Как только курсор достигает разделителя конца строки <ENTER>, оператор cin>>P вводит escape-символ '\0' в переменную P и завершает чтение второй строки. После выполнения оператора cin>>P переменная P получит значение "Кристина", а курсор окажется в конце потока.

В результате программа отобразит на экране:
```
Маркова
Кристина
```
Подчеркнем, что операторы для чтения данных из входного потока cin>> используют в качестве разделителя не только конец строки <ENTER>, но и пробел. Таким образом, если пользователь наберет:
```
Маркова Кристина Лупу Ион <ENTER>
```                          
 переменная N получит значение "Маркова", переменная P ― значение "Кристина", а курсор будет перед символом Л. Остальные символы в потоке данных, а именно "Лупу Ион", останутся сохраненными во входном потоке.

Для чтения строк, разделенных только концом строки, т. е. нажатием клавиши <ENTER>, используется функция cin.getline. Вызов этой функции имеет вид:
```
cin.getline (S, n);
```
где
S ― переменная, в которую будет помещена строка символов из входного потока;
n ― максимальное количество символов, которые можно считать из входного потока.

Пример:
```cpp
// Программа P82_c
// Считывание строк символов
// Разделитель: конец строки
#include <iostream>
using namespace std;

int main()
{
    typedef char NumePrenume[30];
    NumePrenume NP;
    cin.getline(NP, 30); // Разделитель: конец строки NP
    cout << NP << endl;
    return 0;
}
```

Если в процессе выполнения вышеприведенной программы пользователь введет:
```
Пэдурару Елена - Переведена<ENTER>
```
переменная NP получит значение "Пэдурару Елена - Переведена".

Другой способ прочитать строку символов, которая может содержать пробелы, ― использовать функцию get().

Поскольку обработка строк путем доступа к каждому из компонентов этих массивов затруднительна, язык C++ содержит набор предопределенных функций, упрощающих этот процесс. Вот некоторые из них:
   
strcpy(S1, S2) ― копирует строку символов S2 в строку S1;
strcat(S1, S2) ― приклеивает к строке S1 строку символов S2;
strlen(S) ― возвращает длину строки символов S.

Среды разработки программ на C++ содержат и другие предопределенные функции, предназначенные для обработки строк. Описание и способы использования этих функций можно найти в системах поддержки этих сред.

Для использования этих функций в разрабатываемую программу должна быть включена следующая директива:
```cpp
#include <cstring>;
```
Пример:
```cpp
// Программа P82_d
/* Предопределенные функции для обработки */
/* строк символов типа одномерный массив */
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    typedef char Nume[20];
    Nume N;
    typedef char Prenume[10];
    Prenume P;

    strcpy(N, "Мунтяну");
    cout << N << "    " << strlen(N) << endl;

    strcpy(P, "Михай");
    cout << P << "   " << strlen(P) << endl;

    strcat(N, " ");
    cout << strcat(N, P) << "   " << strlen(N) << endl;

    return 0;
}
```

Отображенные на экране результаты:
```
Мунтяну     7
Михай    5
Мунтяну Михай    13
```
В случае представления строк одномерными массивами они могут быть инициализированы во время объявления. Однако следует иметь в виду, что эти массивы должны содержать escape-символ '\0' (конец строки).
Примеры:
1.	 char S[]={’I’, ’o’, ’n’, ’\0’};
2.	 char S[]=”Ion”;
3.	 char T[]={’E’, ’l’, ’e’, ’n’, ’a’, ’\0’};

##### Строка символов типа string
Мы уже знаем, что строки символов типа char <Имя типа строка символов>[nmax] могут содержать не более чем nmax–1 значимых символов. Но очень часто на момент написания программ на C++ значение nmax неизвестно, это усложняет процесс программирования.

Чтобы упростить работу программистов, язык программирования C++ содержит предопределенный тип строковых данных string, который позволяет объявлять строки без указания их максимально возможной длины. Для использования этого типа в декларативную часть программы на C++ необходимо добавить директиву:
```cpp
#include <string>;
```
Строки типа string могут появляться в операторах присваивания, и с ними может выполняться операция конкатенации (склеивания), обозначенная символом «+».

Пример:
```cpp
// Программа P83_a
// Строка символов типа string
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string N;             // Фамилия
    string P;             // Имя
    string NP;            // Фамилия и имя
    N = "Olaru";          // присваивание
    P = "Andrei";         // присваивание
    NP = N + " " + P;     // склеивание и присваивание
    cout << N << endl;
    cout << P << endl;
    cout << NP << endl;
    return 0;
}
```
Эта программа отобразит на экране:
```
Olaru
Andrei
Olaru Andrei
```   
Над строками символов можно выполнять следующие операции отношения: <, <=, ==, >=, >, !=. Строки сравниваются посимвольно слева направо в соответствии с положением символов в типе char.

Например, результат операции
```
’AC’ < ’BA’
```
равен true, а результат операции
```
’AAAAC’ < ’AAAAB’
```
равен false.

Переменная типа строка символов может быть использована целиком или частично, ссылаясь на символ в строке.

Например, после выполнения последовательности операторов
```cpp
P=”Mihai”;
P[0]=’P’; P[1]=’e’; P[2]=’t’; P[3]=’r’; P[4]=’u’;
```
переменная P получит значение ”Petru”.

Обычно чтение введенной с клавиатуры строки в переменную S типа string выполняется с помощью оператора вида:
```cpp
getline(cin, S);
```
Длина l строки символов S типа string определяется с помощью оператора вида:
```cpp
l = S.length();
```
где S ― это обрабатываемая строка символов.

Следующая программа считывает с клавиатуры произвольные строки символов и отображает на экране количество пробелов в каждой считанной строке. Программа заканчивается после введения строки ’Конец’.
```cpp
// Программа P83_b
// Количество пробелов в строке символов
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string Sir; // Считываемая с клавиатуры строка символов
    int L;      // Длина строки символов
    int n;      // Количество пробелов в считанной строке
    int i;

Repeta:
    cout << "Введите строку символов:" << endl;
    getline(cin, Sir); // Считывание строки
    L = Sir.length();   // Длина строки
    cout << "Lungimea sirului = " << L << endl;

    n = 0;
    for (i = 0; i < L; i++)
        if (Sir[i] == ' ') n++;

    cout << "Количество пробелов в строке = " << n << endl;

    if (Sir != "Конец") goto Repeta;

    return 0;
}
```

Стандартные библиотеки C++ дают программисту возможность использовать оба представления строковых данных как через массивы, так и в виде string.

Преобразование string в массив можно выполнить с помощью оператора вида:
```cpp
S.c_str();
```
где S ― это переменная типа string.

Преобразование массива символов в string можно сделать простым присваиванием вида S = T.

Пример:
```cpp
// Программа P83_c
// Преобразования string <--> массив символов
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    char A[20]; // A массив символов
    string B;    // B – string

    // Преобразование строки типа string B в массив A
    B = "Informatica";
    strcpy(A, B.c_str());
    cout << A << endl;

    // Преобразование массива A в string-ul B
    A[0] = 'A'; A[1] = 'd'; A[2] = 'm'; A[3] = 'i'; A[4] = 's'; A[5] = '\0';
    B = A;
    cout << B << endl;

    return 0;
}
```



 ### Вопросы и упражнения
1. Как определяется тип данных строка символов? Каковы два способа представления строк в программах на языке ПАСКАЛЬ/C++?
2. Какие операции можно выполнять со строками, представленными одномерными массивами? А с данными типа string?
3. ПРОГРАММИРУЙТЕ! Разработайте программу, которая запросит ввести с клавиатуры в две строки:
* имя и фамилию ученика/ученицы;
* профессию, к которой он/она стремится.
Используйте наводящие вопросы и организуйте диалог человека с компьютером в соответствии со следующей моделью:
```
Как тебя зовут (имя и фамилия)?
Пэдурару Елена
Кем ты хочешь стать в будущем?
врачом
Тебя зовут Пэдурару Елена
Ты хочешь стать врачом
```
В данной модели данные, которые ввел пользователь, выделены жирным шрифтом.
4. ОБРАТИТЕ ВНИМАНИЕ! Прокомментируйте следующую программу:
```cpp
// Программа P84
#include <iostream>
using namespace std;

int main()
{
    char S[] = "12345";
    cout << S << endl;
    S = "Sfat";
    cout << S;
    return 0;
}
```
5. ЭКСПЕРИМЕНТИРУЙТЕ! Добавьте перед оператором „return 0;” из программы P82_b последовательность операторов:
```cpp
cin >> N;
cin >> P;
cout << N << endl;
cout << P << endl;
```
Запустите программу на выполнение и введите строку:
```cpp
Маркова Кристина Лупу Ион Ion<ENTER>
```
Объясните отображенные на экране сообщения.
6.ПРОАНАЛИЗИРУЙТЕ! Даны строки символов типа string . Укажите результаты операций отношения:

a. 'B' < 'A'
b. "BB" > "AA"
c. "BAAAA" < "AAAAA"
d. "CCCCD" > "CCCCA"
e. "A" == "AA"
f. "BB " < "B B"
g. "A" == "a"
h. "Aa" > "aA"
i. "123" == "321"
j. "12345" > "12345"


7. РЕШИТЕ! Разработайте программу, которая считывает с клавиатуры строку символов S и на экране отобразится:
а. количество вхождений символа ’A’ в строке S;
б. строка, полученная заменой символа ’A’ на символ ’*’;
в. строка, полученная удалением из строки S всех вхождений символа ’B’;
г. количество появлений слога MA в строке S;
д. строка, полученная заменой всех вхождений в строке S слога MA на слог TA;
е. строка, полученная удалением из строки S всех вхождений слога ТО;
ж. обратная запись строки S;
з. true, если строка S палиндром, и false в противном случае;
и. строка, полученная преобразованием всех строчных букв в составе строки S в прописные;
к. строка, полученная преобразованием первой буквы каждого слова в составе строки S в заглавную букву;
л. строка, полученная путем сортировки в алфавитном порядке символов в строке S.
8. ПРОГРАММИРУЙТЕ! Даны строки символов, состоящие из заглавных букв латинского алфавита и пробелов. Напишите программу, которая шифрует данные строки по следующим правилам:
– каждая буква от ’A’ до ’Y’ заменяется на следующую за ней в алфавите букву;
– каждая буква ’Z’ заменяется на букву ’A’;
– каждый пробел заменяется на ’-’.
9. ПРОГРАММИРУЙТЕ! Напишите программу, которая расшифрует строки символов, зашифрованные по правилам из предыдущего упражнения.
10. ПРОГРАММИРУЙТЕ! Разработайте программу, которая считывает с клавиатуры строку символов S, состоящую из n символов, n ≤ 30, и отобразит на экране все строки, получаемые путем удаления из строки S последних k символов, k = 0, 1, 2, .., n – 1. Например, для S = Test программа отобразит на экране:
```cpp
Test
Tes
Te
T
```
11. ТВОРИТЕ! Разработайте программу, которая:
– считает с клавиатуры m, m ≤ 100, строк символов, состоящих из строчных букв латинского алфавита;
– отсортирует строки в алфавитном порядке;
– отобразит на экране отсортированные строки.
12. ПРОГРАММИРУЙТЕ! Строка S состоит из нескольких предложений. Предложения заканчиваются точкой, восклицательным или вопросительным знаком. Разработайте программу, которая отобразит:
−	 количество предложений в строке, введенной с клавиатуры;
−	 количество слов в каждом из предложений.
13. УЧИТЕСЬ УЧИТЬСЯ! Известно, что современные компиляторы содержат несколько предопределенных функций для обработки строк символов, например функций конкатенации, копирования, упорядочения, вставки или удаления определенных символов и т. д. Описание этих функций можно найти в системах поддержки интегрированных сред разработки программ.

Изучите индивидуально или в команде предопределенные функции обработки строк и заполните таблицу:
| Функция | Описание | Примеры |
|---------|----------|---------|
|         |          |         |
|         |          |         |
|         |          |         |
|         |          |         |
|         |          |         |

Перепишите программы из этого параграфа, применив соответствующие функции. Оцените, в какой степени использование этих функций облегчает процесс разработки программ на языке ПАСКАЛЬ/C++.
14. ИССЛЕДУЙТЕ! Кроме функции cin.getline, для считывания строк символов можно использовать функцию cin.get. Изучите самостоятельно или совместно с одноклассниками эту функцию. Узнайте, в чем состоит различие между функциями cin.getline и cin.get. Определите, в каких случаях рекомендуется использование функции cin.getline и в каких ― использование функции cin.get.

Используя функцию cin.get, разработайте программу, считывающую с клавиатуры строку символов и выводящую на экран ее длину. Строка может содержать один или более пробелов, а ее конец указывается символом ’x’.


# I AM HERE
#     1.4. Тип данных запись
   Запись – тип, известный в информатике под названием record, или струк-
тура, представляет собой группу данных, объединенных под одним именем.
Записи состоят из компонентов, называемых полями. В отличие от элементов
массива поля могут относиться к разным типам. Каждое поле имеет свое имя
(идентификатор поля).
   Например, результаты экзамена на степень бакалавра можно представить
в виде:
     Имя поля      Фамилия         Имя   Средний балл
                  Маркова     Кристина        10,0
      Запись     Мунтяну     Ион             8,7
                  ...         ...              ...
                  Пэдурару    Елена           9,5
   В этой модели для отображения результатов экзамена на степень бакалавра
каждому ученику соответствует запись, содержащая три поля: Nume (Фами-
лия), Prenume (Имя) и NotaMedie (Средний балл). На компьютере данные в
полях Nume и Prenume могут быть представлены строками символов, а данные
в поле NotaMedie ― вещественными числами.


     В языке ПАСКАЛЬ тип данных запись определяется структурой вида:
      type <Имя типа> = 	 record
      		                  <Имя поля 1> : T1;
      		                  <Имя поля 2> : T2;
      		                  ...
      		                  <Имя поля n> : Tn;
      	end;
где T1  , T2  , .., Tn указывают тип соответствующих полей. Тип любого поля
может быть произвольным, значит, поле, в свою очередь, может относиться к
типу запись. Таким образом можно определять вложенные типы.
     Примеры:
     1)	 type Elev = 	 record
                    			 Nume : string;
                    			 Prenume : string;
                    			 NotaMedie : real;
     		              end;
     	 var E1, E2 : Elev;
     2)	 type Punct = 	
                      record
     			 x : real; { координата                          x }
     			 y : real; { координата                          y }
     		               end;
     	 var P1, P2 : Punct;

40
  3)	 type Triunghi = 	record
                     		 A : Punct; { вершина                  A }
                    		 B : Punct; { вершина                   B }
  			 C : Punct; { вершина                                    C }
  		                   end;
  	 var T1, T2, T3 : Triunghi;

  Структура данных из приведенных выше примеров представлена на рис. 1.4.


                                                 NotaMedie




              Рис. 1.4. Структура данных типа Elev, Punct и Triunghi

   Если две переменные относятся к одному и тому же типу запись, то между
ними разрешена операция присваивания. При таком присваивании все поля
переменной, стоящей в правой части, копируются в переменную, стоящую в
левой части. Например, для типов данных и переменных, определенных выше,
следующие операторы присваивания корректны:
    E1:=E2;
    T2:=T3;
    P2:=P1
  К каждому элементу любой переменной типа record можно обращаться
явно, по имени переменной и названию поля, которые разделяются точкой.
  Примеры:
  1)	 E1.Nume, E1.Prenume, E1.NotaMedie;

  2)	 E2.Nume, E2.Prenume, E2.NotaMedie;

  3)	 P1.x, P1.y, P2.x, P2.y;

  4)	 T1.A, T1.B, T1.C, T2.A, T2.B, T2.C;

  5)	 T1.A.x, T1.A.y, T2.B.x, T2.B.y.

                                                                       41
   Очевидно, элемент E1.Nume относится к типу string; элемент P1.x ― к
типу real; элемент T1.A ― к типу Punct; элемент T1.A.x ― к типу real и т. д.
   К элементам данных типа запись можно применять все операции, допу-
стимые типом соответствующего поля. Следующая программа сравнивает
средние баллы двух учеников и выводит на экран имя и фамилию ученика
с более высоким средним баллом. Считается, что средние баллы учеников
различны.

     Program P85;
     { Данные типа Elev }
     type Elev = record
                   Nume : string;
                   Prenume : string;
                   NotaMedie : real;
                 end;
     var E1, E2, E3 : Elev;
     begin
       writeln(’Введите данные о первом ученике:’);
       write(’Фамилия:’);     readln(E1.Nume);
       write(’Имя:’); readln(E1.Prenume);
       write(’Средний балл:’); readln(E1.NotaMedie);

       writeln(’Введите данные о первом ученике:’);
       write(’Фамилия:’);     readln(E2.Nume);
       write(’Имя:’); readln(E2.Prenume);
       write(’Средний балл:’); readln(E2.NotaMedie);

       if E1.NotaMedie > E2.NotaMedie then E3:=E1 else E3:=E2;

       writeln(’Ученик с наиболее высоким средним баллом:’);
       writeln(E3.Nume, ’ ’, E3.Prenume, ’:’, E3.NotaMedie : 5:2);
       readln;
     end.

  Любой тип данных record может служить базовым типом для формирова-
ния других составных типов.
     Пример:

      type ListaElevilor = array [1..40] of Elev;
      var  LE : ListaElevilor;

   Очевидно, обозначение LE[i] указывает на i-го ученика из списка; обо-
значение LE[i].Nume указывает на имя данного ученика и т. д. Следующая
программа вводит с клавиатуры данные об n учениках и выводит на экран
имя, фамилию и средний балл ученика с наибольшим средним баллом. Счи-
тается, что средние баллы учеников различны.

42
  Program P86;
  { Массив с элементами типа Elev }
  type Elev = record
                 Nume : string;
                 Prenume : string;
                 NotaMedie : real;
               end;
       ListaElev = array [1..40] of Elev;
  var E : Elev;
      LE : ListaElev;
      n : 1..40;
      i : integer;
  begin
    write(’n=’); readln(n);
    for i:=1 to n do
      begin
        writeln(’Введите данные об ученике’, i);
        write(’Фамилия:  ’);		     readln(LE[i].Nume);
        write(’Имя:  ’);	readln(LE[i].Prenume);
        write(’Средний балл:  ’);	readln(LE[i].NotaMedie);
      end;
    E.NotaMedie:=0;
    for i:=1 to n do
      if LE[i].NotaMedie > E.NotaMedie then E:=LE[i];
    writeln(’Ученик с наибольшим средним баллом:’);
    writeln(E.Nume, ’ ’, E.Prenume, ’:’, E.NotaMedie : 5:2);
    readln;
  end.

   В общем случае тип данных запись определяется с помощью синтаксиче-
ских диаграмм на рис. 1.5. В дополнение к фиксированным записям (записям
с фиксированным количеством полей) язык ПАСКАЛЬ позволяет использо-
вание вариантных записей. Такие записи изучаются в углубленных курсах
информатики.

      <Тип запись>




                 Идентификатор               Тип




                Рис. 1.5. Синтаксическая диаграмма <Тип запись>


                                                                     43
  В языке C++ тип данных запись определяется грамматической конструк-
цией вида:

         struct [<Имя типа>] {
         		                  T1 <Имя поля 1> ;
         		                  T2 <Имя поля 2>;
         		...
         		                  Tn <Имя поля n>;
         	                  };
где T1, T2, .., Tn указывают типы соответствующих полей. Тип любого поля
может быть произвольным, значит, поле, в свою очередь, может относиться
к типу запись. Таким образом можно определять вложенные типы.
     Примеры:

     1)	 struct Elev {
                   string Nume[20];
                   string Prenume[25];
                   float NotaMedie;
                  };
     	 Elev E1, E2;

     2)	 struct Punct {
                    double x;      // координата     x
                    double y;      // координата     y
                   };
     	 Punct P1, P2;

     3)	 struct Triunghi {
                            Punct A;    // вершина       A
                            Punct B;    // вершина       B
                            Punct C;    // вершина       C
                           };
     	    Triunghi T1, T2, T3;

   Структура данных из приведенных выше примеров представлена на
рис. 1.4*.
   Если две переменные относятся к одному и тому же типу запись, то между
ними разрешена операция присваивания. При таком присваивании все поля
переменной, стоящей в правой части, копируются в переменную, стоящую в
левой части. Например, для типов данных и переменных, определенных выше,
следующие операторы присваивания корректны:
         E1=E2;
         T2=T3;
         P2=P1

44
                                                 NotaMedie




             Рис. 1.4*. Структура данных типа Elev, Punct и Triunghi

  К каждому компоненту любой переменной типа struct можно обращаться
явно, по имени переменной и названию поля, которые разделяются точкой.
  Примеры:

  1)	 E1.Nume, E1.Prenume, E1.NotaMedie

  2)	 E2.Nume, E2.Prenume, E2.NotaMedie
  3)	 P1.x, P1.y, P2.x, P2.y
  4)	 T1.A, T1.B, T1.C, T2.A, T2.B, T2.C
  5)	 T1.A.x, T1.A.y, T2.B.x, T2.B.y
  6)	 V[3].Nume, v[3].Prenume, V[3].NotaMedie
   Очевидно, элемент E1.Nume относится к типу string; элемент P1.x ― к типу
double; элемент T1.A ― к типу Punct; элемент T1.A.x ― к типу double и т. д.
   К элементам данных типа struct можно применять все операции, до-
пустимые в типе соответствующего поля. Следующая программа сравнивает
средние баллы двух учеников и выводит на экран имя и фамилию ученика
с более высоким средним баллом. Считается, что средние баллы учеников
различны.

  //Программа P85
  // Данные типа Elev
  #include <iostream>
  using namespace std;
  int main()
  {


                                                                        45
         struct Elev {
                    char Nume[20];
                    char Prenume[30];
                    float NotaMedie;
                   };
         Elev E1, E2, E3;
         cout<<”Введите данные о первом ученике:”<<endl;
         cout<<”Фамилия:”<<endl;    	   cin>>E1.Nume;
         cout<<”Имя:”<<endl;	     cin>>E1.Prenume;
         cout<<”Средний балл:”<<endl;	 cin>>E1.NotaMedie;
         cout<<endl<<”Введите данные о втором ученике:”<<endl;
         cout<<”Фамилия:”<<endl; 		           cin>>E2.Nume;
         cout<<”Имя:”<<endl; 	 cin>>E2.Prenume;
         cout<<”Средний балл:”<<endl; 	cin>>E2.NotaMedie;
         if (E1.NotaMedie > E2.NotaMedie) E3=E1; else E3=E2;
         cout<<”Ученик с наиболее высоким средним баллом:”<<endl;
         cout<<E3.Nume<<’ ’<<E3.Prenume<<’ ’<<E3.NotaMedie;
         return 0;
     }

  Любой тип данных struct может служить базовым типом для формирова-
ния других структурированных типов.
     Пример:
         typedef Elev ListaElevilor[40];
         ListaElevilor LE;

   Очевидно, обозначение LE[i] указывает на i-го ученика из списка; обо-
значение LE[i].Nume указывает на имя данного ученика и т. д. Следующая
программа вводит с клавиатуры данные об n учениках и выводит на экран имя,
фамилию и средний балл ученика с наивысшим средним баллом. Считается,
что средние баллы учеников различны.
     //Программа P86
     // Массив с элементами типа Elev
     #include <iostream>
     using namespace std;
     int main()
     {
     struct Elev {
                  char Nume[20];
                  char Prenume[30];
                  float NotaMedie;
                 };
     Elev E;
     int i;
     typedef Elev ListaElevilor[40];

46
  ListaElevilor LE;
  E.NotaMedie=0;
  int n;
  cout<<”n=”; cin>>n;
  for (i=0; i<n; i++)
    {
      cout<<”Фамилия:”;	cin>>LE[i].Nume;
     cout<<”Имя:”;	     cin>>LE[i].Prenume;
     cout<<”Средний балл:”;	 cin>>LE[i].NotaMedie;
    };
  for (i=0; i<n; i++)
      if (E.NotaMedie < LE[i].NotaMedie) E = LE[i];
    cout << "Ученик с наивысшим средним баллом:" << endl;
    cout << E.Nume << ' ' << E.Prenume << ' ' << E.NotaMedie 	
    << endl;
  return 0;
  }
  В общем случае тип данных запись определяется с помощью синтаксических
диаграмм на рис. 1.5*. В дополнение к фиксированным записям (записям с
фиксированным количеством полей) язык C++ позволяет использование ва-
риантных записей, которые определяются типом данных union. Такие записи
изучаются в более углубленных курсах информатики.

        <Тип запись>

                  struct          Имя типа



           {       Тип          Идентификатор           ;         }




               Рис. 1.5*. Синтаксическая диаграмма <Тип запись>


  Вопросы и упражнения
  Ê	 Укажите множество значений типа данных запись?
  	 Напишите металингвистические формулы, соответствующие синтаксической
     диаграмме на рис. 1.5/1.5*.
  	 Укажите на синтаксической диаграмме рис. 1.5/1.5* пути, которые соот-
     ветствуют определениям типов данных запись из программы Р85.
  	 УПРАЖНЯЙТЕСЬ! Опишите типы данных запись, предназначенные для
     представления следующей информации на компьютере:
     a)	 декартовы координаты точки на плоскости;
     б)	 декартовы координаты точки в пространстве;

                                                                       47
         в) список книг в личной библиотеке: имя и фамилия автора, название книги,
         язык, издательство, год издания, страна, в которой она была издана;
         г) перечень автомобилей автосалона: марка, тип, цвет кузова, емкость бака,
         год выпуска, цена;
         д) список музыкальных произведений из личной фонотеки: имя и фамилия
         исполнителя, название, вид музыки, год записи;
         е) список авиапассажиров: имя, фамилия, номер рейса (строка длиной до
         восьми знаков), дата (день, месяц, год) и время взлета (часы, минуты), тип
         самолета, место в самолете (строка длиной до шести символов);
         ж) список сотрудников компании: имя, фамилия, занимаемая должность,
         дата приема на работу (день, месяц, год), возраст, домашний адрес (город,
         улица, дом, квартира).
     	 ПРИМЕНИТЕ! Даны следующие объявления:
                ПАСКАЛЬ                                     C++
type Elev = record                          struct elev {
        Nume, Prenume : string;                             char Nume[20];
        T, P:real;                                          char Prenume[25];
             end;                                           float T, P;
var E: Elev;                                               };
                                            Elev E;
     	   В описании типа Elev поле T представляет собой средний балл ученика в
         осеннем семестре, а поле P – это средний балл ученика в весеннем семестре.
         Напишите оператор присваивания, в котором рассчитывается среднегодовой
         балл M ученика E.
     	 РЕШИТЕ! Даны следующие типы данных:

                ПАСКАЛЬ                                     C++
type                                        struct Data
Data = record                                 {
           Ziua : 1..31;                         int Ziua;Luna;Anul;
           Luna : 1..12;                      };
           Anul : integer;                  struct Persoana {
        end;                                     string NumePrenume;
Persoana = record                                Data DataNasterii;
           NumePrenume : string;              };
           DataNasterii : Data;             Persoana ListaPersoane[50];
             end;
ListaPersoane = array [1..50] of
Persoana;
     	   Напишите программу, которая вводит с клавиатуры данные о n лицах (n≤50)
         и выводит на экран:
     	   a)	 фамилии и имена тех, кто родился в день z месяца;
     	   б)	 фамилии и имена тех, кто родился в месяц l года;
     	   в)	 фамилии и имена тех, кто родился в год a;
     	   г)	 возраст каждого человека в годах, месяцах и днях z.l.a;
     	   д)	 фамилию и имя самого старшего человека;
     	   е)	 фамилию и имя самого младшего человека;

48
  	    ж)	возраст каждого человека в годах, месяцах и днях;
  	    з)	 список лиц старше v лет;
  	    и)	 список лиц в алфавитном порядке;
  	    к)	 список лиц, упорядоченный согласно дате рождения;
  	    л)	 список лиц одного возраста (рожденных в одном и том же году).
  	   Дано n (n≤30) точек на евклидовой плоскости. Каждая точка i определяется
       координатами xi, yi. Расстояние между точками i, j вычисляется по формуле:

                                             .
  	 Напишите программу, которая выводит на экран координаты двух точек,
     расстояние между которыми максимально.
  	 Площадь треугольника вычисляется по формуле Герона:

                                                     ,
  	    где р ― полупериметр, a, b и с ― длины соответствующих сторон. Используя
       типы данных Punct и Triunghi из данного параграфа, напишите про-
       грамму, которая считывает с клавиатуры информацию о n треугольниках
       (n≤10) и выводит на экран:
  	    a) площадь каждого треугольника;
  	    б) координаты вершин треугольника, площадь которого максимальна;
  	    в) координаты вершин треугольника, площадь которого минимальна;
  	    г) информацию о всех треугольниках в порядке возрастания их площадей.


  1.5. Оператор with
  ПРИМЕЧАНИЕ
  В языке C++ такого оператора нет. Значит, данный параграф предназначен для
  тех учеников, которые изучают только язык ПАСКАЛЬ.

  В языке ПАСКАЛЬ к каждому элементу любой переменной типа запись
можно обращаться явно, по имени переменной и названию поля, которые
разделяются точкой.
  Например, при следующем описании
      type Angajat = record
                       NumePrenume         :   string;
                       ZileLucrate         :   1..31;
                       PlataPeZi           :   real;
                       PlataPeLuna         :   real;
                     end;
      var A : Angajat;

к элементам переменной А можно обращаться через A.NumePrenume,
A.ZileLucrate, A.PlataPeZi и A.PlataPeLuna.
   Так как имя А переменной типа запись постоянно повторяется, то такой
способ обращения к элементам является очень громоздким. Этих повторений
можно избежать при использовании оператора with (с).

                                                                              49
     Синтаксис данного оператора:
   <Оператор with> ::= with <Переменная> {,<Переменная>} do <Опера-
тор>
     Синтаксическая диаграмма представлена на рис. 1.6.

             <Оператор with>

                                 Переменная                Оператор



                 Рис. 1.6. Синтаксическая диаграмма оператора with
  Внутри оператора with к элементам одной или нескольких переменных
типа запись можно обращаться только по имени соответствующего поля.
  Пример:
      with A do PlataPeLuna:=PlataPeZi*ZileLucrate
     Этот оператор эквивалентен следующему:
      A.PlataPeLuna:=A.PlataPeZi*A.ZileLucrate
   Использование оператора with требует особого внимания от программиста,
который обязан объявлять однозначным образом элементы переменных типа
запись. Внутри оператора with, при появлении некоторого идентификатора,
вначале проводится проверка того, может ли он быть интерпретирован как имя
поля соответствующей записи. Если да, то он будет интерпретирован как имя поля,
даже если в данный момент доступна другая переменная под таким же именем.
   Пример:
      type Punct = record
                     x : real;
                     y : real;
                   end;
           Segment = record
                       A : Punct;
                       B : Punct;
                     end;
      var P : Punct;
          S : Segment;
          x : integer;

  В нашем случае идентификатор x может указывать на переменную x типа
integer или на поле P.x записи Р.
  В операторе
      x:=1
идентификатор x указывает на переменную x типа integer.

50
  В операторе
    with P do x:=1
идентификатор х указывает на поле Р.х переменной Р типа Punct.
   Так как переменная S типа Segment не содержит поля с именем S.x, то
в операторе
    with S do x:=1
идентификатор х будет интерпретирован как переменная х типа integer.
  Оператор вида

    with v1, v2, ..., vn do <Оператор>,
где v1, v2, ..., vn ― переменные типа запись, эквивалентен оператору:

    with v2 do
     {...}
    with vn do <Оператор>.

  Очевидно, что поля записей v1, v2, ..., vn должны быть определены одно-
значно.
  Например, для переменных Р и S, описанных выше, можно записать:

    with P, S do
    begin
      x:=1.0;   { ссылка на P.x }
      y:=1.0;
      A.x:=0;   { ссылка на S.A.x }
      A.y:=0;
      B.x:=2.0; { ссылка на S.B.x }
      B.y:=2.0;
    end;

  Как правило, оператор with используется только в тех случаях, когда это
приводит к значительному сокращению текста программы.


  Вопросы и упражнения
  Ê	 Укажите на синтаксической диаграмме рис. 1.6 пути, которые соответствуют
     операторам with из примеров, приведенных в данном параграфе.
  Ë	 В чем назначение оператора with?
  Ì	 ПРИМЕНИТЕ! Используя оператор with, исключите из программ Р85 и
     Р86, рассмотренных в предыдущем параграфе, повторения типа
       E1.Nume, E1.Prenume, ...,
       LE[i].Nume, LE[i].Prenume.

                                                                          51
     Í	 РЕШИТЕ! Даны следующие типы данных:
         type Angajat = record
                          NumePrenume : string;
                          ZileLucrate : 1..31;
                          PlataPeZi : real;
                          PlataPeLuna : real;
                        end;
              ListaDePlata = array [1..50] of Angajat;
     	  Ежемесячная зарплата каждого работника вычисляется путем умножения еже-
        дневной платы на количество отработанных дней. Напишите программу, которая:
     	 a) вычисляет ежемесячную зарплату каждого работника;
     	 б) вычисляет среднюю зарплату всех работников, включенных в список;
     	 в) выводит на экран данные о всех работниках, ежемесячная зарплата ко-
        торых максимальна;
     	 г) выводит на экран список работников в алфавитном порядке;
     	 д) выводит на экран список работников в порядке возрастания ежедневной платы;
     	 е) упорядочивает список работников в порядке возрастания ежемесячной
        зарплаты;
     	 ж) выводит на экран список работников в порядке возрастания количества
        отработанных дней.
     Î	 РЕШИТЕ! Окружность может быть задана через координаты х, у центра и
        радиус r. Напишите программу, которая считывает с клавиатуры данные
        об n окружностях (n≤50) и выводит на экран:
     	 а) координаты центра и радиус окружности, которая описывает круг мак-
        симальной площади;
     	 б) количество окружностей, входящих в круг с максимальным радиусом, и
        координаты соответствующих центров;
     	 в) координаты центра и радиус окружности, которая описывает круг мини-
        мальной площади;
     	 г) количество окружностей, в которые входит круг с минимальным радиусом,
        и координаты соответствующих центров.


     1.6. Тип данных множество
   Напомним, что множество состоит из физических или виртуальных (мыслен-
ных) объектов, обладающих общим свойством. Объекты, составляющие множество,
называются элементами множества. Элементы любого множества различны,
а их порядок не важен.


   В языке ПАСКАЛЬ тип данных множество определяется по отношению к
базовому типу, который должен быть порядковым:
    <Тип множество> ::= [packed] set of <Тип>
   Значениями типа данных множество являются множества, состоящие из
значений базового типа. Если базовый тип имеет n значений, то тип множе-
ство будет иметь 2 значений. Значение n ограничено: n≤256.
                     n

   В языке ПАСКАЛЬ элементы множества могут перечисляться в квадратных
скобках «[» и «]», которые являются аналогом фигурных скобок в математике.
   Запись [] означает пустое множество.

52
  Примеры:
    type Indice = 1..10;
         Zi = (L, Ma, Mi, J, V, S, D);
         MultimeIndicii = set of Indice;
         ZileDePrezenta = set of Zi;
    var MI : MultimeIndicii;
        ZP : ZileDePrezenta;
  Порядковый тип Indice имеет n=10 значений: 1, 2, 3, 4, 5, 6, 7,
                                     10
8, 9, 10. Тип MultimeIndicii имеет 2 = 1024 значений, а именно:
    [], [1], [2], ..., [1, 2], [1, 3], ...,
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].
  Таким образом, переменная МI может принимать любое из этих значений,
например:
    MI:= [1, 3].
  Порядковый тип Zi имеет n=7 значений: L, Ma, Mi, J, V, S, D. Тип
                      7
ZileDePrezenta имеет 2 = 128 значений, а именно:
    [], [L], [Ma], [Mi], ..., [L, Ma], [L, Mi], ...,
    [L, Ma, Mi, J, V, S, D].
  Переменная ZP может принимать любое из этих значений, например:
    ZP:= [L, Ma, Mi, V]
   Значения типа множество могут определяться через конструктор множе-
ства. Синтаксическая диаграмма грамматической единицы <Конструктор
множества> представлена на рис. 1.7.


     Конструктор множества



                     Выражение               Выражение




           Рис. 1.7. Синтаксическая диаграмма <Конструктор множества>

  Конструктор содержит значения элементов множества, разделенных за-
пятыми и заключенных в квадратные скобки. Элемент может являться кон-
кретным значением базового типа или интервалом вида:

    <Выражение>..<Выражение>.

                                                                        53
  Значения данных выражений представляют собой верхний и нижний
пределы интервала.
     Примеры:
     1)	 [];
     2)	 [1, 2, 3, 8];
     3)	 [1..4, 8..10];
     4)	 [i-k..i+k];	
     5)	 [L, Ma, V..D].
   К значениям типа данных множество можно применять обычные операции:
   + объединение;
   * пересечение;
   - разность,
результат которых относится к типу множество, и операции отношения:
   = равенство;
   <> неравенство;
   <=, >= включение;
   in принадлежность,
результат которых относится к типу boolean.
   Следующая программа выводит на экран результаты операций +, * и –,
применяемых к переменным типа MultimeIndicii.
     Program P87;
     { Данные типа MultimeIndicii }
     type Indice = 1..10;
           MultimeIndicii = set of Indice;
     var A, B, C : MultimeIndicii;
         i : integer;
     begin
       A:= [1..5, 8];      { A содержит 1, 2,    3, 4, 5, 8 }
       B:= [1..3, 9, 10]; { B содержит 1, 2,     3, 9, 10 }
       C:= [];             { C является пустым   множеством }
       C:=A+B;             { C содержит 1, 2,    3, 4, 5, 8, 9, 10 }

       writeln(’Объединение’);
       for i:=1 to 10 do
         if i in C then write(i:3);
       writeln;

       C:=A*B;            { C содержит    1, 2, 3 }
       writeln(’Пересечение’’);
       for i:=1 to 10 do
         if i in C then write(i:3);
       writeln;

54
    C:=A-B;             { C содержит         4, 5, 8 }
    writeln(’Разность’);
    for i:=1 to 10 do
       if i in C then write(i:3);
    writeln;
    readln;
  end.
  В отличие от массивов и записей, к компонентам которых существует
прямой доступ соответственно через индексы и названия полей, к элементам
множества прямого доступа нет. Допускается только проверка на принадлеж-
ность элемента множеству (операция отношения in). Благодаря этому при
использовании типов данных множество увеличивается скорость работы и
улучшается читабельность программ на языке ПАСКАЛЬ.
   Например, оператор
    if (c=’A’) or (c=’E’) or (c=’I’) or (c=’O’) or (c=’U’) then ...
можно заменить более простым оператором:

    if c in [’A’,’E’,’I’,’O’,’U’] then ...

Знаете ли вы?
Эратосфен был греческим математиком, гео-
графом, поэтом, астрономом и музыкантом,
жившим между 276 и 194 годами до нашей эры.
Он был первым человеком, который вычислил
окружность Земли, вычислил наклон оси враще-
ния Земли, сформулировал концепцию високос-
ного года, нарисовал одну из первых карт мира.
Эратосфен изобрел очень эффективный алго-
ритм для вычисления всех простых чисел, кото-
рые не превышают заданное число.
             Источник: : https://www.britannica.com
  Другим примером является использование типов данных множество для
вычисления простых чисел, меньших заданного n, где n ― натуральное число.
Для этого применяется алгоритм Решето Эратосфена:
  1) в решете находятся числа 2, 3, 4, ..., n;
  2) из решета удаляется наименьшее число i;
  3) указанное число включается в множество простых чисел;
  4) из решета удаляются все числа m, кратные числу i;
  5) процесс завершается, когда решето становится пустым.

  Program P88;
  { Решето Эратосфена       }
  const n = 50;

                                                                      55
     type MultimeDeNumere = set of 1..n;
     var Sita, NumerePrime : MultimeDeNumere;
          i, m : integer;
     begin
      {1} Sita:= [2..n];
           NumerePrime:=[];
           i:=2;
           repeat
      {2}     while not (i in Sita) do i:=succ(i);
      {3}     NumerePrime:=NumerePrime+[i];
              write(i:4);
              m:=i;
      {4}     while m<=n do
                 begin Sita:=Sita-[m]; m:=m+i; end;
      {5} until Sita=[];
           writeln;
           readln;
     end.
  Соответствие между шагами алгоритма и операторами программы, их ре-
ализующими, указано в виде комментариев в левой части строк программы.


  В языке C++ множества могут быть представлены одномерными массива-
ми. Обычно соответствующие компоненты объявлены порядковыми типами
данных: int, bool, char и enum.
   Примеры:
   1) множества A, содержащие до 100 целых чисел, могут быть представлены
массивом int A[100];
   2) множества B, содержащие до 26 символов латинского алфавита, могут
быть представлены массивом char B[26];
   3) множества Z, сформированные из значений типа данных enum Zi {L,
Ma, Mi, J, V, S, D}, могут быть представлены массивом Zi Z[7].
   Очевидно, что кроме самого массива, в котором хранятся элементы обраба-
тываемого множества, нам нужно будет объявить целочисленную переменную
n, в которой будет храниться текущее количество элементов этого множества.
   В случае вышеописанных множеств A, B и Z можно объявить переменные
nA, nB и nZ, например так: int nA, nB, nZ.
   Представляем далее программу, которая считывает с клавиатуры множе-
ства A и B, содержащие не более 20 целых чисел, и отображает на экране их
пересечение, то есть множество C = A     B.
   Напомним, что множество C должно содержать только те элементы, которые
есть как во множестве A, так и во множестве B.
     // Программа P87
     // Представление множеств через массивы
     // Пересечение множеств A и B

56
  #include <iostream>
  using namespace std;
  int main ()
  {
      int A[20], B[20], C[20],
           nA, nB, nC,
           i, j, k; // счетчики циклов
      bool Gasit;    // флажок: элемент множества A
                     // найден во множестве B
      cout << "Введите количество элементов множества A: ";
      cin >> nA;
      cout << "Введите элементы множества A:" << endl;
      for (i=0; i<nA; i++) cin >> A[i];
      cout << "Введите количество элементов множества B: ";
      cin >>nB;
      cout << "Введите элементы множества B:" << endl;
      for (j=0; j<nB; j++) cin >> B[j];
      nC=0; // изначально множество C пусто
      for (i=0; i<nA; i++)
        {
          Gasit = false;
          for (j=0; j<nB; j++) if (A[i]==B[j]) Gasit = true;
          if (Gasit==true) { C[nC] = A[i]; nC++; };
        }
      cout << "Количество элементов множества C = " << nC << endl;
      cout << "Множество C:" << endl;
      for (k=0; k<nC; k++) cout << C[k] << " ";
      cout << endl;
      return 0;
  }
   Другой метод представления множеств состоит в использовании так называе-
мых характеристических векторов. Этот метод предполагает, что существует
некое универсальное множество (universum), обозначенное через U, которое
содержит все элементы, из которых могут формироваться необходимые для об-
работки множества.
   Например, предполагается обработка множеств, элементами которых могут
быть натуральные числа, меньшие 100, тогда U = {0, 1, 2, 3, …, 99}. Подобным
образом, если предполагается обработка множеств, элементами которых могут
быть заглавные буквы латинского алфавита, тогда U = {A, B, C, …, Z}.
   Предположим, что универсальное множество содержит n элементов:
                           U = {u1, u2, u3, …, un},
а обрабатываемое множество содержит m элементов:
                           A = {a1, a2, a3, …, am}.
   Это множество может быть представлено на компьютере с помощью харак-
теристического вектора
                         V = (v1, v2, v3, …vi, …, vn),

                                                                         57
где

	
                              vi =   { 0,1,весли u ∈A;
                                                 i
                                             противном случае.
  Другими словами, компонент i характеристического вектора V имеет значе-
ние 1, если соответствующий элемент универсального множества принадлежит
множеству A, и значение 0 в противном случае.
  Например, если U = {1, 2, 3, 4, 5} и A = {2, 4}, то характеристический вектор:
                                 V = (0, 1, 0, 1, 0).
   Аналогично, если U = {a, b, c, d, e, f} и B = {a, c, e, f}, то характеристический
вектор:
                             V = (1, 0, 1, 0, 1, 1).
   Из вышеприведенных примеров видно, что количество компонентов харак-
теристического вектора V некоторого множества A совпадает с количеством
элементов n универсального множества U. Очевидно, что количество нену-
левых компонентов характеристического вектора V равно m ― количеству
элементов множества A.
   Наглядным примером использования характеристических векторов для
представления множеств, подлежащих обработке, является вычисление про-
стых чисел, меньших заданного натурального числа n. Для этого используется
алгоритм решета Эратосфена:
   1) в решете находятся числа 2, 3, 4, ..., n;
   2) из решета извлекается наименьшее число i;
   3) извлеченное число включается в множество простых чисел;
   4) все числа m, кратные числу i, удаляются из решета;
   5) процесс заканчивается, когда решето становится пустым.

     // Программа P88
     // Решето Эратосфена
     // Представление множеств через характеристические векторы
     // Universum U = {0, 1, 2, ..., n}
     #include <iostream>
     using namespace std;
     int main()
     {
       const int nmax = 51;
       int n, S[nmax], // Характеристический вектор решето
           P[nmax],    // Характеристический вектор Простые числа
           i,          // Извлеченное из решета число
           j, k;       // Счетчики циклов
       cout << "Введите n= "; cin >> n;
       // Помещаем числа 2, 3, 4, .., n in Sita
       S[0] = 0; S[1] = 0;
       for (j = 2; j <= n; j++) S[j] = 1;
       // Инициализируем множество простых чисел
       for (j = 0; j <= n; j++) P[j] = 0;
       // Извлекаем из решета наименьшее число i

58
    for (i = 2; i <= n; i++)
      {
        if (S[i] != 0)
          {
	           P[i] = 1; // включаем i во множество простых чисел
	           S[i] = 0; // Исключаем i из решета
	           // Исключаем из решета все кратные i числа
	           for (j = i; j <= n; j++) if ((j % i)==0) S[j] = 0;
          }
      }
    cout << "Простые числа:" << endl;
    for (j = 2; j <= n; j++) if (P[j] == 1) cout << j << ' ';
    cout << endl;
    return 0;
}


Вопросы и упражнения
Ê	 ОБРАТИТЕ ВНИМАНИЕ! (ПАСКАЛЬ) Перечислите допустимые значения
   переменных, описанных ниже:
     var V   :   set   of   ’A’..’C’;
         S   :   set   of   (A, B, C);
         I   :   set   of   ’1’..’2’;
         J   :   set   of   1..2;

Ë	 ОБРАТИТЕ ВНИМАНИЕ! (ПАСКАЛЬ) Прокомментируйте следующую прог-
   рамму:
Program P89;
{ Ошибка }
type Multime = set of integer;
var M : Multime;
     i : integer;
begin
  M:=[1, 8, 13];
  for i:=1 to MaxInt do
     if i in M then writeln(i);
end.
Ì	 УПРАЖНЯЙТЕСЬ! (ПАСКАЛЬ) Даны следующие объявления:
     type Culoare = (Galben, Verde, Albastru, Violet);
          Nuanta = set of Culoare;
     var NT : Nuanta;
	 Перечислите значения, которые может принимать переменная NT.
Í	 УПРАЖНЯЙТЕСЬ! (ПАСКАЛЬ) Напишите металингвистическую формулу,
   которая соответствует синтаксической диаграмме <Конструктор множе-
   ства> рис. 1.7.

                                                                  59
     Î	 УПРАЖНЯЙТЕСЬ! (ПАСКАЛЬ) Рассматривается тип данных MultimeIndicii,
        описанный в этом параграфе. Перечислите элементы множеств, определяемых
        следующими конструкторами:
     	   a)	 [];	                              f)	   [4..3];
     	   b)	 [1..10];	                         g)	 [1..3, 7..6, 9];
     	   c)	 [1..3, 9..10];	                   h)	 [4-2..7+1];
     	   d)	 [1+1, 4..7, 9];	                  i)	   [7-5..4+4];
     	   e)	 [3, 7..9];	                       j)	   [6, 9, 1..2].
     	 УПРАЖНЯЙТЕСЬ! (C++) Дано универсальное множество U = {L, Ma, Mi,
        J, V, S, D}, представляющее дни недели. Запишите характеристические
        векторы следующих множеств:
     	 A = {S, D} ― выходные дни недели;
     	 B = {L, Ma, Mi, J, V} ― рабочие дни недели;
     	 C = {L, Mi, J} ― дни, в которые проводятся консультации онлайн по информатике;
     	 D = {Ma, Mi} ― дни занятий в творческих кружках лицея;
     	 E = {Ma, J, V} ― дни занятий в спортивных секциях лицея;
     	 F = {L, V} ― дни, в которые организуются книжные выставки в библиотеке лицея.
     	 УПРАЖНЯЙТЕСЬ! (C++) Зная множества U, A, B, C, D, E, F, описанные в
        предыдущем задании, напишите характеристические векторы множеств,
        которые содержат:
     	 G ― дни недели, в которые занятия проходят как в творческих кружках, так
        и в спортивных секциях;
     	 H ― дни недели, в которые занятия проходят либо в творческих кружках,
        либо в спортивных секциях;
     	 I ― дни недели, в которые не работают как творческие кружки, так и спор-
        тивные секции.
     	 Напишите программу, которая вычисляет и отображает на экране эти мно-
        жества.
     	 ПРОГРАММИРУЙТЕ! Напишите программу, которая считывает с клавиа-
        туры элементы множеств A и B и отображает на экране:
     	 a) пересечение множеств A и B;
     	 б) объединение множеств A и B;
     	 в) разность множеств A и B.
     	 Множества A и B состоят из целых чисел.
     	 ПРОГРАММИРУЙТЕ! Напишите программу, которая считывает с клавиа-
        туры элементы множеств A и B и отображает на экране:
     	 a) пересечение множеств A и B;
     	 б) объединение множеств A и B;
     	 в) разность множеств A и B;
     	 Множества A и B состоят из заглавных букв латинского алфавита.
     Ó	 РЕШИТЕ! Напишите программу, отображающую на экране все подмноже-
        ства множества {1, 2, 3, 4}.
      	 РЕШИТЕ! Напишите программу, отображающую на экране все подмноже-
        ства множества {’A’, ’B’, ’C’, ’D’}.
      	 Рассматриваются строки символов, состоящие из прописных и строчных
        букв латинского алфавита, в которых слова разделены пробелом, точкой,
        запятой, точкой с запятой, восклицательным или вопросительным знаком.

60
        Разработайте программу, которая отображает на экране слова в строках,
        прочитанных с клавиатуры.
    	   Рассматриваются строки символов, состоящие из прописных и строчных
        букв латинского алфавита. Разработайте программу, которая отображает
        на экране количество гласных в строках, прочитанных с клавиатуры.
    	   Разработайте программу, которая считывает с клавиатуры две строки сим-
        волов и отображает на экране:
	       а) символы, которые встречаются хотя бы в одной из строк;
	       б) символы, которые появляются в обеих строках;
	       в) символы, которые появляются в первой строке и не появляются во второй строке.
    	   Имя человека считается написанным правильно, если оно состоит из пропис-
        ных и строчных букв латинского алфавита, начинается с заглавной буквы,
        а следующие буквы являются строчными. Напишите программу, которая
        проверяет, является ли строка, прочитанная с клавиатуры, правильным
        именем человека. Если имя правильное, на экране будет отображаться со-
        общение ПРАВИЛЬНО, а в противном случае ― сообщение НЕПРАВИЛЬНО.
    	   ТВОРИТЕ! (ПАСКАЛЬ) В текущих реализациях языка количество значений
        базового типа для типа данных множество ограничено, обычно n≤256. Сле-
        довательно, программа P88 не может вычислять простые числа больше n. Раз-
        работайте программу для вычисления простых чисел в диапазоне 8, ..., 10000.
	       Подсказка: решето в алгоритме Эратосфена можно представить в виде
        массива, компоненты которого являются множествами.
    	   ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. (C++) Напишите программу, которая
        вычисляет простые числа, используя алгоритм решета Эратосфена, пред-
        ставляющий множества чисел Sita и NumerePrime не характеристическими
        векторами, а массивами, содержащими их фактические элементы. Сравните
        сложность написанной программы с программой, использующей характе-
        ристические векторы.
    	   ТВОРИТЕ! Даны телевизионные каналы A и B. В определенные дни недели,
        не обязательно в одни и те же, каждый из этих каналов не транслирует художе-
        ственные фильмы. Например, канал A не транслирует художественные фильмы
        по понедельникам и пятницам, а канал B ― по вторникам и воскресеньям.
	       Напишите программу, которая для каждого из каналов A и B считывает с клавиа-
        туры дни недели, когда художественные фильмы не транслируются, и отображает
        на экране дни, когда у зрителя есть возможность посмотреть художественный
        фильм хотя бы на одном из каналов. Дни недели будут считываться с клавиатуры
        и отображаться на экране обычным образом, то есть понедельник, вторник, среда
        и т. д., без использования их порядковых номеров или сокращений.
	       Подсказка: используйте множества, элементы которых относятся к пере-
        числяемому типу данных.
    	   ИЗУЧИТЕ! (C++) Известно, что множества могут быть представлены одно-
        мерными массивами, компоненты которых содержат фактические элементы
        этих множеств. В то же время каждый массив должен ассоциироваться с це-
        лым числом ― количеством элементов этого множества. Например, в случае
        множества A, состоящего не более чем из 20 целых чисел, переменная nA
        ассоциируется с массивом int A[20].
	       Чтобы сделать программы более интуитивно понятными, множества также
        могут быть представлены с помощью типа данных запись, который имеет
        вид struct Multime {int E[nmax], nE;}. В этом типе данных массив E
        предназначен для хранения элементов множества, а переменная nE ― для
        хранения текущего количества элементов соответствующего множества.
	       Перепишите программы C++ из этого параграфа, используя для представ-
        ления множеств данные типа запись.

                                                                                     61
      	 УЧИТЕСЬ УЧИТЬСЯ! (C++) Стандартная библиотека языка C++ содер-
        жит специальный контейнер Set, предназначенный для представления и
        обработки данных типа множество. Рекомендуем увлеченным програм-
        мированием ученикам изучить индивидуально или в команде средства,
        предлагаемые в этом контейнере. Попробуйте переписать программы из
        этого параграфа, используя функции, определенные в контейнере Set.


     1.7. Общие сведения о файлах
   До сих пор разработанные нами программы считывали обрабатываемые
данные с клавиатуры и выводили результаты обработки на экран. Данные,
введенные с клавиатуры, сохранялись в переменных из соответствующих про-
грамм. Однако как только выполнение программы завершается, введенные
значения переменных теряются, что требует повторного ввода начальных
данных при новом запуске на выполнение программы. В случае объемных
входных данных их повторный ввод требует большого объема работы.
   В то же время из опыта, приобретенного в процессе обработки текстов, изо-
бражений, аудио- и видеофрагментов, мы уже знаем, что данные, подлежащие
обработке, и, конечно же, результаты обработки должны храниться в файлах.
Напомним, что файл представляет собой набор данных, который имеет имя и
хранится на внешнем носителе информации, например на магнитных дисках
или оптических дисках, флэш-памяти и т. д.
   Чтобы иметь возможность обрабатывать информацию из файлов на внеш-
них носителях, современные языки программирования содержат структури-
рованные типы данных, называемые файлами. В языках ПАСКАЛЬ и C++
под файлом понимается структура данных, состоящая из последовательности
компонентов (записей). Количество компонентов в последовательности явля-
ется произвольным, а конец последовательности обозначается специальным
символом EOF (End of File ― конец файла). Файл, не содержащий компонентов,
называется пустым файлом.
   В целом использование файлов дает следующие преимущества:
   – обеспечивается долгосрочное хранение как входных, так и выходных дан-
ных, пользователь имеет возможность вернуться к ним в любое время после
завершения процесса выполнения соответствующих программ;
   – программы становятся универсальными, так как одну и ту же программу
можно без изменений использовать для обработки данных из разных внешних
файлов;
   – сложная обработка может быть выполнена путем разделения задач между
разными более простыми программами, поскольку выходные данные одной прог-
раммы могут использоваться в качестве входных данных для другой программы.

     ВНИМАНИЕ!
     Способы обработки файлов в значительной степени зависят от специфики ис-
     пользуемых операционных систем и сред программирования. Как следствие,
     результаты, предоставляемые программами обработки файлов, могут отличаться
     от компьютера к компьютеру.
     Поэтому ученикам предлагается изучить средства обработки файлов методом ком-
     пьютерного эксперимента. Для этого рекомендуется писать и запускать небольшие
     программы, которые обрабатывают данные с внешних носителей.


62
   Под файлом понимают структуру данных, которая состоит из последовательно-
сти компонент. Все компоненты файла относятся к одному и тому же типу, который
называется базовым. Число компонентов файла является произвольным, однако
конец файла обозначается специальным символом: EOF (End of File – конец фай-
ла). Файл, который не содержит ни одного элемента, называется пустым файлом.
   Файловый тип данных определяется следующим образом:
    <Файловый тип> ::= [packed] file of <Тип>;
где <Тип> является базовым типом. Базовый тип может быть любым, кроме
самого файлового типа (не существует «файл файлов»).
  Примеры:
  1)	 type FisierNumere = file of integer;
  	 var 	 FN : FisierNumere;
      		  n : integer;
  2)	 type FisierCaractere = file of char;
  	 var 	 FC : FisierCaractere;
      		  c : char;
  3)	 type Elev = record
  				 Nume : string;
  				 Prenume : string;
  				 NotaMedie : real;
               	end;
  		       FisierElevi = file of Elev;
  	 var 	 FE : FisierElevi;
  		      E : Elev;
  Структура данных файлового типа представлена на рис. 1.8. Отметим, что
символ EOF, который означает конец файла, не является компонентом файла.




Рис. 1.8. Структура данных типа FisierNumere, FisierCaractere и FisierElevi

   Переменные FN, FC, FE файлового типа называются логическими
файлами, файлами языка ПАСКАЛЬ, или просто файлами. В отличие
от остальных типов данных, значения которых хранятся во внутренней па-

                                                                           63
мяти компьютера, данные файлов хранятся на периферийных устройствах
― носителях информации (на дисках, магнитных лентах, оптических дисках,
бумаге принтера или на устройстве считывания документов и др.). Информа-
ция на таких носителях хранится в виде внешних файлов в соответствии с
требованиями операционной системы. Таким образом, перед использованием
переменной файлового типа необходимо связать ее с некоторым внешним
файлом. Методы связи зависят от версии языка и операционной системы,
установленной на компьютере.
   В стандартной версии языка связь осуществляется посредством включения
переменных файлового типа в заголовок программы в качестве аргументов.
   В Turbo PASCAL связь файловой переменной f с внешним файлом осущест-
вляется вызовом процедуры:

      assign(f, s);

где s ― это выражение типа string, задающее путь доступа и имя внешнего
файла.
     Примеры:

     1)	 assign(FN, ’A:\REZULTAT\R.DAT’)

  – файл FN связывается с внешним файлом R.DAT, находящимся в каталоге
REZULTAT на диске A.
     2)	 assign(FC, ’C:\A.CHR’)
  – файл FC связывается с файлом A.CHR, находящимся в корневом каталоге
диска С.
     3)	 write(’Введите имя файла:’);
     	readln(str);
     	 assign(FE, str);
  – файл FE связывается с внешним файлом, имя которого считывается с
клавиатуры в переменную str типа string.
  После выполнения оператора assign(f, s) все операции, осуществляе-
мые над файлом f, фактически будут выполняться над внешним файлом s.
  Самыми распространенными операциями, выполняемыми над файлами,
являются считывание компонентов из файла и их запись в файл.
  Считывание текущей компоненты из файла осуществляется с помощью
оператора вызова процедуры:

      read( f, v),

где v ― переменная, которая относится к базовому типу файла f.
   Запись следующей компоненты в файл осуществляется с помощью опера-
тора вызова процедуры:
      write( f, e),
где e ― выражение, относящееся к базовому типу файла f.

64
     Примеры:
     1)	 read(FN, n);
     2)	 write(FC, c);
     3)	 read(FE, E).
   По типам операций, применяемых к компонентам, файлы подразделяются на:
   – входные (открыты только для чтения);
   – выходные (открыты только для записи);
   – рабочие (открыты и для чтения, и для записи).
   По методу доступа к компонентам файлы подразделяются на:
   – файлы последовательного доступа (доступ к компоненте i возможен только
после считывания или записи компоненты i – 1);
   – файлы прямого доступа (к любой компоненте есть прямой доступ через
ее порядковый номер i в файле).
   Отметим, что в стандартном языке допустимы только входные и выходные
файлы последовательного доступа.
   Тип файла (входной, выходной или рабочий) и метод доступа (прямой или
последовательный) задаются при открытии файла. В стандартном языке
существуют следующие процедуры для открытия файлов:
   reset( f ) ― открывает существующий файл для чтения;
   rewrite( f) ― создает пустой файл для записи.
   После завершения обработки компонент файл нужно закрыть. При за-
крытии файла операционная система записывает символ EOF, регистрирует
только что созданный файл в соответствующем каталоге и т. д.
   В стандартном языке по окончании работы программы все файлы закры-
ваются автоматически. В Turbo PASCAL закрытие файла f осуществляется
явно с помощью оператора процедуры close( f).
   В заключение приведем порядок вызова процедур, предназначенных для
обработки данных файлового типа:
1)     assign ( f, s)               ― связывание файловой переменной f с внешним
                                      файлом s;
2)     reset( f )/rewrite( f )      ― открытие файла f для чтения / записи;
3)     read( f, v )/write( f, e )   ― чтение/запись текущей компоненты файла f;
4)  close( f )              ― закрытие файла f.
  После закрытия файла переменная f может быть связана с другим внеш-
ним файлом.
  Так как значения переменных файлового типа хранятся на внешних носителях
информации, в языке ПАСКАЛЬ оператор присваивания файлов запрещен.


  В языке C++ файл состоит из записей (компонентов), размер которых может
быть фиксированным или переменным. Количество записей в файле ограни-
чено только емкостью используемого физического носителя.
  В зависимости от типа операций, разрешенных для компонентов,
файлы классифицируются по следующим категориям:

                                                                                   65
   –	 входные файлы (разрешено только чтение);
   –	 файлы вывода (разрешена только запись);
   –	 обновляемые файлы (разрешены как запись, так и чтение).
   По доступу к компонентам файлы подразделяются на:
   –	 файлы с последовательным доступом (записи могут обрабатываться
только в том порядке, в котором они хранятся в файле);
   –	 файлы с прямым доступом (компоненты можно обрабатывать в любом
порядке). В этом случае перед каждой операцией чтения/записи указывается
информация, необходимая для выбора компонента для обработки.
   По интерпретации содержимого файлы делятся на:
   –	 текстовые файлы, содержащие только символы, организованные по
строкам;
   –	 двоичные файлы, в которых информация рассматривается как набор
байтов.
   С файлами можно выполнять следующие операции:
   –	 открытие файла;
   –	 чтение данных из файла/запись данных в файл;
   –	 закрытие файла.
   В языке C++ обработка данных из внешних файлов осуществляется с по-
мощью потоков.
   Потоки – это объекты, которые транспортируют и форматируют строки
байтов. В качестве примера упомянем уже известные нам потоки:
   cin ― поток, предназначенный для чтения данных с внешнего носителя
информации стандартного устройства ввода, обычно с клавиатуры;
   cout ― поток, предназначенный для записи данных на внешний носитель
информации стандартного устройства вывода, обычно на экран.
   Программист также может создавать собственные потоки. Такие потоки долж-
ны быть ассоциированы/связаны с файлами на внешних устройствах, например
с файлами на магнитных дисках или флэш-памяти. После осуществления такой
ассоциации операция включения данных в поток приводит к их записи в связан-
ный файл, а операция извлечения данных из потока ― к чтению их из этого файла.
   Напоминаем, что включение данных в поток осуществляется с помощью
оператора <<, а извлечение данных ― с помощью оператора >>.
   Чтобы иметь доступ к функциям для работы с потоками и файлами в про-
граммы на C++ необходимо включить директиву:
     #include <fstream>
   Создание входного потока и его связывание с некоторым внешним файлом
осуществляются с помощью следующей грамматической конструкции:
     ifstream <Имя входного потока> (”<Имя внешнего файла >”);
   Очевидно, что внешний файл, из которого будут считываться данные,
должен существовать на внешнем носителе в момент запуска программы на
выполнение. В противном случае в процессе выполнения программы, при
попытке связать входной поток с внешним файлом возникнет ошибка
   Создание выходного потока и его связывание с внешним файлом
осуществляются с помощью следующей грамматической конструкции:
     ofstream <Имя выходного потока> (”<Имя внешнего файла>”);

66
  Если на момент связывания выходного потока с внешним файлом послед-
ний еще не существует, он будет создан автоматически. Если внешний файл
уже существует, все записи в нем будут удалены.
  Примеры:
  1)		 ifstream FI(”C:\REZULTAT\R.DAT”);
  –	 создание входного потока FI и его ассоциация с внешним файлом R.DAT
     из папки REZULTAT на диске C:.
  2)		 ofstream FE(”D:\D.CHR”);
  –	 создание выходного потока FE и его ассоциация с внешним файлом D.CHR
     из корневого каталога диска D:.
  3)		 cout << (”Введите имя файла:”);
  		 cin << (Str);
  		 ofstream FE(Str);
    –	 создание выходного потока FE. Поток FE связан с внешним файлом, имя
       которого считывается с клавиатуры и сохраняется в переменной типа
       string Str.
    Подчеркнем тот факт, что в последнем примере имя внешнего файла не-
известно во время написания программы, оно читается с клавиатуры только
во время выполнения программы. Такой подход позволяет разрабатывать
программы, которые могут обрабатывать данные не только из определенного
внешнего файла, но и из любого другого файла, указанного пользователем.
    Переменные (потоки) FI и FE в вышеприведенных примерах также назы-
ваются логическими файлами, или просто файлами. В отличие от других
типов данных, значения которых хранятся во внутренней памяти компьютера,
файловые данные хранятся на носителях информации периферийного обо-
рудования (диски и магнитные ленты, оптические диски, флэш-память и т.
д.). Информация на исследуемых носителях организована в виде внешних
файлов в соответствии с требованиями операционной системы.
    Подчеркнем, что, если пользователь не указывает полное имя внешнего
файла (каталог, в котором он находится, и его фактическое имя), поиск файла/
создание файла будет осуществляться в каталоге среды разработки программ
C++, установленном по умолчанию.
    Закрытие файлов, связанных с потоками, производится вызовом вида:
    <Имя потока>.close();
  Примеры:
    FI.close(); FE.close();
   После того как файл был закрыт, в него больше нельзя записывать и из него
нельзя считывать данные. Однако эти операции становятся возможными после
повторного открытия файла. Другими словами, запись или чтение данных,
в зависимости от ситуации, возможны только в период, когда файл открыт.
   Очевидно, что файл, который был ранее открыт, а затем закрыт, может
быть повторно открыт с любым из потоков в разрабатываемой программе, не

                                                                         67
обязательно только с тем, с которым он был ранее связан. Другими словами, по-
токи (логические файлы) могут использоваться для открытия любых внешних
файлов, а внешние файлы могут быть открыты любым из потоков в программе.
   Чтение данных из внешнего файла выполняется с помощью оператора
извлечения данных из входного потока, ассоциированного с этим файлом:
      <Имя потока> >> <Переменная> { >> <Переменная> };
     Примеры:
     1)	 FI >> x;
     2)	 FI >> x >> y;
     3)	 FI >> x >> y >> z;
  Запись данных во внешний файл осуществляется с помощью оператора
включения данных в выходной поток, связанный с соответствующим файлом:
      <Имя потока> << <Выражение> { << <Выражение> };
     Примеры:
     1)	 FE << x;
     2)	 FE << ”x=” << x;
     3)	 FE << x ” ” << y << ” ” << z;
   В заключение представим порядок, в котором необходимо вызывать функ-
ции, предназначенные для обработки файлов.
   1) Ассоциация/связывание потока f с внешним файлом s и его открытие
для чтения/записи: ifstream f(s), respectiv, ofstream f(s).
   2) Чтение/запись компонента файла, связанного с потоком f: f >> v, со-
ответственно f << e.
   3) Закрытие файла, связанного с потоком f: f.close().
   После закрытия файла поток f может быть ассоциирован с другим внешним
файлом.

     Вопросы и упражнения
     Ê	 Объясните термины логический файл, внешний файл.
     Ë	 Где хранятся данные логического файла? А данные внешнего файла?
     	 Как классифицируются файлы в зависимости от операций, которые с ними
        можно осуществлять и в зависимости от способа доступа к их компонентам?
     	 Какие операции можно осуществлять с файлами? А с компонентами файла?
     	 Для чего нужна операция связывания логического файла с внешним фай-
        лом?
     	 Для чего нужны операции открытия и закрытия файлов? Как они осущест-
        вляются?
     	 В каком порядке необходимо осуществлять операции обработки данных из
        входного файла? А из выходного файла?

68
	 УПРАЖНЯЙТЕСЬ! Нарисуйте структуру, подобную той, которая приведена
   на рисунке 1.8, для следующих типов данных:
     a)	 type 	Tabel = array [1..5, 1..10] of real;
     		        FisierTabele = file of Tabel;
     b)	 type	 Multime = set of ’A’..’C’;
     		        FisierMultimi = file of Multime;
     c)	 type	 Punct = record x, y:real end;
     		        Segment = record A, B:Punct end;
     		        FisierSegmente = file of Segment;

	 Для чего нужны процедуры read и write? Какого типа должна быть пере-
   менная v в вызове процедуры read(f, v)? Какого типа должно быть выраже-
   ние e в вызове процедуры write(f, e)?
	 ПРОАНАЛИЗИРУЙТЕ! Даны следующие объявления:
        type Numere   = file of integer;
        var F, FIN,   FOUT : Numere;
            i, j, k   : integer;
            x, y, z   : integer;
	    Объясните, какие операции будет выполнять программа в процессе выпол-
     нения следующих последовательностей операторов:
     a)	 assign(F, ’EXP.DAT’);
         rewrite(F);
         i:=10; write(F, i);
         j:=20; write(F, j);
         k:=30; write(F, k);
         close(F);
     b)	 assign(F, ’EXP.DAT’);
         reset(F);
         read(F, x);
         read(F, y);
         read(F, z);
         close(F);
     c)	 assign(FOUT, ’EXP.DAT’);
         rewrite(FOUT);
         i:=40; j:=50; k:=60;
         write(FOUT, i); write(FOUT, j); write(FOUT, k);
         close(FOUT);
         assign(FIN, ’EXP.DAT’);
         reset(FIN);
         read(FIN, x); read(FIN, y); read(FIN, z);
         close(FIN);
    	 В условиях предыдущего задания, какие значения примут переменные x,
      y, z, если последовательности операторов a), b) и c) будут выполняться
      одна за другой?

                                                                         69
         	 Переменные A и B объявлены следующим образом:
             	   var A, B : file of integer;
     	       Корректна ли следующая запись?
         	       A:=B
     	       Обоснуйте свой ответ.


         	 Как объявляются потоки данных? Как ассоциируется поток с некоторым
           внешним файлом?
         	 ПРОАНАЛИЗИРУЙТЕ! Даны объявления:
                 int i, j, k,
                 int x, y, z;
             Объясните, какие операции программа будет выполнять в процессе выпол-
             нения следующих последовательностей инструкций:
     	       a)	 ofstream F(”EXP.DAT”);
                 i:=10; F << i << ” ”;
                 j:=20; F << j << ” ”;
                 k:=30; F << k;
                 F.close();
     	       	b)	 ifstream F(”EXP.DAT”);
                  F >> x;
                  F >> y;
                  F >> z;
                  F.close();
     	       c)	 ofstream FOUT(”EXP.DAT”);
                 i:=40; j:=50; k:=60;
                 FOUT << i << ” ” << j << ” ” << k;
                 FOUT.close();
                 ifstream FIN(”EXP.DAT”);
                 FIN >> x >> y >> z;
                 FIN.close();

         	 ПРОАНАЛИЗИРУЙТЕ! В условиях предыдущего задания, какие значения
           примут переменные x, y, z, если последовательности операторов a), b) и
           c) будут выполняться одна за другой?
         	 ПРОАНАЛИЗИРУЙТЕ! Переменные A и B объявлены следующим образом:
                 fstream A(”text.in”);
                 ofstream B(”test.out”);

     	       Корректен ли следующий оператор?

                 B=A

     	       Обоснуйте свой ответ.

70
      	 ИЗУЧИТЕ! Кроме входных (ifstream) и выходных потоков (ofstream),
        язык C++ предоставляет пользователям поток типа fstream. Создание
        потока такого типа и его связывание с внешним файлом осуществляются с
        помощью грамматической конструкции:
         fstream <Имя входного/выходного потока > (”<Имя внешнего файла >”,
      <Опция>);

  	    где <Опция> указывает способ открытия потока. Используя систему под-
       держки среды разработки программ и интернет-источники, выясните назна-
       чение опций, которые можно использовать для связывания таких потоков с
       внешними файлами. Заполните таблицу:
        Опция           Назначение
        ios::in
        ios::out
        ios::app
        ios::ate
        ios::trunc
        ios::binary

      	 ИЗУЧИТЕ! В языке C++ есть несколько функций, предназначенных для
        проверки текущего состояния потока. Используя систему поддержки среды
        разработки программ и интернет-источники, выясните, какие результаты
        возвращают эти функции, и заполните таблицу:
        Функция         Назначение
        bad()
        fail()
        eof()
        good()
        clear()




  1.8. Файлы с последовательным доступом

  Рассмотрим следующие описания:
      type FT = file of T;
      var f : FT; v : T;

посредством которых определяются файловый тип FT с базовым типом T,
файловая переменная f и переменная v типа T.
  Для открытия выходного файла последовательного доступа применяют
вызов процедуры rewrite(f). Затем в файл записываются соответствующие
компоненты. Запись отдельных компонент производится с помощью процедуры:

                                                                          71
         write(f, e),

где е ― выражение типа Т. Оператор вида
         write(f, e1, e2, ..., en)
эквивалентен последовательности операторов
         write(f, e1) ; write(f, e2); ...; write(f, en).
     После записи последней компоненты файл необходимо закрыть.
     Пример:
     Program P90;
     { Создание файла с компонентами типа Elev }
     type Elev = record
                    Nume : string;
                    Prenume : string;
                    NotaMedie : real;
                  end;
           FisierElevi = file of Elev;
     var FE : FisierElevi;
         E : Elev;
         str : string;
         i, n : integer;
     begin
       write(’Введите имя создаваемого файла: ’);
       readln(str);

         assign(FE, str);            { связывает FE с именем str }
         rewrite(FE);                { открывает файл FE для записи }

         write(’Введите количество учеников: ’); readln(n);

         for i:=1 to n do
           begin
             writeln(’Введите данные об ученике            ’, i);

                	   { Считывает поля переменной Е с клавиатуры }
                	   write(’Фамилия: ’);     readln(E.Nume);
                	   write(’Имя: ’); readln(E.Prenume);
                	   write(’Средняя оценка: ’); readln(E.NotaMedie);

     	     { Записывает значение переменной Е в файл FE }
            write(FE, E);
          end;
       close(FE);           { Закрывает файл FE }
       readln;
     end.

72
  Для открытия входного файла последовательного доступа используется
процедура reset(f). Чтение текущего элемента из файла выполняют с помо-
щью вызова процедуры:
    read(f, v).
  Оператор вида
    read(f, v1, v2, ..., vn)
эквивалентен последовательности операторов
    read(f, v1); read (f, v2); ..., read (f, vn).
  Конец файла можно обнаружить с помощью булевой функции eof(f), кото-
рая возвращает значение true после чтения последнего элемента.
  Пример:
  Program P90;
  { Считывание файла с элементами типа Elev }
  type Elev = record
                 Nume : string;
                 Prenume : string;
                 NotaMedie : real;
               end;
        FisierElevi = file of Elev;
  var FE : FisierElevi;
      E : Elev;
      str : string;
  begin
    write(’Введите имя файла:’);
    readln(str);

    assign(FE, str);           { связывает FE с именем str }
    reset(FE);                 { открывает файл FE для чтения }

    while not eof(FE) do
      begin
     	    { считывает E из файла FE }
     	    read(FE, E);
     	    { выводит E на экран }
     	    writeln(E.Nume, ’ ’, E.Prenume, ’:’,
  			            E.NotaMedie : 5:2);
       end;
    close(FE);           { закрывает файл FE }
    readln;
  end.
   Отметим, что число элементов файла заранее неизвестно и не задается в
описании соответствующего типа. Следовательно, в выходной файл после-
довательного доступа теоретически можно записать бесконечное множество

                                                                     73
элементов. Однако практически количество элементов ограничено емкостью
внешнего носителя информации. Считывание элементов любого входного файла
последовательного доступа завершается при достижении символа EOF.


   В случае файла с последовательным доступом его компоненты могут быть
доступны только один за другим, начиная с первого. Следующая программа
показывает, как создать файл с последовательным доступом.

      // Создание файла с последовательным доступом
      #include<iostream>    //для использования cout
      #include<fstream>     //для использования ofstream
      using namespace std;
      int main()
      {
        ofstream f(”test.out”);   // открывает файл для записи
        f << ”Мой первый файл!” << endl; //записывает в файл
        cout << ”Файл создан” << endl;
        return 0;
      }
   После запуска этой программы на экране монитора появится сообщение
Файл создан, а в папке проекта мы найдем файл test.out, который сможем
прочитать с помощью любого текстового редактора, например приложения
Notepad (Блокнот) в операционной системе Windows. Вновь созданный файл
также можно открыть с помощью команды Open (Открыть) в меню File сре-
ды разработки программ C++. Очевидно, что рассматриваемый файл будет
содержать текст Мой первый файл!
   Как подчеркивалось в предыдущем параграфе, в языке C++ файлы обра-
батываются как байтовые последовательности. Следовательно, группировка
данных из файлов в лексические единицы (целые числа, вещественные чис-
ла, строки символов и т. д.) является обязанностью программиста. Для более
глубокого понимания этого подхода рассмотрим следующую практическую
задачу, часто встречаемую в повседневной жизни.
   Задача: Для каждого ученика класса известны следующие данные: имя, фа-
милия, средний балл по определенному школьному предмету. Эти данные необ-
ходимо хранить в файле с последовательным доступом и отобразить их на экране.
   Решение: В следующей программе соответствующие данные считываются
с клавиатуры, сохраняются в таблице e[50] и одновременно сохраняются в
файле elevi.in.

     // Программа P90
     // Создания файла с данными об учениках
     #include <iostream>
     #include <fstream>
     #include <cstring>
     using namespace std;

74
  int main()
  {
       ofstream f(”elevi.in”);
       struct elev
       {
          char nume [15];
          char prenume[20];
          float NotaMedie;
       };
    int i,n;
     elev e[50];
     cout<<"Введите количество учеников ";
     cin>>n;
     cin.get();
     for (i=1;i<=n;i++)
       {
          cout<<"Введите фамилию ученика "<<i<<" ";
          cin.get(e[i].nume,15);
          cin.get();
          cout<<"Введите имя ученика "<<i<<" ";
          cin.get(e[i].prenume,20);
          cin.get();
          cout<<"Введите средний балл ";
          cin>>e[i].NotaMedie;
          cin.get();
         f<<e[i].nume<<' '<<e[i].prenume<<' '<<e[i].NotaMedie<<endl;
       }
    f.close();
    return 0;
  }

   В этой программе извлечение фамилии и имени очередного ученика из
входного потока cin или, другими словами, чтение значений переменных
Nume и Prenume с клавиатуры выполняется с помощью функции get. Если
список аргументов в вызове этой функции не пуст, она извлекает (считывает)
из обработанного потока строку символов и помещает ее в эту переменную. В
случае вызова без аргументов функция get просто перемещает курсор через
один символ, в нашем случае это специальный символ EOL. Помните, что
символы EOL появляются в потоке cin при нажатии клавиши <ENTER>.
   Текущее значение переменной NotaMedie извлекается из входного потока
cin с помощью оператора >>. Этот оператор считывает, начиная с текущей
позиции курсора, вещественное число из обрабатываемого потока и помещает
его в переменную NotaMedie. В результате считывания курсор переместится
после последней цифры этого числа, в нашем случае перед символом EOL.
Для того чтобы перевести курсор через этот символ, вызывается функция get,
естественно, без аргументов.
   Считанные с клавиатуры данные об ученике включаются (записываются)
в выходной поток f, связанный с внешним файлом elevi.in.

                                                                       75
   Поскольку в языке C++ любой поток представляет собой последовательность
символов, не имеющую определенной структуры, простого включения строк
Nume, Prenume и вещественного числа NotaMedie в выходной поток будет не-
достаточно. Проблема в том, что любая программа, которая читает этот файл,
не будет знать, где заканчивается строка символов Nume и где начинается
строка символов Prenume. Чтобы решить эту проблему, в данной программе,
в выходном потоке после каждого значения Nume, Prenume ставится пробел, а
после каждого значения NotaMedie ― специальный символ EOL (конец строки).
   Очевидно, что после завершения процесса выполнения программы P90
данные в таблице e[5] будут потеряны, а данные во вновь созданном файле
elevi.in будут сохранены на внешнем носителе информации. Считывание
данных из этого файла и отображение их на экране можно выполнить с по-
мощью следующей программы.
     // Программа P91
     // Считывание файла, содержащего данные об учениках
     #include <iostream>
     #include <fstream>
     using namespace std;
     int main()
     {
       ifstream f(”elevi.in”); //открывается файл ”elevi.in”
       struct elev
        {
          char nume [15];
          char prenume[20];
          float NotaMedie;
        };

         elev e;
         f>>e.nume>>e.prenume>>e.NotaMedie;
         while (!f.eof())
          {
            cout<<e.nume<<’ ’<<e.prenume<<’ ’<<e.NotaMedie<<endl;
            f>>e.nume>>e.prenume>>e.NotaMedie;
          }
         f.close(); //Закрывает файл
         return 0;
     }
   Данные из входного потока f извлекаются (читаются) до тех пор, пока
функция eof не сообщит о достижении символа EOF, то есть о конце внешнего
файла elevi.in.
   Подчеркнем, что разработка программ последовательной обработки фай-
лов возможна без предварительного знания количества компонентов в этих
файлах. Теоретически количество компонентов, которые можно записать в
файл последовательного вывода, не ограничено. На практике, однако, это
количество ограничено емкостью внешнего носителя информации. В случае
входных файлов программа должна закончить чтение компонентов из файла
последовательного доступа в момент достижения элемента EOF.

76
 Вопросы и упражнения
 Ê	 Из скольких компонентов может состоять файл? В каком порядке записы-
    ваются и считываются компоненты файла с последовательным доступом?
 Ë	 УПРАЖНЯЙТЕСЬ! Даны следующие типы данных:
             ПАСКАЛЬ                                  C++
type Data = record                     struct Data
              Ziua : 1..31;                {
              Luna : 1..12;                  int Ziua, Luna, Anul;
              Anul : integer;              };
            end;                       struct elev
     Persoana = record                     {
          NumePrenume : string;              char NumePrenume [40];
          DataNasterii : Data;               Data DataNasterii;
                 end;                      };
     FisierPersoane = file of
Persoana;
 	    Напишите программу, которая считывает с клавиатуры данные об n лицах
      (фамилия, имя, дата рождения) и записывает их в файл. Создайте файлы:
      FILE1.PRS, FILE2.PRS, FILE3.PRS, в которых должны содержаться данные
      соответственно 2, 7 и 10 человек.
 Ì	   РЕШИТЕ! Напишите программу, которая читает файлы, созданные прог-
      раммой из предыдущего упражнения, и выводит на экран:
 	    a)	 данные о всех лицах, внесенных в файл;
 	    б)	 данные о лицах, родившихся в год а;
 	    в)	 данные о лицах, у кого дата рождения z.l.a;
 	    г)	 данные о самом старшем человеке;
 	    д)	 данные о самом младшем человеке.
 Í	   РЕШИТЕ! Напишите программу, которая выводит на экран среднее ариф-
      метическое чисел, записанных в файле с вещественными числами.
 Î	   РЕШИТЕ! В файле записаны произвольные символы. Напишите программу,
      которая выводит на экран количество согласных, содержащихся в файле.
 Ï	   ОБРАТИТЕ ВНИМАНИЕ! Прокомментируйте программу:
             ПАСКАЛЬ                                  C++
Program P92;                           // Программа P92
{ Ошибка }                             // Ошибка
type                                   #include <iostream>
     FisierNumere = file of            #include <fstream>
integer;                               using namespace std;
var FN : FisierNumere;                 int main()
     i : integer;                      {
     r : real;                           char s[10];
     s : string;                         cout<<”Имя файла: \n”;
begin                                    cin>>s;
  Writeln(’Имя файла: ’);                ifstream FN(s);
  readln(s);                             int i;

                                                                        77
  assign(FN, s);                              float r;
  rewrite(FN);                                i=1;
  i:=1;                                       FN<<i;
  write(FN, i);                               i=10;
  i:=10;                                      FN<<i;
  write(FN, i);                               r=20;
  r:=20;                                      FN<<r;
  write(FN, r);                               FN.close();
  close(FN);                                  return 0;
end.                                      }



     1.9. Текстовые файлы
   Известно, что данные логических файлов в программах, написанных на
языке высокого уровня, представлены последовательностями двоичных цифр.
Такой способ представления данных удобен для внешних запоминающих
устройств (магнитных дисков и лент, оптических дисков, флэш-памяти и
др.). В случае устройств ввода-вывода (клавиатура, экран, принтер и т. д.)
данные должны быть представлены в понятной человеку форме, т.е. после-
довательностями символов.
   Чтобы облегчить взаимодействие между человеком и компьютером, на
языках высокого уровня информация, предназначенная для пользователя,
представлена в виде текстовых файлов. Текстовый файл состоит из по-
следовательности символов, разделенных на строки (рис. 1.9). Длина строк
варьирует. Конец каждой строки обозначается специальным элементом, обо-
значенным EOL (End Of Line). Поскольку длина строк является переменной,
положение строки в любом текстовом файле невозможно рассчитать заранее.
Следовательно, доступ к компонентам текстовых файлов является последова-
тельным. Другими словами, запись или чтение компонента, то есть символа
или строки, возможны только после того, как предыдущий компонент был
прочитан или записан.




                      Рис. 1.9. Структура текстового файла

  В рамках лицейской учебной дисциплины «Информатика» изучаются сле-
дующие способы записи/чтения текстовых файлов:
  - на уровне символа;
  - на уровне лексемы;
  - на уровне строк.

78
    В случае обработки на уровне символов данные во внешнем файле читаются
/ записываются посимвольно, каждый из символов сохраняется в переменной
типа char. Объединение этих символов в числа или строки является обязан-
ностью программиста.
    Программист также должен позаботиться об обработке специальных эле-
ментов EOL (end of line ― конец строки).
    В случае обработки на уровне лексем данные записываются и читаются с
использованием функций и процедур, которые «собирают» данные из внешнего
файла в числа и строки и сохраняют их, в зависимости от ситуации, в переменных
целого, вещественного, строкового типа. Очевидно, что рассматриваемые лексемы
должны быть разделены белыми символами (пробел, табуляция или конец строки).
    Например, предположим, что входной файл содержит следующие данные:
    82 3.14 ПРИНЯТ <EOL><EOF>
   Интуитивно понятно, что входной файл содержит целое число 82, веще-
ственное число 3,14 и строку символов ПРИНЯТ.
   Обработка этого файла на уровне символов заключается в последовательном
чтении каждого из символов, в нем содержащихся:
    8 2     3 . 1 4      П Р И Н Я T

и помещая их в переменные типа char, объявленные в программе. Далее
программист должен будет дополнительно написать последовательность опе-
раторов, преобразующих считанные символы в нужные ему значения.
   Обработка того же файла на уровне лексем включает чтение символов во
входном файле и их группировку в три лексемы:
    82 3.14 ПРИНЯТ
   Впоследствии полученные таким образом лексемы автоматически преоб-
разуются во внутреннее представление и хранятся в переменных соответству-
ющего типа: integer/int, real/float и строка символов.
   В случае обработки на уровне строк данные во внешнем файле читаются/
записываются построчно, причем каждая строка сохраняется в переменной
тип строка символов.
   Обработка на уровне символов полезна при программировании алгоритмов
редактирования текстов, например при построении последовательности слов
и предложений, делении слов на слоги и т. д., а обработка на уровне лексем
― в случае программирования алгоритмов обработки преимущественно чис-
ловых данных. Обработка на уровне строк дает пользователю возможность
манипулировать как отдельными символами, так и лексемами, используя
предопределенные функции для обработки строк.


   В языке ПАСКАЛЬ текстовый файл задается описанием вида:
    var f : text;
где предопределенный тип text известен любой программе на языке
ПАСКАЛЬ. Отметим, что типы text и file of char различны, так как файл

                                                                           79
file of char не содержит символов EOL. Чтобы в этом убедиться, достаточно
сравнить соответствующие структуры, представленные на рис.1.8 и рис. 1.9.
   Обработка файлов типа text может осуществляться с помощью известных
процедур, применимых к любым типам файлов: assign, reset, rewrite,
read, write, close. В дополнение к ним в языке есть специальные про-
цедуры для обработки элементов EOL:
   writeln(f)― записывает в файл элемент EOL (конец строки);
   readln(f)― переход на следующую строку.
   Конец строки определяется с помощью булевой функции eoln(f), которая
принимает значение true после считывания последнего символа строки.
   Оператор вида

      writeln(f, e1, e2, ..., en)

эквивалентен последовательности операторов:

      write(f, e1, e2, ..., en); writeln(f).

     Оператор вида
      readln(f, v1, v2, ..., vn)
эквивалентен последовательности операторов:
      read(f, v1, v2, ..., vn); readln(f).
   Для ввода и вывода данных используются, как правило, предопреде-
ленные текстовые файлы Input и Output, известные любой программе на
языке ПАСКАЛЬ. Файл Input предназначен только для чтения и связан
со стандартным устройством ввода операционной системы (как правило, с
клавиатурой). Файл Output предназначен только для записи и связан со
стандартным устройством вывода (как правило, экраном). Эти файлы от-
крываются и закрываются автоматически в начале и соответственно в конце
выполнения программы. Если при вызове процедур ввода/вывода имя файла
не указано в списке параметров, то предполагается, что текстовым файлом
является файл Input или файл Output, в зависимости от ситуации. Напри-
мер, read(c) эквивалентен read(Input, c), а write(c) эквивалентен
write(Output, c).
   Для примера представляем программу, которая создает внешний файл
LISTA.TXT, содержащий фамилию и имя n учеников, количество которых
неизвестно на момент написания программы.

     Program P93;
     { Создание текстового файла LISTA.TXT способом        }
      { обработки на уровне строк                                  }
     var F : text;        { логический файл }
         n : integer;     { количество учеников }
         NP : string;     { фамилия и имя ученика }
         i : integer;     { счетчик цикла }

80
  begin
    { связывание логического файла F с внешним файлом }
    assign(F, 'LISTA.TXT');
    { Открытие файла F для записи }
    rewrite(F);
    { Считывание с клавиатуры количества учеников }
    write('Введите количество учеников n=');
    readln(n);
    { Запись количества учеников в файл F }
    writeln(F, n);
    { цикл по количеству учеников }
    for i:=1 to n do
       begin
         { Считывание с клавиатуры фамилии и имени }
         writeln('Введите фамилию и имя ученика ', i, ':');
         readln(NP);
         {Запись фамилии и имени в файл F }
         writeln(F, NP);
       end;
    { Закрытие файла F }
    close(F);
    writeln('Были введены данные ', n, ' учеников');
    readln;
  end.

  В продолжение предыдущего примера представим программу, считываю-
щую данные из внешнего файла LISTA.TXT и отображающую их на экране.

  Program P94;
  { Считывание текстового файла LISTA.TXT способом }
   { обработки на уровне строк                      }
  var F : text;        { логический файл F    }
      n : integer;     { количество учеников }
      NP : string;     { фамилия и имя        }
      i : integer;     { счетчик цикла        }
  begin
    { Связывание логического файла F с внешним файлом }
    assign(F, 'LISTA.TXT');
    { Открытие файла F для чтения }
    reset(F);
    { Считывание количества учеников n из файла F }
    readln(F, n);
    { Отображение на экране количества учеников n }
    writeln('Количество учеников n=', n);
    { Цикл по количеству учеников }
    for i:=1 to n do

                                                                 81
          begin
            readln(F, NP); { считывание NP из файла F }
            writeln(NP);   { отображение NP на экране }
          end;
       close(F);           { закрытие файла F         }
       readln;
     end.

  Обработка на уровне символов
  Текстовые файлы могут быть считаны и записаны посимвольно. Для этой
цели переменная v в вызываемых процедурах read(f, v) и write(f, v) должна
быть типа char. Очевидно, что вставка специальных символов EOL и EOF
является обязанностью программиста.
  В качестве примера приведем программу Р95, которая создает на те-
кущем диске текстовый файл FILE.TXT. Строки файла вводят с клавиа-
туры (файл Input). Признаком конца строки является нажатие клавиши
<ENTER>, а признаком конца файла является нажатие клавиш <CTRL+Z>,
<ENTER>.

     Program P95;
     { Создание текстового файла FILE.TXT методом обработки }
     { на уровне символов                                       }
     var F : text;              { логический файл F             }
          C : char;
     begin
      assign(F, 'FILE.TXT'); { связывает файл F с FILE.TXT }
      rewrite(F);             { открывает F для записи        }
      while not eof do      { проверяет, нажаты ли клавиши <CTRL+Z>}
        begin
          while not eoln do	{ проверяет, нажата ли клавиша <ENTER> }
            begin
              read(C);        { считывает C с клавиатуры      }
              write(F, C);    { записывает C в файл F         }
            end;
          writeln(F);         { записывает EOL в файл F       }
          readln;             { переходит на следующую строку }
        end;
      close(F);                { записывает EOF в файл F      }
     end.
  Отметим, что в вышеприведенной программе компоненты входного файла
Input (клавиатура) считываются посимвольно, а конец каждой строки (специ-
альный символ EOL) распознается функцией eoln. Аналогично конец входного
файла (специальный символ EOF) распознается функцией eof.
  Следующая программа отображает на экране содержимое внешнего файла
FILE.TXT.

82
  Program P96;
  { Считывание текстового файла FILE.TXT путем обработки }
  { на уровне символов                                      }
  var F : text;                { логический файл F          }
      C : char;
  begin
    assign(F, 'FILE.TXT');     { связывает файл F с FILE.TXT }
    reset(F);                  { открывает F для чтения       }
    while not eof(F) do        { проверяет, есть ли EOF в F }
      begin
         while not eoln(F) do { проверяет, есть ли EOL в F }
            begin;
              read(F, C);      { считывает C из F             }
              write(C);        { отображает на экране C       }
            end;
         readln(F); { переходит на следующую строку в F }
        writeln;      { переходит на следующую строку на экране }
       end;
    close(F);                  { закрывает файл F }
    readln;
  end.
   В вышеприведенной программе компоненты выходного файла Output
(экран) записываются на уровне символов. Конец EOL каждой строки записы-
вается с помощью вызова процедуры readln, а конец файла EOF ― с помощью
вызова процедуры close.
   Обработка на уровне лексем
   Посимвольная обработка текстовых файлов является обременительной,
если символьные последовательности из текста следует интерпретировать
как данные типа integer, real, boolean, строка символов. Конверсия из
внешней формы этих данных во внутреннее представление соответственно их
типам является ответственностью программиста. Чтобы облегчить ему работу,
процедуры чтения/записи были расширены следующим образом.
   В случае текстовых файлов переменная v в вызове read(f, v) может быть
целого, вещественного, символьного или строкового типа. При чтении после-
довательность символов, представляющая переменную v, будет преобразована
во внутреннее представление соответствующего типа.
   За выражением е в процедуре write(f, e) может следовать указатель фор-
мата. Значение выражения может относиться к типу integer, real, char
или строка символов. При записи соответствующее значение переводится из
внутреннего представления в последовательность символов.
   Последовательности символов, считываемые/записываемые с помощью
процедур read/write, соответствуют синтаксису констант типа переменной/
выражения v/e.
   В качестве примера приведем программу Р97, которая:
   1) считывает с клавиатуры строку, содержащую три вещественных числа
a, b, c ― длины сторон треугольника;
   2) записывает считанные числа в файл IN.TXT;
   3)	повторяет шаги 1) и 2) до момента нажатия пользователем клавиш
	 <CTRL+Z> <ENTER>;

                                                                      83
     4)	считывает из текущей строки файла IN.TXT вещественные числа a, b, c;
     5) вычисляет полупериметр p и площадь s соответствующего треугольника;
     6) записывает вещественные числа a, b, c, p, s в текстовый файл OUT.TXT;
     7) повторяет шаги 4)―6) до тех пор, пока не будет считана последняя строка
	    текстового файла OUT.TXT;
     8) отображает на экране содержимое файла OUT.TXT.
     Program P97;
     { Обработка треугольников                 }
     { Запись и считывание на уровне лексем    }
     var F, G : text;          { логические файлы            }
         a, b, c, p, s : real;
         Str : string;
     begin

       { Считывание данных с клавиатуры и их сохранение в файле F}
       assign(F, 'IN.TXT'); { связывает F с IN.TXT               }
       rewrite(F);           { открывает F для записи            }
       writeln('Введите вещественные числа a, b, c:');
       while not eof do
         begin
           readln(a, b, c); { считывает с клавиатуры a, b, c     }
           writeln(F, a:8:2, b:8:2, c:8:2); { scrie a, b, c in F }
         end;
       close(F);              { закрывает F }

       { Считывание данных из F, выполнение вычислений и }
       { сохранение результатов в G                         }
       reset(F);              { открывает F для считывания }
       assign(G, 'OUT.TXT'); { связывает G с OUT.TXT        }
       rewrite(G);            { открывает G для записи      }
       while not eof(F) do
         begin
           readln(F, a, b, c); { считывает a, b, c из F }
          write(G, a:8:2, b:8:2, c:8:2); { записывает a, b, c в G }
           p:=(a+b+c)/2;
           s:=sqrt(p*(p-a)*(p-b)*(p-c));
           writeln(G, p:15:2, s:15:4); { scrie p, s în G }
         end;
       close(F);              { закрывает F }
       close(G);              { закрывает G }

       { Считывание результатов из G и отображение их на экране }
       reset(G);             { открывает G для считывания       }
       while not eof(G) do
          begin
            readln(G, Str);  { считывает Str из G         }
            writeln(Str);    { отображает Str на экране }
          end;
       close(G);             { закрывает G                }
       readln;
     end.

84
  При вводе данных
    1 1 1 <ENTER>
    3 4 6 <ENTER>
    <CTRL+Z><ENTER>
программа P97 отобразит на экране:
    1.00 1.00 1.00 1.50 0.4330
    3.00 4.00 6.00 6.50 5.3327
   Отметим, что вышеприведенная программа предназначена для обработки
данных о неизвестном количестве треугольников, что придает ей большую гиб-
кость для применения. Такая гибкость обусловлена использованием функции
eof. С помощью этой функции проверяется, был ли в процессе считывания
достигнут конец каждого из файлов Input (клавиатура) и IN.TXT.


   В C++ текстовый файл содержит только символы ASCII, расположенные в
строках разной длины. Элемент EOL представлен символом escape "\n" (new
line, новая строка). Конец файла указывается элементом EOF. Поскольку
длина строк является переменной, положение строки в файле невозможно
рассчитать заранее. В результате доступ к компонентам текстового файла
является последовательным.
   Поскольку язык C++ не навязывает никакой структуры содержимому фай-
лов, разбиение их на лексемы (числа, строки символов) и на строки является
обязанностью программиста. Для этого могут быть использованы все функции,
предназначенные для обработки файлов с последовательным доступом, рас-
смотренные в параграфе 1.8.
   В качестве примера представлена программа P93, которая создает на те-
кущем диске текстовый файл, имя которому задается с клавиатуры. Строки
файла разделяют нажатием клавиши <ENTER>, а конец файла нажатием
клавиш <CTRL + Z> <ENTER>.
  // Программа P93
  // Создание текстового файла
  #include <iostream>
  #include <fstream>
  using namespace std;
  int main()
  {
    char nume_fisier[80];
    char c;
    cout << "\n\tПрограмма создает текстовый файл\n";
    cout << "\n\tВведите имя файла: ";
    cin.getline(nume_fisier,80);
    ofstream f(nume_fisier);
    cout << "\n\tВводите символы. В конце строк нажимайте En-
ter, в конце ввода CTRL+Z\n";
    while(cin.get(c))
         f << c;
    f.close();
    return 0;
  }

                                                                       85
   Обработка на уровне символов
   Напомним, что при считывании оператором >> игнорируются белые символы
(пробел, табуляция, конец строки). Поэтому, если хотим прочитать один за дру-
гим все символы в файле, включая белые, мы воспользуемся функцией get().
     // Программа P94
     // Считывание из текстового файла
     #include <iostream>
     #include <fstream>
     using namespace std;
     int main()
     {
       char nume_fisier[80];
       char c ;
       cout << "\n\tПрограмма считывает текстовый файл\n";
       cout << "\n\tВведите имя файла: ";
       cin.getline(nume_fisier,80);
       ifstream f(nume_fisier);
       f.get(c);
       while(!f.eof())
         {
           f.get(c);
           cout<<c;
         }
     f.close();
     return 0;
     }
   Чтобы проверить, достигла ли конца файла текущая позиция чтения/за-
писи, применяют функцию eof(), которая возвращает значение 0, если те-
кущая позиция не находится в конце файла, и значение, отличное от 0, если
текущая позиция указывает на конец файла.
   Нижеследующая программа копирует символьные данные из текстового
файла IN.TXT в текстовый файл OUT.TXT.
     // Программа P95
     // Посимвольное копирование текстовых файлов
     #include <iostream>
     #include <fstream>
     using namespace std;
     int main()
     {
     char c ;
     ifstream f("in.txt");   // поток f связывается с in.txt
     ofstream g("out.txt"); // поток g связывается с out.txt
     f.get(c);               // из f считывается первый символ
     while(!f.eof())         // цикл по символам из f
         {

86
       g.put(c);               // считанный символ записывается в g
       f.get(c);               // из f считывается следующий символ
      }
  f.close();                    // закрытие файла      in.txt
  g.close();                    // закрытие файла      out.txt
  return 0;
  }

  Обработка на уровне строк
  Для построчного считывания символов из входного файла, включая белые
символы, применяется функция getline.
  Следующая программа копирует строку за строкой данные из текстового
файла IN.TXT в текстовый файл OUT.TXT.
  // Программа P96
  // Построчное копирование текстовых файлов
  #include <iostream>
  #include <fstream>
  using namespace std;
  int main()
  {
  char linie[80];
  ifstream f("in.txt");     // поток f связывается с in.txt
  ofstream g("out.txt");    // поток g связывается с out.txt
  while(!f.eof())           // цикл по строкам из f
      {
       f.getline(linie,80); // из f считывается текущая строка
      g<<linie<<endl;     // считанная строка записывается в g
      }
  f.close();                // закрытие файла in.txt
  g.close();                // закрытие файла out.txt

  return 0;
  }
   Обработка на уровне лексем
   Нижеследующая программа применяет функции обработки файлов C++
для их разбиения на лексемы. Точнее, эта программа:
   1) считывает с клавиатуры строку, содержащую вещественные числа a, b,
c ― длины сторон треугольника;
   2) записывает считанные из текущей строки числа в текстовый файл
in.txt;
   3) повторяет шаги 1)―2) до тех пор, пока не будут нажаты клавиши
<CTRL+Z> <ENTER>;
   4) считывает из текущей строки текстового файла in.txt вещественные
числа a, b, c;
   5) вычисляет полупериметр p и площадь s соответствующего треугольника;
   6) записывает вещественные числа a, b, c, p , s в текстовый файл out.txt;

                                                                         87
   7) повторяет шаги 4)―6) до тех пор, пока не считается последняя строка
текстового файла out.txt;
   8) отражает на экране содержимое файла out.txt.

     //Программа P97
     //Обработка треугольников
     //Запись и считывание на уровне лексем
     #include <iostream>
     #include <iomanip>
     #include <cmath>
     #include <fstream>
     using namespace std;
     int main()
     {
       float a,b,c;
       float p,s;
       int i,n;
       char linie[80];

   //Считывание данных с клавиатуры и их запись в f
   ofstream f("in.txt"); //открывает f для записи
   cout<<"открывает f для записи a,b,c \n";
   cin>>a>>b>>c;            // считывает a, b, c с клавиатуры
  while (!cin.eof())  //повторяет до нажатия с клавиатуры <CTRL+Z>
			<ENTER>
    {
       f<<a<<" "<<b<<" "<<c<<endl; // пишет a, b, c в файл f
        cin>>a>>b>>c;       // считывает a, b, c с клавиатуры
    }
   f.close();               // закрывает f

        //Считывание данных из f, проведение вычислений и
     // сохранение результатов в g
        ifstream f("in.txt");    // открывает f для чтения
        ofstream g("out.txt");   // открывает g для записи
        f>>a>>b>>c;              // считывает a,b,c из f
        while(!f.eof())
         {
         g<<a<<" "<<b<<" "<<c<<" "; // запись a,b,c в g
         p=(a+b+c)/2;
         s=sqrt(p*(p-a)*(p-b)*(p-c));
         g<<p<<" "<<s<<"\n"; // запись p и s в g
         f>>a>>b>>c;           // считывание a,b,c из f
      }
      f.close();               // закрывает f
      g.close();               // закрывает g


88
  // Считывание результатов из g и их отображение на экране
  ifstream g("out.txt");   // открывает g для считывания
  while(!g.eof())
    {
      g.getline(linie,80); // считывает текущую строку из g
    cout<<linie<<endl; // отображает на экране считанную строку
    }
  g.close();               // закрывает g
  return 0;
  }

  Для входных данных
      1 1 1 <ENTER>
      3 4 6 <ENTER>
      <CTRL+Z><ENTER>
  программа P97 отобразит на экране:
      1 1 1   1.5    0.433013
      3 4 6   6.5    5.332684
   Подчеркнем, что вышеприведенная программа предназначена для обработ-
ки данных в отношении неизвестного количества треугольников. Это придает
программе гибкость в ее применении. Достигается эта гибкость благодаря
применению функции eof. С помощью этой функции проверяется, были ли
считаны до конца данные из обоих файлов Input (клавиатура) и IN.TXT.


  Вопросы и упражнения
  Ê	 УПРАЖНЯЙТЕСЬ! Нарисуйте схематическое представление структуры
     текстового файла. Объясните назначение каждого графического значка
     соответствующей схемы.
  	 ПРОАНАЛИЗИРУЙТЕ! Дан следующий текстовый входной файл:
         Данные 9.8 12 23.67 СТОП<EOL><EOF>
  	  Объясните, каким образом считаются данные из этого файла и какие при
     этом произойдут преобразования для случаев обработки: (a) на уровне сим-
     волов; (b) на уровне лексем.
  	 ПРОАНАЛИЗИРУЙТЕ! Дан следующий текстовый входной файл:
         5.1	 9.3	    Отклонен<EOL>6.4	 4.3 Допущен <EOL><EOF>
  	  Объясните, каким образом считаются данные из этого файла и какие при
     этом произойдут преобразования для случаев обработки: (a) на уровне сим-
     волов; (b) на уровне лексем.
  	 СОЗДАВАЙТЕ! Приведите примеры входных файлов с начальными данны-
     ми задачи по физике и задачи по биологии и опишите процесс считывания
     этих данных на уровне символов и на уровне лексем.

                                                                          89
     	 ПРОАНАЛИЗИРУЙТЕ! Чем отличаются способы обработки текстового фай-
        ла на уровне символов и на уровне лексем? Приведите примеры алгорит-
        мов, в которых возникает необходимость реализации обработки на уровне
        символов и на уровне лексем.
     	 УЧИТЕСЬ УЧИТЬСЯ! Исходя из двух способов считывания входных файлов
        на уровне символов и на уровне лексем, объясните эти способы для выходных
        текстовых файлов. Приведите примеры.
     	 ОБЪЯСНИТЕ! Объясните значение элементов EOL и EOF. Каким образом
        обрабатываются эти элементы?
     	 ОБЪЯСНИТЕ! Объясните, как записываются и считываются данные в случае
        текстовых файлов. Какие процедуры/функции применяют для этого?
     	 ОБРАТИТЕ ВНИМАНИЕ! Запустите на выполнение следующую программу:
               ПАСКАЛЬ                                     C++
Program P98;                         // Программа P98
{ Связывание файла FN с              // Связывание файла FN с
устройством ввода }                  // устройством ввода
type FisierNumere = file of          #include <iostream>
integer;                             #include <fstream>
var FN : FisierNumere;               using namespace std;
     i : integer;                    int main()
begin                                {
   assign(FN, ’CON’);                  int i;
   rewrite(FN);                        ofstream FN („CON”);
   i:=1;                               i=1;
   write(FN, i);                       FN<<i;
   i:=2;                               i=2;
   write(FN, i);                       FN<<i;
   i:=3;                               i=3;
   write(FN, i);                       FN<<i;
   close(FN);                          FN.close();
   readln;                             return 0;
end.                                 }
  	 Объясните результаты, выводимые на экран. 
  	 ПРОАНАЛИЗИРУЙТЕ! Дан логический файл f. Какие из нижеследующих
     операторов, предназначенные для обнаружения конца файла, записаны
     корректно?
                                  ПАСКАЛЬ
 a)    if eoln(f) then
            write (’Конец файла’)
       else write (’Не конец файла’);
 b)    if eof(f) then
            write (’Конец файла’)
       else write (’Не конец файла’);
 c)    if eoln(f)=false then
            write (’Конец файла’)
       else write (’Не конец файла’);
 d)    if not eof(f) then
            write (’Конец файла’)
       else write (’Не конец файла’);

90
                                    C++
a)   if (eof(f))
          cout << ”Конец файла”;
     else cout << ”Не конец файла”;
b)   if (f.eof())
          cout << ”Конец файла”;
     else cout << ”Не конец файла”;
c)   if (!eof(f))
          cout << ”Конец файла”;
     else cout << ”Не конец файла”;
d)   if (!f.eof())
          cout << ”Не конец файла”;
     else cout << ”Конец файла”;
  	 ПРИМЕНИТЕ! Напишите программу, которая выводит на экран содержание
    любого текстового файла.
  	 ПРОГРАММИРУЙТЕ! Напишите программу, которая выводит на экран
    количество гласных, содержащихся в текстовом файле.
  	 ПРОГРАММИРУЙТЕ! Входные данные некоторой программы записаны в
    текстовый файл. В каждой строке файла содержатся два целых и три ве-
    щественных числа, разделенные пробелами. Напишите программу, которая
    выводит на экран сумму целых и сумму вещественных чисел из каждой строки.
  	 ПРОГРАММИРУЙТЕ! Входные данные некоторой программы записаны в
    текстовый файл. В каждой строке файла содержатся по три вещественных
    числа, разделенных пробелами, и по одному из слов ДОПУЩЕН, ОТКЛОНЕН.
    Напишите программу, которая:
 	 a)	 выводит содержимое данного файла на экран;
 	 б)	 создает резервную копию файла;
 	 в)	 создает текстовый файл, строки которого содержат среднее арифметическое
        трех вещественных чисел, взятых из соответствующих строк входного файла;
 	 г)	 выводит на экран строки входного файла таким образом, что перед каждой
        строкой пишется ее порядковый номер: 1, 2, 3 и т. д.
  	 ПРОГРАММИРУЙТЕ! Каждая строка текстового файла содержит следу-
    ющие данные, разделенные пробелами:
 	 – порядковый номер (целое число);
 	 – фамилия (последовательность символов, не содержащая пробелов);
 	 – имя (последовательность символов, не содержащая пробелов);
 	 – отметка по 1-му школьному предмету (вещественное число);
 	 – отметка по 2-му школьному предмету (вещественное число);
 	 – отметка по 3-му школьному предмету (вещественное число).
 	 Напишите программу, которая:
    a)	 создает резервную копию текстового файла;
    б)	 выводит на экран содержимое файла;
    в)	 создает текстовый файл, строки которого содержат следующие данные,
        разделяемые пробелами:
 		– порядковый номер (целое число);
 		– фамилия (последовательность символов, не содержащая пробелов);
 		– имя (последовательность символов, не содержащая пробелов);
 		– средний балл (вещественное число);
 Файл, созданный в пункте в, необходимо вывести на экран.

                                                                             91
Глава 2
                                                    ИНФОРМАЦИЯ

     2.1. Количество информации
   Обычный смысл слова информация – «новости, устное, письменное или
переданное другими способами сообщение об определенных фактах, событиях,
деятельности и т. п.», – конкретизируется в специальном разделе математики,
который называется теорией информации. В соответствии с этой теорией ис-
точник информации описывается переменной S, которая может принимать
значения из конечного множества различных элементов {s1, s2, ..., sn}. Предполага-
ется, что текущие значения переменной S априори не известны. Известно только
множество {s1, s2, ..., sn}, называемое множеством возможных сообщений.
   Например, дорожный светофор можно рассматривать как источник информа-
ции, множество возможных сообщений которого: {зеленый, желтый, красный}.
Телеграфный аппарат представляет собой источник информации, множество
возможных сообщений которого включает буквы A, B, C, ..., Z, цифры 0, 1, 2, ..., 9 и
знаки препинания. Возможными сообщениями клавиатуры являются «Нажата
клавиша A», «Нажата клавиша B» ,..., «Нажата клавиша F1», «Нажата клавиша
F2», ..., «Одновременно нажаты клавиши CTRL и BREAK» и т. д.
   Сообщения передаются от источника к приемнику информации через физиче-
скую среду, называемую каналом передачи (рис. 2.1). Например, телеграфные
сообщения передаются по проводам, радиосообщения передаются через эфир, со-
общения клавиатуры ― через группу проводников. Помехи (шумы) упомянутой
физической среды могут искажать передаваемые сообщения.


                          Сообщения


             Источник            Канал передачи            Приемник


                                      Помехи

                 Рис. 2.1. Общая схема системы передачи информации

  Очевидно, что текущее значение переменной S становится известным при-
емнику только после приема соответствующего сообщения.
  Количество/объем информации I, которое содержится в сообщении,
переданном источником, определяется соотношением:

92
                                 I = loga n,
где n ― это количество возможных сообщений источника. Конкретное значение
константы a устанавливается выбором единицы измерения количества ин-
формации. Обычно в качестве единицы измерения используется бит.
  Бит ― это количество информации в отдельном сообщении от
  источника с множеством только из двух возможных сообщений.
   Следовательно, как и в случае других величин (длины, массы, температуры
и т. д.), количество информации измеряется сравнением с эталоном. Так как
для эталонного источника n = 2, из уравнения:
                                loga 2 = 1 (бит)
получаем a = 2. Следовательно, количество информации I, измеряемое в битах,
определяется соотношением:
                                I = log2 n (бит).
  В таблице 2.1 представлены часто используемые значения функции log2 n.

                                                                Таблица 2.1
                        Значения функции log2n
         n             log2 n              n         log2 n
          1            0,000               21        4,392
          2            1,000               22        4,459
          3            1,585               23        4,524
          4            2,000               24        4,585
          5            2,322               25        4,644
          6            2,585               26        4,700
          7            2,807               27        4,755
          8            3,000               28        4,807
          9            3,170               29        4,858
         10            3,322               30        4,907
         11            3,459               31        4,954
         12            3,585               32        5,000
         13            3,700               33        5,044
         14            3,807               34        5,087
         15            3,907               35        5,129
         16            4,000               36        5,170
         17            4,087               37        5,209
         18            4,170               38        5,248
         19            4,248               39        5,285
         20            4,322               40        5,322
   Проанализируем несколько примеров. Количество информации в одном
сообщении светофора:
                        I = log2 3 ≈1,585 бит.

                                                                        93
   Количество информации одной буквы латинского алфавита {A, B, C, ..., Z}, n =
= 26, составляет:
                          I = log2 26 ≈ 4,700 бит.
   Количество информации одной буквы греческого алфавита {A, B, Γ, ∆ , ...,
Ω}, n = 24, составляет:
                          I = log2 24 ≈ 4,585 бит.
   Если известно количество информации I, содержащееся в отдельном со-
общении, то общее количество информации, переданное источником,
определяется соотношением:
                                   V = N I,
где N ― количество переданных сообщений.
   Большие объемы информации выражаются с помощью единиц, произво-
дных от бита:
               1 Килобит (Kbit) = 210 = 1 024 бит (≈103 бит );
                 1 Мегабит (Mbit) = 220 = 1 048 576 бит (≈106 бит );
                 1 Гигабит (Gbit) = 230 ≈ 109 бит;
                 1 Терабит (Tbit) = 240 ≈ 1012 бит;
                 1 Петабит (Pbit) = 250 ≈ 1015 бит.


     Вопросы и упражнения
     Ê	 Как определяется источник информации? Приведите несколько примеров.
     Ë	 Для чего предназначен канал передачи?
     Ì	 Как определяется количество информации в одном сообщении? В N сообще-
        ниях?
     Í	 Какая единица используется для измерения количества информации и в
        чем ее смысл?
     Î	 Определите количество информации в отдельном сообщении источников со
        следующими возможными сообщениями:
        а) прописные и строчные буквы латинского алфавита;
        б) прописные и строчные буквы греческого алфавита;
        в) прописные и строчные буквы румынского алфавита;
        г) прописные и строчные буквы русского алфавита;
        д) десятичные цифры 0, 1, 2, ..., 9;
        е) цифры 0, 1, 2, ..., 9, знаки +, –, ×, / и скобки ( );
        ж) числовые показания в виде hh:mm (hh ― часы, mm ― минуты) электрон-
           ных часов;
        з)	числовые показания в виде hh:mm:ss (ss ― секунды) электронных часов;
        и)	числовые показания в виде zz.ll.aa (zz ― день, ll ― месяц, aa ― год) элек-
           тронного календаря.
     Ï	 Для каждого из источников, приведенных в упражнении 5, определите
        количество информации, содержащееся в 1000 сообщений, переданных ис-
        точником.
     Ð	 Напишите программу, вычисляющую количество информации в N сообще-
        ниях, переданных источником с n возможными сообщениями.

94
  2.2. Кодирование и декодирование информации
   Назовем знаком элемент конечного множества объектов, которые могут
различаться. Линейно упорядоченное множество знаков называется ал-
фавитом.
   Представим некоторые из бесчисленного множества алфавитов:
   а) алфавит десятичных цифр: 0, 1, 2, ..., 9;
   б) алфавит прописных латинских букв: A, B, C, ..., Z;
   в) множество знаков зодиака;
   г) множество фаз Луны.
   Особое значение представляют алфавиты, состоящие только из двух знаков.
Такие алфавиты называются двоичными алфавитами, а их знаки соответ-
ственно ― двоичными знаками.
   Приведем несколько примеров двоичных алфавитов:
   a) цифры {0, 1};
   б) пара цветов {красный, желтый};
   в) пара состояний {закрыт, открыт};
   г) пара ответов {да, нет};
   д) пара напряжений {0 В, 2 В};
   е) пара состояний {намагничен, не намагничен};
   ж) пара знаков {+, –} и т. д.
   Удобно, чтобы знаки двоичного алфавита были представлены цифрами
{0, 1}, которые называются двоичными цифрами. Последовательность,
состоящая из m знаков, некоторые из которых могут повторяться, образует
слово, а m представляет длину слова. Слова, образованные из двоичных
знаков, называются двоичными словами. Очевидно, что слова могут иметь
переменную или постоянную длину. В последнем случае они называются
m-позиционными словами. Приведем некоторые множества слов посто-
янной длины:
   1-позиционные: {0, 1};
   2-позиционные: {00, 01, 10, 11};
   3-позиционные: {000, 001, 010, 011, 100, 101, 110, 111};
   4-позиционные: {0000, 0001, ..., 1110, 1111}.
   Заметим, что (m + 1)-позиционные слова образуются по два из
m-позиционных слов добавлением двоичных цифр 0 и 1. Следовательно,
множество m-позиционных слов включает 2m различных слов.
   Двоичные слова применяют для представления, передачи, хранения и об-
работки сообщений s1, s2, ..., sn источника информации (рис. 2.2).

              Сообщение       Двоичное         Двоичное
                                                                 Сообщение
                               слово            слово

                                     Канал
   Источник        Шифратор                         Дешифратор        Приемник
                                    передачи


  Рис. 2.2. Кодирование и декодирование сообщений в системах передачи информации

                                                                                 95
    Правило преобразования сообщений в слова называется кодом,
    а соответствующая операция ― кодированием. Операция, об-
    ратная кодированию, называется декодированием. Технические
    устройства, которые выполняют соответствующие операции,
    называются шифратор и дешифратор.
    Самым простым является код, в котором возможным сообщениям s1, s2, ...,
sn соответствуют двоичные слова постоянной длины m. Такой код, называемый
m-позиционным кодом, может быть определен с помощью таблицы, содержа-
щей возможные сообщения и соответствующие им слова. На рис. 2.3 представ-
лены соответствующие таблицы для источника с n = 2, 3, 4, ..., 8 возможными
сообщениями.
                  n=2, m=1              n=3, m=2                 n=4, m=2
                  s1    0               s1       00              s1    00
                  s2    1               s2       01              s2    01
                                        s3       10              s3    10
                                                                 s4    11

       n=5, m=3              n=6, m=3                 n=7, m=3              n=8, m=3
        s1   000             s1   000                 s1   000              s1   000
        s2   001             s2   001                 s2   001              s2   001
        s3   010             s3   010                 s3   010              s3   010
        s4   011             s4   011                 s4   011              s4   011
        s5   100             s5   100                 s5   100              s5   100
                             s6   101                 s6   101              s6   101
                                                      s7   110              s7   110
                                                                            s8   111
               Рис. 2.3. Коды, состоящие из слов постоянной длины
                               (m-позиционные коды)

   Операции кодирования и декодирования состоят в извлечении необхо-
димых данных из таблицы. Очевидно, что декодирование будет однозначным
только тогда, когда двоичные слова, содержащиеся в таблице, различны. Это
возможно, если длина m слов кода удовлетворяет неравенству
                                     2 ≥ n.  m



   После логарифмирования получаем:
                                    m ≥ log n.   2


   Поскольку выражение log2 n представляет количество информации, можно
утверждать:
   Длина слов любого позиционного кода должна быть больше или
   равна количеству информации в кодируемом сообщении.
   Например, длина слов для кодирования прописных букв латинского алфа-
вита {A, B, C, ...Z}, n = 26, определяется соотношением
                               m ≥log 26 ≈4,700.
                                             2


   Устанавливая m = 5, можем формировать двоичные 5-позиционные кодовые
слова:
                                    A – 00000

96
                               B – 00001
                               C – 00010
                               D – 00011
                               E – 00100
                                   ...
                               Z – 11001.
  Подобный код был предложен английским философом и государственным
деятелем Фрэнсисом Бэконом еще в 1580 году.
  Алгоритмы составления кодов, состоящих из слов с переменной дли-
ной, значительно сложнее и изучаются в углубленных курсах информатики.


  Вопросы и упражнения
  Ê	 Что такое алфавит? Приведите примеры двоичных алфавитов.
  Ë	 Как представляют знаки любого двоичного алфавита?
  Ì 	Объясните, как могут быть получены двоичные (m + 1)-позиционные слова.
     Чему равно число различных двоичных m-позиционных слов?
  Í	 Для чего предназначен код? Как определяется m-позиционный код?
  Î	 Как осуществляются кодирование и декодирование сообщений в случаях,
     когда код определен с помощью таблицы?
  Ï	 Закодируйте сообщения s3, s4 и s6 источника с семью возможными сообще-
     ниями. Используйте 3-позиционный код с рис. 2.3.
  Ð	 Декодируйте сообщения 100, 000 и 010, представленные в 3-позиционном
     коде на рис. 2.3, n = 5.
  Ñ	 Как определяется количество двоичных знаков, необходимых для форми-
     рования слов постоянной длины любого кода?
  Ò	 Используя 3-позиционный код с рис. 2.3, n = 6, закодируйте сообщения s1,
     s2, s6, s5, s3, s6, s3, s2, s1.
  Ó	 Как влияет количество информации некоторого сообщения на длину слова кода?
   	 Объясните смысл терминов количество информации и информация.
   	 Напишите программу, которая кодирует и декодирует буквы латинского
     алфавита. Используйте код, предложенный Фрэнсисом Бэконом.
   	 Напишите программу, которая составляет таблицу m-позиционного кода
     для источника с n возможными сообщениями.



  2.3. Часто используемые коды
    Любой код, применяемый для представления, передачи, хранения и обра-
ботки информации, должен быть экономичным и нечувствительным к помехам,
а соответствующие устройства кодирования и декодирования ― простыми. По
мере развития вычислительной техники разработано много кодов. Эти коды
классифицируются на числовые и алфавитно-числовые.
    Числовые коды обеспечивают возможность представления цифр {0, 1,
2, ..., 9} с помощью двоичных 4-позиционных слов. Примеры числовых кодов
представлены в таблице 2.2.

                                                                            97
                                                                  Таблица 2.2
                            Числовые коды
                                   Название кода
         Цифра
                   Прямой        Грея    Айкена        С избытком 3
           0        0000         0000      0000             0011
           1        0001         0001         0001         0100
           2        0010         0011         0010         0101
           3        0011         0010         0011         0110
           4        0100         0110         0100         0111
           5        0101         0111         1011         1000
           6        0110         0101         1100         1001
           7        0111         0100         1101         1010
           8        1000         1100         1110         1011
           9        1001         1101         1111         1100
   Алфавитно-числовые коды представляют с помощью двоичных слов
цифры 0, 1, 2, ..., 9, строчных и прописных букв алфавита, знаков препина-
ния, знаков арифметических операций и т. д. В таблице 2.3 представлен код
ASCII (American Standard Code for Information Interchange ― Американский
стандартный код для информационного обмена), изобретенный в 1968 году.
                                                                  Таблица 2.3
                                 Код ASCII
               Двоичное Десятичный                   Двоичное Десятичный
 Символ                                 Символ
                слово   эквивалент                    слово   эквивалент
  Пробел       0100000      32            P          1010000        80
     !         0100001      33            Q          1010001        81
     ″         0100010      34            R          1010010        82
     #         0100011      35            S          1010011        83
     $         0100100      36            T          1010100        84
     %         0100101      37            U          1010101        85
     &         0100110      38            V          1010110        86
     ’         0100111      39            W          1010111        87
     (         0101000      40            X          1011000        88
     )         0101001      41            Y          1011001        89
     *         0101010      42            Z          1011010        90
     +         0101011      43            [          1011011        91
     ,         0101100      44            \          1011100        92
     -         0101101      45            ]          1011101        93
     .         0101110      46            ^          1011110        94

98
                                                    Продолжение таб. 2.3
           Двоичное Десятичный                 Двоичное Десятичный
 Символ                              Символ
             слово  эквивалент                   слово  эквивалент
    /       0101111     47              _       1011111     95
    0       0110000         48          `       1100000        96
    1       0110001         49          a       1100001        97
    2       0110010         50          b       1100010        98
    3       0110011         51          c       1100011        99
    4       0110100         52          d       1100100        100
    5       0110101         53          e       1100101        101
    6       0110110         54          f       1100110        102
    7       0110111         55          g       1100111        103
    8       0111000         56          h       1101000        104
    9       0111001         57          i       1101001        105
    :       0111010         58          j       1101010        106
    ;       0111011         59          k       1101011        107
    <       0111100         60          l       1101100        108
    =       0111101         61          m       1101101        109
    >       0111110         62          n       1101110        110
    ?       0111111         63          o       1101111        111
    @       1000000         64          p       1110000        112
    A       1000001         65          q       1110001        113
    B       1000010         66          r       1110010        114
    C       1000011         67          s       1110011        115
    D       1000100         68          t       1110100        116
    E       1000101         69          u       1110101        117
    F       1000110         70          v       1110110        118
    G       1000111         71          w       1110111        119
    H       1001000         72          x       1111000        120
    I       1001001         73          y       1111001        121
    J       1001010         74          z       1111010        122
    K       1001011         75          {       1111011        123
    L       1001100         76          |       1111100        124
    M       1001101         77          }       1111101        125
    N       1001110         78          ~       1111110        126
    O       1001111         79         Del      1111111        127
  Данный код является 7-позиционным и включает 27 = 128 символов.
Первые 32 символа (двоичные слова 0000000, 0000001, 0000010, …, 0011111)
определяют технические детали передачи информации и не включены в таб-

                                                                     99
лицу. Двоичные слова 0100000, 0100001, 0100010, …, 1111110 представляют
печатные символы текстов на английском языке. Слово 1111111 представляет
непечатаемый символ Delete (Стирание).
   Кодирование сообщений осуществляется путем замены символов соответ-
ствующими двоичными словами. Например, слово START представляется в
коде ASCII следующей последовательностью двоичных слов:
               1010011    1010100   1000001   1010010    1010100.
  Очевидно, что декодирование осуществляется в обратном порядке. Напри-
мер, последовательность двоичных слов
                    1010011    1010100   1001111   1010000
представляет в коде ASCII слово STOP.
   Как правило, языки программирования оперируют не с самими двоичными
словами, а с их десятичными эквивалентами. В программах на языке ПА-
СКАЛЬ десятичные эквиваленты символов могут быть найдены с помощью
предопределенной (встроенной) функции ord. Например:
  ord(’S’)=83;	          ord(’T’)=84;	    ord(’A’)=65;	      ord(’R’)=82
и т. д. Предопределенная функция chr возвращает символ, соответствующий
указанному десятичному эквиваленту. Так,
  chr(83)=’S’;	          chr(84)=’T’;	    chr(65)=’A’;	      chr(82)=’R’.
  Подобным образом в программах на языке C++ записываем:
  int(’S’)=83;	          int(’T’)=84;	    int(’A’)=65;	      int(’R’)=82
  char(83)=’S’;	 char(84)=’T’;	           char(65)=’A’;	 char(82)=’R’.
   Ориентированный на английские тексты код ASCII не включает буквы
с диакритическими знаками и специальные графические символы, встре-
чаемые в разных европейских языках и в научных работах. Поэтому для
современных компьютеров разработаны специальные версии кода ASCII,
называемые расширенными кодами ASCII. Расширенные коды являются
                            8
8-позиционными и включают 2 = 256 символов. Структура соответствующих
кодов представлена в таблице 2.4.
                                                                    Таблица 2.4
                   Структура расширенных ASCII кодов
                   Двоичное     Десятичный
   Символ                                               Замечания
                    слово       эквивалент
      Пробел       00100000         32
         !         00100001         33
         ″         00100010         34
         #         00100011         35         Часть 1:
         …             …             …         - символы кода ASCII
         }         01111101         125
         ~         01111110         126
        Del        01111111         127

100
                                                          Продолжение таб. 2.4
                 Двоичное      Десятичный
   Символ                                               Замечания
                  слово        эквивалент
       A         10000000          128
       Б         10000001          129
       В         10000010          130
       …             …              …
                 11110000          240
       Ă         11110001          241
       ă         11110010          242
                                                 Часть 2:
       Â         11110011          243
                                                 -	специфические символы
       â         11110100          244           национальных языков;
       Î         11110101          245           -	псевдографические
       î         11110110          246           символы;
       Ş         11110111          247           -	научные символы
       ş         11111000          248
       '         11111001          249
       ¯         11111010          250
       √         11111011          251
       Ţ         11111100          252
       ţ         11111101          253
                11111110          254
                 11111111          255

   Часть 1 каждого расширенного кода включает символы от 0 до 127, со-
держащиеся в обычном коде ASCII. Часть 2 определена для каждой страны
в отдельности и включает символы от 128 до 255. Эти символы применяют как
для представления букв национальных алфавитов, так и для часто исполь-
зуемых научных символов. Для примера в таблице 2.4 представлены коды
букв Ă, ă, Â, â, Î, î, Ş, ş, Ţ, ţ из алфавита румынского языка и коды букв А, Б,
В, ... из алфавита русского языка, предложенные в 1992 году фирмой TISH
(Кишинэу). Очевидно, что использование расширенных кодов обеспечивает
обработку информации, представленной на различных языках.
   Другим примером алфавитно-числового кода является двоичный 8-пози-
ционный код EBCDIC (Extended Binary Coded Data Interchange Code ― Рас-
ширенный двоичный код для обмена данными), который применяют для
больших электронно-вычислительных машин.
   Необходимо подчеркнуть, что расширение области применения 8-позици-
онных кодов способствует использованию байта и производных от него единиц
для измерения количества информации:
              3
    1 байт = 2 = 8 бит;			                  1 Гигабайт = 230 ≈ 109 байт;
    1 Kилобайт = 210 ≈ 103 байт;		          1 Teрабайт = 240 ≈ 1012 байт;
    1 Meгабайт = 220 ≈106 байт;		           1 Пeтабайт = 250 ≈ 1015 байт.

                                                                            101
  В специальной литературе байт обозначается B (byte), а соответствующие
производные единицы – KB, MB, ГB, TB и ПB.
  Известно, что информатика в значительной степени подвержена явлению
глобализации, поэтому программные продукты и цифровое оборудование
разрабатывают таким образом, что они могут обрабатывать информацию,
представленную на разных языках. Для компьютерного представления
символов практически всех языков мира чаще всего используется код
UNICODE, длина слов которого может достигать 32 двоичных цифр.

  Вопросы и упражнения
  Ê	 Сколько возможных сообщений может быть закодировано с помощью
     m-позиционного кода?
  Ë	 Определите коды, которые применены в операционной системе, с которой
     вы работаете.
  Ì	 Закодируйте в коде Грея следующие последовательности десятичных цифр:
     123, 461, 952, 783, 472.
  Í	 Декодируйте сообщения, представленные в коде Айкена:
  	   a)	 0011   1111      0100	           d)	 1110      0010      1101
  	   b)	 1111   0000      0100	           e)	 0011      1100      1111
  	   c)	 0010   0001      1011	           f)	   1111    1101      0000

  Î	 Закодируйте в ASCII-коде выражения:
  	   a)	 A+B	                             d)	 NEXT I	
  	   b)	 FOR I=1 TO N	                    e)	 PAUSE	
  	   c)	 PRINT A$	                        f)	   PROGRAM

  Ï	 Декодируйте сообщения, представленные в ASCII-коде:
  	   a)	 1000010     1100101   1100111    1101001      1101110;
  	   b)	 1010011     1110100   1101111    1110000;
  	   c)	 1000101     1101110   1100100;
  	   d)	 1101001     0111010   0111101    0110001      0111011.

  Ð	 Разработайте программу, которая выводит на экран коды следующих сим-
     волов, введенных с клавиатуры:
  	 а) десятичные цифры 0, 1, 2, ..., 9;
  	 б) прописные латинские буквы A, B, C, ..., Z;
  	 в) строчные латинские буквы a, b, c, ..., z;
  	 г) знаки арифметических операций;
  	 д) специальные символы ;, <, =, >, ?, [, ], {, }, /, \.
  	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. С помощью поисковой системы най-
     дите в Интернете описания часто используемых кодов. Установите истори-
     ческий курс соответствующих кодов, их достоинства и недостатки, сферы их
     применения.

102
  2.4. Информация непрерывных сообщений
   Источники информации, изученные ранее, определялись с помощью
переменной S, которая может принимать значения из конечного множества
различных элементов {sn1, sn2, ..., sn}, называемого множеством возможных
сообщений. Практика показывает, что не все источники информации могут
быть определены подобным образом. Для примера приведем ртутные либо
спиртовые термометры, спидометры автомобилей, микрофоны, видеокамеры и
др. Такие источники могут быть определены с помощью переменной S (темпе-
ратура, мгновенная скорость, напряжение на выходных клеммах микрофона
и т. д.), которая может принимать любые значения из заданного интервала
[smin, smax].




              а)




              б)




              в)




    Рис. 2.4. Дискретизация непрерывных сообщений: a ― непрерывное сообщение;
                    б ― сообщение, дискретизированное во времени;
              в ― сообщение, дискретизированное во времени и по уровню

  Источники информации, которые определены с помощью переменной S,
принимающей значения из конечного множества различных элементов, на-

                                                                                103
зываются источниками с дискретными сообщениями. Источники, опреде-
ляемые с помощью переменной, которая может принимать любые значения
из заданного интервала, называются источниками с непрерывными (ана-
логовыми) сообщениями.
   Как и дискретные, непрерывные сообщения осуществляются во времени.
Следовательно, S ― функция времени, S = S(t). С целью оценки количества/
объема информации в непрерывных сообщениях будем рассматривать значения
функции S(t) только в моменты времени t1, t2, ..., tm (рис. 2.4). Множество соответ-
ствующих значений (отсчетов), обозначаемое {S (t1), S (t2), ..., S (tm)}, называется
выборкой.
   Как правило, моменты времени t1, t2, ..., tm определяются в соответствии с
соотношением:
                                   t = t + ∆t.
                                        i   i-1


   Величина Δt называется интервалом дискретизации. Конкретное зна-
чение интервала дискретизации Δt выбирается исходя из скорости, с которой
S(t) изменяется во времени.
   Например, в метеорологии изменения температуры происходят на протяже-
нии часов, и Δt = 1 час, а в технике обработки звуковых сигналов Δt = 5·10 с.
                                                                                 –5


   Операция преобразования непрерывных сообщений в выборку называ-
   ется дискретизацией во времени.
    Очевидно, что до приема непрерывного сообщения конкретные отсчеты
S (t1), S (t2), ..., S (tm) не известны получателю. Известен только интервал
 [smin, smax], к которому принадлежат рассматриваемые значения. Для оценки
количества информации в каждом из отсчетов выборки округлим значения
S(ti), i = 1, 2, ..., m до одного из заранее заданных значений s1, s2, ..., sn (рис. 2.4).
    Заранее выбранные значения s1, s2, ..., sn называются квантами, а операция
преобразования текущих значений непрерывных сообщений в кванты ― дис-
кретизацией по уровню, или квантованием.
    Обычно
           s1 = smin, s2 = smin + ∆s, ..., si = si–1 + ∆s, ..., sn = smax.
    Величина ∆s представляет шаг или интервал квантования. Конкретное
значение интервала квантования зависит от физической природы источника
информации, точности измерений, разрешающей способности        o
                                                                        приемника
                                                                             o
                                                                                     и т.д.
                                                                                         o
    Например, для медицинского    o
                                         термометра
                                              o     o
                                                     smin = 34   , smax = 42   и ∆s = 0,1 .
В метеорологии smin = –60 , smax = +60 , ∆s = 1 . Для спидометра автомобиля
smin = 0, smax = 150 км/ч, ∆s = 5 км/ч.
    Количество отсчетов выборки m и количество квантов n определяются сле-
дующими соотношениями (рис. 2.4 b и c):



где T ― длительность непрерывного сообщения.
   Поскольку кванты s1, s2, ..., sn могут рассматриваться как дискретные со-
общения, количество информации в одном отсчете:




104
а количество информации в непрерывном сообщении:




  Например, для медицинского термометра:

                                             бит

Для спидометра автомобиля:

                                               бит

   Количество информации в аудиозаписи для n = 256, ∆t = 5 · 10 –5 и
T = 45 мин составляет:

                                         бит         Мбит

   Если точность измерения и разрешающая способность приемника воз-
растают, то интервал дискретизации Δt и шаг квантования Δs должны быть
уменьшены. Следовательно, возрастает и количество информации, содержа-
щейся в непрерывном сообщении.
   Информация непрерывных сообщений может быть представлена с по-
мощью последовательности двоичных слов. Для этого кванты s1, s2, ..., sn
кодируются точно так же, как и любое дискретное сообщение. Например,
показания медицинского термометра (I ≈ 6,34 бит) могут быть закодированы
с помощью 7-позиционного кода. Чаще всего используют прямые числовые
коды (таблица 2.2), причем кодовое слово представляет количество соответ-
ствующих квантов. В некоторых приложениях применён код Грея, который
нечувствителен к помехам.
   Устройство, которое преобразовывает непрерывное сообщение, поданное
на его вход, в последовательность кодовых слов, называется аналого-
цифровым преобразователем (АЦП). Обратная операция, состоящая в
преобразовании кодовых слов в непрерывное сообщение, осуществляется с
помощью цифро-аналогового преобразователя (ЦАП). Использование
преобразователей необходимо в случаях, когда обрабатываемая информация
представлена непрерывными сообщениями: при контроле технологических
процессов, в управлении движущимися объектами, в мониторинге физиоло-
гических параметров в медицине, для фильтрации и микширования аудио-
сигналов и т.д.

  Вопросы и упражнения
  Ê	 В чем отличие источников с дискретными и с непрерывными сообщениями?
  Ë	 Приведите несколько примеров источников непрерывных сообщений. Уточ-
     ните интервал изменения переменной, описывающей источник.
  Ì	 Объясните, как осуществляется операция дискретизации во времени. Как
     выбирается интервал дискретизации?

                                                                     105
  Í	 Объясните, как осуществляется операция квантования. Как выбирается шаг
     квантования?
  Î	 Как влияют интервал дискретизации и шаг квантования на количество
     информации, извлекаемой из непрерывного сообщения?
  Ï	 Импульсный альтиметр (высотомер) самолета может измерять высоту от 100 м
     до 20 км. Погрешность измерения не превышает 1 м. Чтобы выполнить одно
     измерение, нужно 10–3 с. Определите количество информации, выдаваемой
     альтиметром за 5 часов полета.
  Ð	 Температура внутри химического реактора записывается на бумажной мил-
     лиметровой ленте. По оси абсцисс отображается время (1 мм соответствует
     1 часу), а по оси ординат ― температура (1 мм соответствует 10 oC). Сколько
     информации содержит запись, осуществленная за 30 дней, если температура
     может изменяться от 80 до 1000 oC?
  Ñ	 Для записи звука используется микрофон, напряжение на выходе которого
     изменяется от 0 до 100 мкВ. Устройство записи не различает уровни напря-
     жений, отличающиеся менее чем на 0,1 мкВ. Для обеспечения качественного
     воспроизведения каждую секунду берутся 40000 отсчетов. Сколько инфор-
     мации вырабатывает микрофон на протяжении 3 часов?
  Ò	 Для чего предназначены аналого-цифровые и цифро-аналоговые преоб-
     разователи?
  Ó	 Напишите программу, которая вводит с клавиатуры текущие значения от-
     счетов и выводит на экран коды соответствующих квантов.
   	 Напишите программу, которая моделирует работу цифро-аналогового пре-
     образователя.
   	 ИССЛЕДУЙТЕ! Пользуясь поисковой системой, найдите в Интернете
     описание цифровых звукозаписывающих устройств. Узнайте период дис-
     кретизации и шаг квантования, используемые для оцифровки звуковых
     сообщений, выполняемых каждым из этих устройств.
   	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. С помощью поисковой системы
     найдите в Интернете описания цифровых звукозаписывающих устройств,
     предлагаемых коммерческими/торговыми агентами. Сравните эти устрой-
     ства с точки зрения способа оцифровки аудиосообщений. Узнайте, как пара-
     метры дискретизации влияют на стоимость звукозаписывающих устройств,
     каковы их преимущества, недостатки и области применения.


  2.5. Квантование изображений
   Изображением называется представление некоторого объекта, выполненное
на поверхности самим пользователем напрямую или с помощью определенных
устройств. Для примера вспомним рисунки, фотографии, изображения, полу-
ченные с помощью различных систем ― оптических, оптико-механических или
оптико-электронных: микроскопа, телескопа, кинопроектора, телевизора и др.
   Для измерения количества информации изображение делится на микро-
зоны, называемые чаще всего точками, или пикселями. Разложение изо-
бражения на точки осуществляется с помощью растра (от латинского слова
raster – «грабли»). Растр представляет плоскую поверхность, чаще прямоуголь-
ную, на которую нанесены два ряда параллельных линий, перпендикулярных
между собой (рис. 2.5). Плотность линий и соответственно плотность точек

106
характеризуют разрешающую способность оборудования для воспроизведения
или формирования изображений.


                      микрозоны

                                                             растр




                 Рис. 2.5. Разложение изображения на микрозоны

   Например, для газетных иллюстраций используют растры с разрешением
24–30 линий/cм (576–900 точек на 1 cм2), а для воспроизведения картин ― рас-
тры с 54–60 линий/cм. Растр монитора, то есть рисунок, который формирует
электронный луч на экране электронно-лучевой трубки (кинескопа), может
включать 640 × 480, 800 × 600, 720 × 400, ..., 1024 × 1024 точек.
  Разложение изображения на точки (микрозоны) представляет собой
  операцию дискретизации в пространстве.
  В случае монохромных (черно-белых) изображений каждая микрозона
описывается ее яркостью, которая в общем случае представляет собой непре-
рывную величину. Эта величина может быть дискретизована (квантована) по
уровню. Количество квантов n будет характеризовать разрешающую способ-
ность оборудования для воспроизведения или формирования изображений.
Следовательно, количество информации в одном монохромном изображении:
                               I = m m log n,
                                     x       y       2


где mx и my представляют количество микрозон соответствующего растра по
горизонтали и вертикали (рис. 2.5).
   Поскольку цвета могут быть переданы путем совмещения трех представле-
ний одного и того же изображения в красном, зеленом и синем, то количество
информации в цветном изображении определяется соотношением:
                              I = 3 m m log n.
                                         x       y       2


   Изображения движущихся объектов дискретизируются во времени, пред-
ставляя обычно 24 (в кинематографии) или 25 (в телевидении) кадров в
секунду. Следовательно, количество информации в одном фильме продолжи-
тельностью T секунд определяется соотношением:
                                  V = T f I,
где f ― это частота кадров, а I ― количество информации в одном кадре.

                                                                         107
  Например, в телевидении mx ≈ my = 625, n = 32 и f = 25 кадров в секунду.
Один кадр будет содержать:
                   I = 3 · 625 · 625 · log 32 ≈ 5,6 Mбит .
                                         2


  Цветной фильм продолжительностью 1,5 часа будет содержать:
                    V = 1,5 · 3 600 · 25 · I ≈ 791 Гбит .
  Набор двоичных слов, содержащих информацию о микрозонах, на-
  зывается цифровым изображением. Операция преобразования изо-
  бражения в набор двоичных слов называется квантованием (оциф-
  ровыванием) изображения.
   Изображения, полученные с видеокамер, квантуются с помощью ана-
лого-цифровых преобразователей. Изображения на бумаге могут быть
квантованы с помощью специального устройства ― сканера. Это устройство
содержит фоточувствительные ячейки, аналого-цифровые преобразователи
и механизм относительного перемещения бумаги и фотоячеек.
   Цифровые изображения преобразуются в видимые изображения с по-
мощью цифро-аналоговых преобразователей и устройства формирования
растра: электронно-лучевой трубки и системы отклонения монитора, ма-
трицы иголок в механических принтерах и т. д.


  Вопросы и упражнения
  Ê	 Назовите операции, необходимые для квантования изображений.
  Ë	 Каково назначение растра? Чем руководствуются при выборе плотности
     линий растра?
  Ì	 Как оценить количество информации, содержащейся в монохромном изо-
     бражении?
  Í	 Как можно передать цвета многоцветного изображения? Как измерить ко-
     личество информации в цветном изображении?
  Î	 Оцените количество информации в газетной фотографии размерами 10×10 см,
      переданной с помощью растра, содержащего 24 точек/см. Каждая точка
     может содержать оттенки: белый, светло-серый, темно-серый, черный.
  Ï	 Сколько информации содержит цветная фотография размерами 20 × 20 см,
     воспроизведенная с помощью растра, содержащего 60 точек/cм. Может быть
     передано до 256 уровней яркости соответствующих точек.
  Ð	 Растр видеокамеры состоит из 1024 × 1024 точек. Может быть передано до
     64 уровней яркости соответствующих точек. Сколько информации будет со-
     держаться в фильме продолжительностью 3 часа?
  Ñ	 Цифровое изображение содержит по одному двоичному слову для каждой
     точки растра монитора. Сколько уровней яркости можно отобразить на
     экране, если слова цифрового изображения являются 3-позиционными?
     5-позиционными? 8-позиционными?
  Ò	 ИССЛЕДУЙТЕ! Пользуясь поисковиками, найдите в Интернете описа-
     ние цифровых фотоаппаратов. Узнайте мощность разрешения каждого из
     устройств при оцифровке статических изображений.
  Ó	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. С помощью поисковой системы
     найдите в Интернете описания цифровых фотоаппаратов, предлагаемых
     коммерческими агентами. Сравните эти устройства с точки зрения способа

108
      оцифровки статических изображений. Узнайте, как параметры дискрети-
      зации влияют на стоимость цифровых фотоаппаратов, каковы их преиму-
      щества, недостатки и области применения.
    	 ИССЛЕДУЙТЕ! Пользуясь поисковиками, найдите в Интернете описания
      цифровых видеокамер. Узнайте мощность разрешения каждого из устройств
      при оцифровке динамической информации.
    	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. С помощью поисковой системы най-
      дите в Интернете описания цифровых видеокамер, предлагаемых коммер-
      ческими агентами. Сравните эти камеры с точки зрения способа оцифровки
      динамических изображений. Узнайте, как параметры дискретизации влияют
      на стоимость цифровых видеокамер, каковы их преимущества, недостатки и
      области применения.


  2.6. Представление и передача информации
   Материальный объект, используемый для хранения, передачи или об-
работки информации, называется носителем информации. Различают
статические и динамические носители информации.
   Статические носители используются для хранения информации или,
другими словами, для передачи ее во времени. Информация, записанная на
статический носитель, может быть считана с целью последующей обработки
или использования. Первыми носителями информации, использованными
людьми, были камни, таблички из обожженной глины, папирус. Другим но-
сителем информации является бумага. Сообщения, записанные на бумаге в
рукописной форме, в виде рисунков или печатных текстов, могут сохраняться
очень продолжительное время. В компьютерах в качестве статических носителей
информации используются:
   – бумага для механических, струйных, лазерных и других принтеров;
   – активные слои магнитных лент и дисков;
   – отражающие среды оптических дисков и т. п.
   Передача информации в пространстве осуществляется с помощью динами-
ческих носителей. В качестве динамических носителей современная техника
использует:
   – акустические волны в газах (воздухе) или жидкостях;
   – электрические напряжение и ток;
   – электромагнитные волны и т. п.
   Поскольку передача информации производится в пространстве и време-
ни, как минимум хотя бы одна физическая величина носителя информации
должна изменяться.
  Изменение физической величины, обеспечивающее передачу сообще-
  ний, называется сигналом. Характеристика сигнала, используемая
  для представления (описания) сообщений, называется информаци-
  онным параметром.
   Например, в радио- и телевещании в качестве носителя информации ис-
пользуются электромагнитные волны. Амплитуда или частота этих волн может
изменяться во времени (рис. 2.6). В первом случае информационным параме-
тром является амплитуда колебаний, а во втором ― их частота.

                                                                        109
             б)



            Рис. 2.6. Информационные параметры электромагнитных волн:
                             a ― амплитуда; б ― частота


   В электронных компьютерах в качестве носителя информации обычно ис-
пользуется электрический ток, а напряжение и сила тока являются информаци-
онными параметрами сигнала. Форма рассматриваемых сигналов представлена
на рис. 2.7. В случае уровней напряжения с одним значением напряжения
связывается двоичная цифра 0, а с другим ― двоичная цифра 1. Двоичные
цифры 0 и 1 могут также быть связаны соответственно с отсутствием или на-
личием импульса, с отрицательным или положительным импульсом и др.




      исходная информация


      уровни напряжения


      наличие или
      отсутствие импульса

      положительный и
      отрицательный
      импульсы




              Рис. 2.7. Сигналы, используемые в вычислительной технике


110
  Сигнал называется дискретным, если соответствующий информа-
  ционный параметр может принимать конечное число значений.
  Сигнал называется непрерывным, если информационный параметр
  может принимать произвольные значения из заданного интервала.

    Например, сигналы на рис. 2.6 ― непрерывные, а сигналы на рис. 2.7 ―
дискретные. Очевидно, что дискретные и непрерывные сигналы являются
формой представления соответствующих сообщений.
    Любая техническая система использует те сигналы, которые обеспечивают
наилучшую реализацию функций, для которых она была спроектирована.
Современные компьютеры используют уровни напряжения, телефонные сети
― электрический ток, а радио и телевидение ― электромагнитные волны и
т. д. Практика показывает, что непрерывные сигналы могут быть переданы на
значительно большие расстояния, чем дискретные сигналы. Следовательно,
для обеспечения связи между компьютерами, находящимися на расстоянии,
при передаче дискретных сигналов они должны быть преобразованы в непре-
рывные. При приеме осуществляется обратное преобразование: непрерывный
сигнал преобразуется в дискретный.


    Исходная информация




     Дискретный сигнал



     Непрерывный сигнал,
     модулированный по
     амплитуде




     Непрерывный сигнал,
     модулированный по
     частоте



                    Рис. 2.8. Модуляция непрерывных сигналов


  Операция, с помощью которой информационный параметр непре-
  рывного сигнала изменяется в зависимости от значений дискретного
  сигнала, называется модуляцией.

                                                                     111
   Техническое устройство, которое реализует указанную операцию, называет-
ся модулятором. Для примера на рис. 2.8 представлены операции модуляции
по амплитуде и частоте.

                                 Дискретные    Непрерывные
                 Сообщения         сигналы       сигналы


      Источник       Шифратор         Модулятор        Физическая среда


                                                        Помехи



                             Демодулятор           Дешифратор         Приемник

                   Непрерывные        Дискретные
                                                         Сообщения
                     сигналы            сигналы

             Рис. 2.9. Подробная схема системы передачи информации


  Операция извлечения дискретного сигнала из непрерывного в соот-
  ветствии с применяемым способом модуляции называется демоду-
  ляцией.

   Техническое устройство, которое реализует соответствующую операцию,
называется демодулятором.
   Вспомним назначение компонент рассматриваемой системы:
   шифратор ― преобразует сообщения, вырабатываемые источником в дво-
ичные слова;
   модулятор ― преобразует дискретные сигналы, представляющие собой
двоичные слова, в непрерывные сигналы;
   физическая среда ― представляет собой проводники, оптические волокна,
эфир и т.п., через которые распространяются непрерывные сигналы;
   демодулятор ― преобразует непрерывные сигналы в дискретные;
   дешифратор ― преобразует двоичные слова в сообщения.
   Очевидно, что в случае использования кодов для коррекции и обнаружения
ошибок система передачи информации будет помехоустойчивой.
   Главной характеристикой любой системы передачи информации является
ее пропускная способность, которая выражается в битах в секунду. Про-
пускная способность зависит от физических характеристик компонент систе-
мы, методов модуляции-демодуляции, статистических характеристик помех.
Например, пропускная способность телефонного канала составляет около
34 Кбит/с; пропускная способность радиоканала с сантиметровыми волнами
― около 1 Гбит/с; пропускная способность оптического канала ― 1 Тбит/с.


112
Вопросы и упражнения
Ê	 В чем отличия статических и динамических носителей информации?
Ë	 Определите тип следующих носителей информации:
	  a)	 перфокарты;		                д)	 фотопленка;
	  б)	 ультразвуковые волны;		      е)	 гравитационные волны;
	  в)	 перфоленты;		                ж)	 фотобумага.
	  г)	 акустические волны;
Ì	 Назовите информационные параметры сигналов от следующих источников:
	  a)	 микрофон;
	  б)	 радиостанция, волны ― длинные, средние или короткие;
	  в)	 музыкальный инструмент;
	  г)	 радиостанция, ультракороткие волны;
	  д)	 видеокамера.
Í	 Опишите носители информации и сигналы, используемые в современных
   компьютерах.
Î	 Объясните операции модуляции и демодуляции сигналов.
Ï	 Каково назначение модулятора? Демодулятора?
Ð	 На рис. 2.8 приведены непрерывные сигналы, представляющие двоичное
   слово 1001101. В коде ASCII (таблица 2.3) это слово соответствует символу
   M. Нарисуйте непрерывные сигналы, соответствующие следующим симво-
   лам:
	    a)	 >;	           д)	 <;
	    б)	 r;	           е)	 K;
	    в)	 W;	           ж)	 a;
	    г)	 9;	           з)	 @.

Ñ	 От чего зависит пропускная способность канала? В каких единицах она из-
   меряется?
Ò	 Как влияют помехи на пропускную способность канала?
	 ИССЛЕДУЙТЕ! Узнайте пропускную способность каналов информационных
   систем, к которым у вас есть доступ дома, в школе, в общественных местах.




                                                                        113
Глава 3
                      АРИФМЕТИЧЕСКИЕ ОСНОВЫ
                     ВЫЧИСЛИТЕЛЬНОЙ ТЕХНИКИ

  3.1. Системы счисления
   В цифровых компьютерах информация любого вида представляется, хра-
нится и обрабатывается в числовой форме. Числа представляются с помощью
элементарных символов, называемых цифрами.
   Совокупность правил представления чисел вместе с множеством
   используемых цифр носит название системы счисления. Количество
   цифр определяет основание системы счисления.
   Приведем несколько примеров систем счисления:
   – десятичная система ― это система счисления по основанию 10 с коли-
чеством используемых цифр, равным 10, соответственно 0, 1, 2, ..., 9;
   – двоичная система ― это система счисления по основанию 2 с количе-
ством используемых цифр, равным 2, то есть 0 и 1. Соответствующие цифры
называются двоичными цифрами, или битами;
   – троичная система ― это система счисления по основанию 3 с количеством
используемых цифр, равным 3, соответственно 0, 1 и 2;
   – восьмеричная система ― это система счисления по основанию 8, со-
держащая 8 цифр: 0,1, 2, …,7;
   – шестнадцатеричная система ― это система счисления по основанию
16, которая содержит 16 цифр: 0, 1, 2, ..., 9, A (десять), B (одиннадцать), C
(двенадцать), D (тринадцать), E (четырнадцать), F (пятнадцать).
   В таблице 3.1 представлены одни и те же числа в различных системах
счисления.
                                                                  Таблица 3.1
          Представление чисел в различных системах счисления
Десятич-   Двоич-   Восьме-    Шестнад-    Десятич-   Двоич-   Восьме-    Шестнад-
  ная       ная     ричная    цатеричная     ная       ная     ричная    цатеричная
      0      0        0           0           7        111        7          7
      1       1       1           1           8       1000       10          8
      2      10       2           2           9       1001       11          9
      3      11       3           3          10       1010       12          A
      4     100       4           4          11       1011       13          B
      5     101       5           5          12       1100       14          C
      6     110       6           6          13       1101       15          D

114
Десятич-   Двоич-   Восьме-     Шестнад-           Деся-         Двоич-    Восьме-    Шестнад-
  ная       ная     ричная     цатеричная         тичная          ная      ричная    цатеричная

   14        1110     16              E              50       110010         62         32
   15        1111     17              F             ...         ...         ...         ...
   16       10000     20             10              60       111100         74         3C
   17       10001     21             11             ...         ...         ...         ...
   18       10010     22             12              70      1000110        106         46
   19       10011     23             13             ...         ...         ...         ...
   20      10100      24             14              80      1010000        120         50
   ...        ...     ...            ...            ...         ...         ...         ...
   30      11110      36             1E             90       1011010        132         5A
   ...        ...     ...            ...            ...         ...         ...         ...
   40      101000     50             28             100      1100100        144         64
   ...        ...     ...            ...            ...         ...         ...         ...

  Правило представления чисел в десятичной системе видно из следую-
щего примера:
                                 3         2       1         0        –1       –2
             (3856,43)10 =3 ·10 +8 ·10 +5 ·10 +6 ·10 +4 ·10 +3 ·10 .
   Заметим, что в этом представлении значение (вес) каждой цифры зависит
от положения, которое она занимает в числе. Например, цифра 3 встречается
два раза: первый раз она имеет значение 3000, а второй раз ― 0,03.

  Системы, в которых значение цифр зависит от занимаемого ими по-
  ложения в представлении (записи) чисел, называются позиционными.

   Предположим, что число N имеет целую часть, состоящую из n + 1 цифры,
а дробную часть ― из m цифр:
                              N =cncn–1...c1c 0 ,c–1c–2 ...c–m .
   Значение этого числа вычисляется в зависимости от основания системы
следующим образом:
             (N )b =cnbn+cn–1bn–1+...+c1b1+c0b0+c–1b–1+c–2b–2+...+c–mb–m.
   Путем соответствующих вычислений выполняется преобразование числа
(N)b по основанию b в десятичную систему счисления.
   Например:
                    2      1     0      –1
    (101,1)10 = 1·10 + 0·10 +1·10 + 1·10 = 101,1;		
                  2     1    0     –1
    (101,1)2 = 1·2 + 0·2 +1·2 + 1·2 = 5,5;		
                  2     1    0     –1
    (101,1)3 = 1·3 + 0·3 +1·3 + 1·3 = 10,333...;
                  2     1    0     –1
    (101,1)8 = 1·8 + 0·8 +1·8 + 1·8 = 65,125;
    (101,1)16 = 1·162 + 0·161 +1·160 + 1·16–1 = 257,0625.

                                                                                              115
   Формально десятичная система не имеет никаких особых преимуществ
перед другими системами счисления. Предполагается, что эта система была
принята в древние времена благодаря тому факту, что в процессе счета в ка-
честве инструмента использовались пальцы рук.
   Компьютер может работать в любой системе счисления. В ходе развития
вычислительной техники было установлено, что наиболее удобна двоичная
система. Предпочтение ей можно отдать по следующим причинам:
   – простота правил для арифметических и логических операций;
   – физическое представление цифр с целью хранения и обработки чисел
осуществляется гораздо легче для двух символов, чем для десяти: перфориро-
ван – не перфорирован, контакт замкнут – контакт разомкнут, наличие или
отсутствие тока и т. д.;
   – схемы, которые должны различать только два состояния, более надежны
в работе, чем схемы, которые должны различать десять состояний.
   Отметим, что в процессе развития цивилизации были созданы и непози-
ционные системы счисления. Ярким примером может служить римская
система, использующая цифры I, V, X, L, C, D, M. Поскольку правила пред-
ставления чисел и выполнения арифметических операций в таких системах
очень сложны, они имеют ограниченное применение.

  Вопросы и упражнения
  Ê	 Как определяется система счисления?
  Ë	 В чем отличие между позиционными и непозиционными системами счис-
     ления?
  Ì	 Приведите примеры позиционных систем счисления. Как определяется
     основание системы счисления?
  Í	 Переведите в десятичную систему счисления число (101,1)b, записанное в
     следующих системах счисления:
                       b = 4, 5, 6, 7, 9, 11, 12, 13, 14 и 15.
  Î	 Переведите в десятичную систему счисления следующие числа:
  	   a)	 (328)9;	       i)	   (1010,01)3;	   q)	 (341,02)8;
  	   b)	 (516)7;	       j)	   (201,12)4;	    r)	 (ABCD)16;
  	   c)	 (1010,01)2;	   k)	 (341,02)6;	      s)	 (328)16;
  	   d)	 (201,12)3;	    l)	   (1111)16;	     t)	   (516)16;
  	   e)	 (341,02)5;	    m)	 (328)11;	        u)	 (1010,01)16;
  	   f)	 (FFFF)16;	     n)	 (516)9;	         v)	 (201,12)16;
  	   g)	 (328)10;	      o)	 (1010,01)8;	     w)	 (341,02)12;
  	   h)	 (516)8;	       p)	 (201,12)8;	      x)	 (F001)16.
  Ï	 Какие факторы способствовали использованию в вычислительной технике
     двоичной системы счисления?
  Ð	 Напишите программу, переводящую числа, записанные в системах счисле-
     ния по основанию b, b≤10, в десятичную систему счисления.
  Ñ	 Напишите программу, переводящую числа, записанные в системах счисле-
     ния по основанию b, 10≤b≤36, в десятичную систему счисления.

116
  	 ИССЛЕДУЙТЕ! Найдите в Интернете, какие системы счисления исполь-
     зовались великими древними цивилизациями. Как эти системы повлияли
     на современные цивилизации?




  3.2. Перевод чисел из одной системы счисления в другую
   Перевод числа (N)b в его десятичный эквивалент осуществляется в соот-
ветствии с формулой из предыдущего параграфа:
             (N )b =cnbn+cn–1bn–1+...+c1b1+c0b0+c–1b–1+c–2b–2+...+c–mb–m.
   Перевод десятичного числа (N)10 в его эквивалент по основанию b осущест-
вляется по следующим правилам:
   – делением на соответствующее основание целой части и целочисленных
частных после каждой операции деления до получения нулевого частного;
результат перевода целой части составляется из целочисленных остатков,
записанных в порядке, обратном их вычислению;
   – умножением на основание дробной части, а затем и дробных частей, полу-
ченных в предшествующих умножениях, до тех пор пока дробная часть очеред-
ного произведения не станет равной нулю или до получения требуемого количе-
ства цифр дробной части результата; результат преобразования дробной части
состоит из целых частей произведений, записанных в порядке их вычисления.
   Проанализируем несколько примеров.
   1. Перевести десятичное число 53,40625 в его двоичный эквивалент.
                    1
    53 : 2 = 26 + /2;
    26 : 2 = 13 + 0/2;
    13 : 2 = 6 + 1/2;
    6 : 2 = 3 + 0/2;
    3 : 2 = 1 + 1/2;
    1 : 2 = 0 + 1/2.
  Следовательно, целая часть двоичного числа будет 110101.
    0,40625 × 2 = 0,8125;
    0,8125 × 2 = 1,625;
    0,625 × 2 = 1,25;
    0,25 × 2 = 0,5;
    0,5 × 2 = 1,0.
  Дробная часть двоичного числа будет 01101. Следовательно,
                         (53,40625)10 = (110101,01101)2.
  2. Перевести число 23,7 из десятичной системы в двоичную.
    23 : 2 = 11 + 1/2;
    11 : 2 = 5 + 1/2;
                1
    5 : 2 = 2 + /2;

                                                                            117
                 0
      2 : 2 = 1 + /2;
                 1
      1 : 2 = 0 + /2;

      0,7 × 2 = 1,4;
      0,4 × 2 = 0,8;
      0,8 × 2 = 1,6;
      0,6 × 2 = 1,2;
      0,2 × 2 = 0,4;
      0,4 × 2 = 0,8;
      ...
   Заметим, что операция может быть продолжена до бесконечности, то есть
не существует точного перевода анализируемого числа. Следовательно,
                                (23,7)10 = (10111,101100...)2.
  3. Осуществить перевод числа 1996,0625 из десятичной системы в восьме-
ричную.
      1996 : 8 = 249 + 4/8;
                       1
      249 : 8 = 31 + /8;
                    7
      31 : 8 = 3 + /8;
      3 : 8 = 0 + 3/8;
      				
      0,0625 × 8 = 0,5;
      0,5 × 8 = 4.
  Следовательно,
                                (1996,0625)10 = (3714,04)8.
  4. Перевести число 2914,25 из десятичной системы в шестнадцатерич-
ную.
      2914 : 16 = 182 + 2/16;
      182 : 16 = 11 + 6/16;
      11 : 16 = 0 + 11/16;

      0,25 × 16 = 4.
  Следовательно,
                                    (2914,25)10 = (B62,4)16.


  Вопросы и упражнения
  Ê	 Как осуществляется перевод числа из системы по основанию b в десятичную
     систему?
  Ë	 Переведите в десятичную систему следующие числа:
  	    a)	 (100001,01111)2;	          b)	 (328,678)9;	           c)	 (100,100)16;

118
  	   d)	 (10,01)16;	               g)	 (1221,1112)3;	            j)	 (4231,124)5;
  	   e)	 (AAA,BBB)16;	             h)	 (1321,1312)4;	            k)	 (50,505050)6;
  	   f)	 (EE,00F)16;	              i)	 (124,521)7;	              l)	 (7777,001)8.
  Ì	 Как выполняется перевод десятичного числа в его эквивалент по основанию b?
  Í	 Переведите в двоичную систему следующие десятичные числа:
  	   a)	 13,889;	                  e)	 93,447;	                  i)	 58,749;	
  	   b)	 38,668;	                  f)	 70,212;	                  j)	 4,345;
  	   c)	 53,536;	                  g)	 8,347;	                   k)	 3,156;
  	  d)	 29,261;	            h)	 39,764;	           l)	 91,428.
  	  Проверьте результаты, осуществляя перевод из двоичной в десятичную
     систему счисления.
  Î	 Переведите в восьмеричную систему следующие десятичные числа:
  	   a)	 358,932;	                 e)	 886,526;	                 i)	 795,128;
  	   b)	 479,093;	                 f)	 971,258;	                 j)	 680,895;
  	   c)	 591,241;	                 g)	 515,914;	                 k)	 256,453;
  	  d)	 649,113;	           h)	 347,607;	            l)	 838,261.
  	  Проверьте результаты, выполняя перевод из восьмеричной системы в деся-
     тичную.
  Ï	 Переведите в шестнадцатеричную систему следующие десятичные числа:
  	   a)	 1424,699;	                e)	 5818,961;	                i)	 4985,995;
  	   b)	 3517,315;	                f)	 9336,491;	                j)	 9721,678;
  	   c)	 9607,201;	                g)	 3442,722;	                k)	 5292,837;
  	  d)	 8974,664;	           h)	 4521,449;	         l)	 2734,592.
  	  Проверьте результаты, выполняя перевод из шестнадцатеричной системы
     в десятичную.
  Ð	 Напишите программу, которая переводит десятичные числа в эквиваленты
     из соответствующих систем счисления по основанию b, b<10.
  Ñ	 Напишите программу, которая переводит десятичные числа в числа систем
     по основанию b, 10<b≤36.



  3.3. Перевод чисел из двоичной системы счисления
  в восьмеричную, шестнадцатеричную и обратно
  Поскольку 8 = 23, двоично-восьмеричный перевод и восьмерично-дво-
ичный перевод может быть осуществлен напрямую. Любая восьмеричная
цифра представляется тремя двоичными цифрами:
  	                     0 = 000;	                      1 = 001;

                                                                                      119
  	                2 = 010;	                  5 = 101;
  	                3 = 011;	                  6 = 110;
   	               4 = 100;	                 7 = 111.
   Если дано восьмеричное число, то для его перевода в двоичное каждая
восьмеричная цифра заменяется тремя двоичными.
   Примеры:
                (247,315)8 = (010 100 111, 011 001 101)2;	
                (512,07)8 = (101 001 010, 000 111)2;		
                (3,146)8 = (011, 001 100 110)2.
   Если рассматривается двоичное число, то для перевода его в восьмеричное
группируем по три двоичные цифры, начиная с позиции запятой влево для
целой части и вправо соответственно для дробной части, находя эквиваленты
этих троек цифр в восьмеричной системе. При дополнении некоторой группы
до трех двоичных цифр добавление нулей в начале числа для целой части и
соответственно в конце числа для дробной части не меняет значение числа.
   Примеры:
                 (11,011101)2 = (011,011 101)2 = (3,35)8;		
                (10,11011)2 = (010,110 110)2 = (2,66)8;		
                  (1001,01011)2 = (001 001,010 110)2 = (11,26)8.	
   Аналогично поступаем и в случае шестнадцатеричной системы, основание
              4
которой 16 = 2 . Любая шестнадцатеричная цифра представляется четырьмя
двоичными цифрами:
  	                0 = 0000;	                 8 = 1000;
  	                1 = 0001;	                 9 = 1001;
  	                2 = 0010;	                 A = 1010;
  	                3 = 0011;	                 B = 1011;
  	                4 = 0100;	                 C = 1100;
  	                5 = 0101;	                 D = 1101;
  	                6 = 0110;	                 E = 1110;
  	                7 = 0111;	                 F = 1111.
  Примеры:
             (6AF3,B2)16 = (0110 1010 1111 0011, 1011 0010)2;
             (6F1,3CA)16 = (0110 1111 0001, 0011 1100 1010)2;	
             (11,01101)2 = (0011, 0110 1000)2 = (3,68)16;	
             (10001,01011)2 = (0001 0001, 0101 1000)2 = (11,58)16.

120
Вопросы и упражнения
Ê	 Как осуществляется перевод из восьмеричной в двоичную систему счисления
   и обратно?
Ë	 Переведите в двоичную систему следующие восьмеричные числа:
	   a)	 15,006;	                e)	 21,626;	           i)	 42,322;
	   b)	 13,06;	                 f)	 6,3415;	           j)	 44,523;
	   c)	 43,15;	                 g)	 771,25;	           k)	 32,271;
	   d)	 10,01;	                 h)	 12,121;	           l)	 73,536.
Ì	 Переведите в восьмеричную систему следующие двоичные числа:
	   a)	 1,1;	                   e)	 1101,1;	           i)	 10110,001011;
	   b)	 101,10101;	             f)	 1,000001;	         j)	 11111,0010001;
	   c)	 1111,000101;	           g)	 11110001,101;	     k)	 11001,00101;
	   d)	 10101110,1001;	         h)	 0,00001;	          l)	 1011,0001011.
Í	 Напишите программу для перевода чисел из двоичной в восьмеричную
   систему счисления и из восьмеричной в двоичную систему счисления.
Î	 Как осуществляется шестнадцатерично-двоичное и двоично-шестнадцате-
   ричное преобразование?
Ï	 Переведите в двоичную систему следующие шестнадцатеричные числа:
	   a)	 FFF,AAA;	               e)	 3,1AB;	            i)	 C,DC1;	
	   b)	 F,1A;	                  f)	 AABB,0000F;	       j)	 942,14A;
	   c)	 1,009;	                 g)	 81,91A;	           k)	 CAA,B;
	   d)	 0,00F;	                 h)	 10,01;	            l)	 DAD,ABA.
Ð	 Переведите в двоичную систему следующие шестнадцатеричные числа:
	   a)	 1001011101,01101;	      e)	 1011101,011;	      i)	 1011,0101;
	   b)	 111,01;	                f)	 11,001011101;	     j)	 11001,0110;
	   c)	 1,1;	                   g)	 11110,01111;	      k)	 0,00001;
	   d)	 10101110111,00101;	     h)	 111011,0010000;	   l)	 101,01011.
Ñ	 Напишите программу для перевода чисел из двоичной в шестнадцатеричную
   систему счисления и из шестнадцатеричной в двоичную систему счисления.
Ò	 Переведите в шестнадцатеричную систему следующие восьмеричные числа:
	   a)	 13,146;	              e)	 451,35;	             i)	 644,031;
	   b)	 613,12;	              f)	 12,357;	             j)	 5,4312;	
	   c)	 541,723;	             g)	 53,627;	             k)	 675,542;
	   d)	 104,527;	             h)	 572,004;	            l)	 372,271.

                                                                           121
  Ó	 Переведите в восьмеричную систему следующие шестнадцатеричные числа:
  	    a)	 AA;	                 e)	 15F,6A1;	               i)	 BBB;
  	    b)	 A2B,1F;	             f)	 3,281;	                 j)	 AF,31B;
  	    c)	 F,3A;	               g)	 9,AF;	                  k)	 2C,ACB;
  	    d)	 FFFF;	               h)	 3,418F;	                l)	 A1B,39E.

       	Напишите программу для восьмерично-шестнадцатеричного и шестнадца-
        терично-двоичного перевода чисел.



  3.4. Арифметические операции в двоичной системе
  счисления
  Арифметические операции над двоичными числами очень просты. Правила
действий в двоичной системе представлены в таблицах 3.2, 3.3 и 3.4.
         Таблица 3.2               Таблица 3.3                 Таблица 3.4
      Двоичное сложение        Двоичное вычитание          Двоичное умножение

           0+0=0                      0–0=0                        00=0
           0+1=1                      1–0=1                        01=0
           1+0=1                      1–1=0                        10=0
          1 + 1 = 10                  10 – 1 = 1                   11=1

   Примеры:
   1. Выполните сложение десятичных чисел 29 и 43 в двоичной системе
счисления:
   	(29)10 = (11101)2;
   	(43)10 = (101011)2;
   									                   11101	 +
   									                   101011
   									                         1001000
   Проверка: (1001000)2=(72)10, результат верен, поскольку (29)10+(43)10 = (72)10.
   2. Выполните вычитание десятичного числа 37 из десятичного числа 46 в
двоичной системе счисления:
   	(37)10 = (100101)2;
   	(46)10 = (101110)2;
   									                         101110	—
   									                         100101
   									                         1001
   Проверка: (1001)2 = (9)10, результат верен, поскольку (46)10 – (37)10 = (9)10.
   3. Выполните умножение десятичных чисел 3,25 и 7,125 в двоичной системе
счисления:
   	 (3,25)10 = (11,01)2;			
   	 (7,125)10 = (111,001)2;

122
                                 					 11,01	 ×
                                 					111,001
                                 					 1101
                                 					 0000
                                 	0000
                                 	1101
                                 	1101
                                  	1101
                                 10111,00101
   Проверка: (10111,00101)2 = (23,15625)10, результат верен, поскольку (3,25)10 ×
× (7,125)10 = (23,15625)10.
   4. Выполните деление десятичного числа 211 на десятичное число 3 в
двоичной системе счисления:
   	(211)10 = (11010011)2;
   	(3)10 = (11)2;
                            	11010011	 11
                            	11		           1000110
                            		00100
                            			 11
                            		 		 11
                            	 		 11
                            					01

    Следовательно 11010011 : 11=1000110, остаток 1.
    Проверка: (1000110)2 = (70)10, результат верен, поскольку (211)10 : (3)10 =
 = (70)10 + (1)10.
    Заметим, что как при умножении, так и при делении установка запятой, от-
деляющей целую часть от дробной, осуществляется так же, как и в десятичной
системе счисления.


  Вопросы и упражнения
  Ê	 Как выполняются арифметические операции в двоичной системе счисления?
  Ë	 Вычислите в двоичной системе:
  	   a)	 34 + 251;	            f)	 1996 – 51;	           k)	 0,5 × 0,5;
  	   b)	 68 – 7;	              g)	 2015 + 1995;	         l)	 1 : 0,5;
  	   c)	 1512 + 620;	          h)	 28,5 + 0,75;	         m)	 40 : 0,125;
  	   d)	 14 × 8;	              i)	 63,125 – 4,125;	      n)	 32 : 2;
  	   e)	 63 : 3;	              j)	 3,0625 × 2,125;	      o)	 32 : 16;

                                                                             123
  	   p)	 401 × 8;	                  r)	 401 × 4;	                  t)	 401 × 2;
  	  q)	 32 : 8;	           s)	 32 : 4;	            u)	 933 : 3.
  	  Числа в приведенных выражениях записаны в десятичной системе счисле-
     ния.
  Ì 	Напишите программу для сложения и вычитания двоичных чисел.
  Í	 Напишите программу для умножения и деления двоичных чисел.




  3.5. Представление натуральных чисел в компьютере
   Современные компьютеры используют двоичную систему счисления. Пред-
ставление натуральных чисел N = {0, 1, 2, ...} реализуется на фиксированном
числе двоичных позиций, как правило, 8, 16, 32 или 64 (рис. 3.1).




          Рис. 3.1. Представление натуральных чисел на n двоичных позициях

  В позициях 0, 1, ..., n ― 1 записаны двоичные цифры натурального числа,
представленного в двоичной системе счисления. Выравнивание двоичных
чисел выполняется вправо, возможные незначащие нули размещаются перед
двоичным числом.
  Для примера на рис. 3.2 приведено представление натурального числа
                                 1039 = (10000001111)2
на 16 двоичных позициях.




      Рис. 3.2. Представление натурального числа 1039 на 16 двоичных позициях

   Максимальное число, которое может быть представлено на n двоичных
позициях (рис. 3.3),

                      1 · 20 + 1 · 21 + 1 · 22 + ... + 1 · 2n–1 = 2n – 1.
  Следовательно, на n двоичных позициях могут быть представлены нату-
ральные числа из интервала [0; 2n–1].

124
  Рис. 3.3. Представление максимального натурального числа на n двоичных позициях


  Вопросы и упражнения
  Ê	 Как представляются натуральные числа в компьютере?
  Ë	 Представьте натуральные числа 3, 112, 191, 204, 255 на 8 двоичных позициях.
  Ì	 Представьте натуральные числа 3, 255, 1024, 2048, 4096, 65535 на 16 дво-
     ичных позициях.
  Í	 Вычислите максимальные натуральные числа, которые могут быть пред-
     ставлены на 4, 8, 12, 16, 24, 32 и 64 двоичных позициях.
  	 ИССЛЕДУЙТЕ! Определите, на скольких двоичных позициях представля-
     ются натуральные числа в цифровых устройствах, с которыми вы работаете.


  3.6. Представление целых чисел
   В компьютере отсутствует возможность прямого представления знаков + и
–, принадлежащих положительным и отрицательным числам. По этой при-
чине представление знака числа x осуществляется с помощью особой двоичной
цифры, именуемой цифрой знака (или знаковым битом), расположенной в
позиции n – 1 (рис. 3.4):




            Рис. 3.4. Представление целых чисел на n двоичных позициях

   Как правило, двоичные числа со знаком представляются в компьютерах не в
исходном виде, а в специальных кодах, дающих определенные преимущества при
выполнении арифметических операций. С этой точки зрения известны три способа
представления, называемые двоичными кодами для алгебраических чисел.
   Прямой код (код величина и знак). Представление любого числа в этом
коде очень простое: в цифре знака записывается 0, если число положительное,
и 1, если оно отрицательное; в значащей части записывается число (по модулю)
в обычной двоичной системе.
   Для примера на рис. 3.5 (с. 126) приведены представления чисел +52 и –52
в прямом коде на 8 двоичных позициях.

                                                                               125
               Рис. 3.5. Представление чисел +52 и –52 в прямом коде

  В прямом коде на n двоичных позициях могут быть представлены целые
положительные и отрицательные числа N, для которых:
                            –(2n–1 – 1) ≤ N ≤ (2n–1 – 1).
   Заметим, что в прямом коде существуют два двоичных представления для
числа 0: 00...0 и 10...0. Прямой код редко используется в компьютерах, по-
скольку требует сложных алгоритмов выполнения арифметических операций
и проверки результатов.
   Обратный (инверсный) код. Положительные числа записываются в инверс-
ном коде точно так же, как и в прямом. Если число отрицательное, то сначала
оно записывается как положительное, а затем инвертируется каждая двоичная
цифра, то есть 1 становится 0 и 0 становится 1. Отсюда и название ― обратный код.
   На рис. 3.6 приведены представления чисел +52 и –52 в обратном коде на
8 двоичных позициях.




              Рис. 3.6. Представление чисел +52 и –52 в обратном коде

   Можно легко установить, что интервал целых чисел N, которые могут быть
представлены в обратном коде, такой же, как и для прямого кода, а число 0
имеет два двоичных представления: 00...0 и 11...1.
   Дополнительный код. В этом коде положительные числа имеют точно
такое же представление, как в прямом и инверсном кодах. Если число от-
рицательное, оно сначала записывается в обратном коде, а затем к младшей
значащей цифре (двоичная позиция 0) прибавляется 1.

126
  Для примера на рис. 3.7 приведены представления чисел +52 и –52 в
дополнительном коде.




                                                         в обратномном
                                                         коде




                                                        в дополнительном
                                                        коде


           Рис. 3.7. Представление чисел +52 и –52 в дополнительном коде

   Дополнительный код используется в большинстве компьютеров благодаря
простоте выполнения в нем арифметических операций и легкости проверки
результатов. В этом коде на n двоичных позициях могут быть представлены
целые числа из интервала [–2n–1, 2n–1 – 1].


  Вопросы и упражнения
  Ê	 Как могут быть представлены в компьютере целые числа? Объясните, как
     записываются отрицательные числа в прямом, инверсном и дополнительном
     кодах.
  Ë	 Представьте в прямом коде на 8 двоичных позициях:
  	   a)	 +12;	                  d)	 –12;	                  g)	 +21;
  	   b)	 –21;	                  e)	 –64;	                  h)	 –68;
  	   c)	 +68;	                  f)	 +105;	                 i)	 –112.

  Ì	 Представьте в обратном коде на 8 двоичных позициях:
  	   a)	 +10;	                  d)	 –10;	                  g)	 +65;
  	   b)	 –65;	                  e)	 +101;	                 h)	 –101;
  	   c)	 +112;	                 f)	 –112;	                 i)	 –105.
  Í	 Представьте в дополнительном коде на 8 двоичных позициях:
  	   a)	 +40;	                  c)	 +109;	                 e)	 –40;
  	   b)	 +27;	                  d)	 –16;	                  f)	 –27;

                                                                           127
  	     g)	 –109;	                 i)	 +16;	                  k)	 +111;
  	     h)	 –101;	                 j)	 +101;	                 l)	 –111.
  Î	 Напишите программу, которая считывает с клавиатуры целые числа и вы-
     водит на экран их представления в прямом, обратном и дополнительном
     кодах для n = 8, 16 и 32.
  Ï	 Как представляется число 0 в прямом, обратном и дополнительном кодах?
     Сколько представлений есть у числа 0 в рассматриваемых кодах?
  Ð	 Определите максимальное число, которое может быть представлено на n
     двоичных позициях в прямом, обратном и дополнительном кодах.
  	 ИССЛЕДУЙТЕ! Узнайте, на скольких позициях и какими двоичными ко-
     дами для алгебраических чисел представляются целые числа в цифровых
     устройствах, с которыми вы работаете.




  3.7. Представление вещественных чисел
   Вещественные числа представляются в компьютере в формате с фиксиро-
ванной или плавающей запятой (в экспоненциальной форме).
   Представление с фиксированной запятой. В этом представлении счи-
тается, что у всех чисел запятая расположена в одной и той же позиции, хотя
это и не соответствует внешней форме представления чисел. Процесс преоб-
разования из внешней формы во внутреннюю и обратно реализуется путем
выбора программистом соответствующих масштабных коэффициентов.
   Обычно считается, что запятая размещается сразу после цифры знака ―
случай, когда числа содержат только дробную часть (рис. 3.8).




       Позиция запятой

      Рис. 3.8. Представление вещественных чисел в формате с фиксированной запятой


  Собственно, запятая не материализована физически в компьютере. Из
рис. 3.8 следует, что на n двоичных позициях можно представить вещественные
числа, абсолютное значение которых
                               0,00...0 ≤ |x| ≤ 0,11…1
или в десятичной системе счисления,
                                  0 ≤ |x| ≤ 1 – 2–(n–1).

128
   Как и в случае целых чисел, вещественные числа, меньшие единицы, мо-
гут быть представлены с некоторыми изменениями в прямом, обратном или
дополнительном кодах.
   Для примера на рис. 3.9 приведено представление чисел
                           + 0,9375 = + 15/16 = (0,1111)2,
                           – 0,9375 = – 15/16 = (–0,1111)2
в формате с фиксированной запятой на 8 двоичных позициях в прямом коде.




              Рис. 3.9. Представление чисел +0,9375 и –0,9375 в формате
                        с фиксированной запятой в прямом коде

   Главное преимущество представления с фиксированной запятой состоит в
том, что арифметические операции над вещественными числами могут быть
выполнены арифметическим устройством, предназначенным для обработки
целых чисел.
   Представление с плавающей запятой. Операции над числами с фик-
сированной запятой удобны для однородных потоков данных, когда все
вещественные числа по модулю меньше 1. Однако такое представление не
эффективно в научных расчетах при одновременной работе с очень большими
и очень малыми числами, порядок которых заранее непредсказуем. Для таких
задач используется представление с плавающей запятой.
   Числа, представляемые в формате с плавающей запятой, могут быть как
целыми, так и дробными, а их значение задается соотношением:

                                    x=M×b ,
                                         E



где b ― основание, M ― мантисса, а E ― экспонента. В современных компью-
терах используется b = 2 или 16, а | M | ≤ 1.
   Число, представленное в формате с плавающей запятой, является норма-
лизованным, если первая после запятой цифра мантиссы отлична от нуля.
  Примеры:
  1. Число 23 выражается в формате с плавающей запятой так:
                                                    5
                           23 = (10111)2 = 0,10111×2 ,
где M = 0,10111; b = 2; E = 5.

                                                                          129
   2. Число 4,9375 записывается в формате с плавающей запятой следующим
образом:
                     4,9375 = (100,1111)2 = 0,1001111×23,
   M = 0,1001111; b = 2; E = 3.
   3. Число –0,375 записывается в формате с плавающей запятой так:
                         – 0,375 = (– 0,011)2 = – 0,11×2–1,
   M = – 0,11; b = 2; E = – 1.
   Отметим, что реальная позиция запятой внутри числа зависит от значе-
ния экспоненты, то есть запятая меняет свое положение (отсюда и название
плавающая запятая).
   Существует несколько вариантов представления мантиссы и экспоненты
на n двоичных позициях. На рис. 3.10 приведено представление с плавающей
запятой в формате экспонента–мантисса.

                Знак
              мантиссы

                            Экспонента              Мантисса

                      Знак
                  экспоненты


      Рис. 3.10. Представление с плавающей запятой в формате экспонента-мантисса

   Количество двоичных позиций nE, выделенных экспоненте, устанавливает
область значений чисел, которые могут быть представлены, тогда как коли-
чество битов для мантиссы nM определяет точность представления числа.
В современных компьютерах nE = 6...15 и nM = 24...64, что обеспечивает пред-
ставление чисел в очень широком диапазоне.
   На рис. 3.11 приведено представление чисел в формате характеристи-
ка–мантисса.


                 Знак
               мантиссы

                           Характеристика             Мантисса



  Рис. 3.11. Представление с плавающей запятой в формате характеристика-мантисса

  Характеристика C ― это форма представления экспоненты E. Она опреде-
ляется соотношением
                                     C = E + K.

130
  В персональных компьютерах
                                       nc –1
                                 K=2           – 1,
где nC ― это количество двоичных позиций, выделенных для характеристики.
В этом представлении характеристика в отличие от экспоненты не может при-
нимать отрицательных значений, что упрощает арифметические устройства.
   В частности, для n = 8 характеристика вычисляется так:
                                 C = E + 127,
указывая практически знак экспоненты:
   – если C ≥ 127, тогда E ≥ 0;
   – если C < 127, тогда E < 0.
   В таблице 3.5 представлены форматы характеристика–мантисса, исполь-
зуемые в большинстве персональных компьютеров.
                                                                              Таблица 3.5
Форматы характеристика-мантисса, используемые в персональных компьютерах

                                          Точность мантис- Область воз-
 Название формата       n    nC    nM      сы, десятичные можных значе-
                                               цифры        ний чисел
                                                                               –37
Обычная точность        32   8      23                 6 sau 7            10         ...1038
Двойная точность        64   11     52                15 sau 16           10–307...10308
Расширенная точность    80   15     64                   19              10–4932...104932
   Поскольку в соответствии с условием нормализации первая цифра мантиссы
всегда равна 1, эта цифра может быть представлена или не представлена в
памяти компьютера. В случае, когда она не представлена, указанная цифра
называется скрытым битом. Отметим, что техника скрытого бита относится
только к представлению чисел в памяти, но не к операциям, выполняемым
арифметическим устройством.


  Вопросы и упражнения
  Ê	 Какие различия имеют представления с фиксированной и плавающей за-
     пятой?
  Ë	 Представьте в формате с фиксированной запятой на 8 двоичных позициях
     в прямом коде:
  	   a)	 +0,875;	           e)	 –0,875;	                         i)	 +0,125;
  	   b)	 –0,125;	           f)	 +0,3;	                           j)	 –0,3;
  	   c)	 +0,4;	             g)	 –0,4;	                           k)	 +0,15625;	
  	   d)	 –0,15625;	         h)	 +0,21875;	                       l)	 –0,21875.

  Ì	 Укажите преимущества и недостатки у представления с фиксированной
     запятой.

                                                                                               131
  Í	 Как представляются вещественные числа в формате с плавающей запятой?
     Какие числа, представленные в формате с плавающей запятой, удовлетво-
     ряют условию нормализации?
  Î	 Как выполняется нормализация чисел, представленных в формате с пла-
     вающей запятой?
  Ï	 Представьте в формате с плавающей запятой следующие числа:
  	   a)	 +1,5;	               e)	 –1,5;	               i)	 –0,0625;
  	   b)	 +0,0625;	            f)	 +3,25;	              j)	 +2,7;
  	   c)	 –3,25;	              g)	 –32,87;	             k)	 –2,7;
  	   d)	 –6,25;	              h)	 +6,25;	              l)	 –0,147.

  Ð	 От чего зависят точность и область значений чисел, представленных в фор-
     мате с плавающей запятой?
  Ñ	 Каковы различия между форматами экспонента–мантисса и характерис-
     тика–мантисса? Как рассчитываются характеристики чисел, представлен-
     ных в формате с плавающей запятой?
  Ò	 Вычислите характеристики чисел из упражнения 6. Предполагается, что
     nC = 8.
  Ó	 Объясните термин скрытый бит. Каковы преимущества такого представ-
     ления?
      	ИССЛЕДУЙТЕ! Узнайте, как представляются натуральные, целые и веще-
       ственные числа в цифровых устройствах, с которыми вы работаете? Опреде-
       лите количество двоичных позиций, используемых каждым представлением.




132
Глава 4
                                              БУЛЕВА АЛГЕБРА

  4.1. Логические переменные и выражения
   Булева алгебра, или алгебра логики является составной частью мате-
матики. В ней законы мышления ― объект изучения классической логики ―
изучаются с помощью символических методов. Такое название она получила
в честь английского математика Джорджа Буля, который в своей работе The
Laws of Thought (Законы мышления), опубликованной в 1853 году, заложил
основы алгебры логики. Долгие годы булева алгебра считалась просто мате-
матическим курьезом, неприменимым к практическим областям науки. Она
снова стала актуальной с появлением автоматических телефонных сетей и
цифровых компьютеров.
   С формальной точки зрения булева алгебра может быть определена мно-
жеством элементов {0, 1}, множеством элементарных операций {‾, &, (} и
определенным набором постулатов. Следовательно, в алгебре логики любая
переменная может иметь только одно из двух возможных значений, обозна-
чаемых условно 0 и 1, причем другие значения являются недопустимыми.
   Переменные алгебры логики обозначаются через x, y, z, x1, x2, ... с индек-
сами или без них, а элементы 0 и 1 называются логическими константами.
   Элементарные операции алгебры логики имеют следующие названия:
   ¯ ― отрицание (инверсия, логическая операция НЕ);
   & ― конъюнкция (логическое произведение, логическая операция И);
   ( ― дизъюнкция (логическая сумма, логическая операция ИЛИ).
   Элементарные операции определяются с помощью специальных таблиц,
называемых таблицами истинности.
  Таблица истинности ― это таблица, включающая все возможные
  комбинации значений переменных, для которых определен оператор,
  и результаты соответствующей операции.
  На рис. 4.1 представлены таблицы истинности отрицания, конъюнкции и
дизъюнкции.
         x                  x      y    x&y             x      y    x∨y
         0      1          0       0      0            0       0      0
         1      0          0       1      0            0       1      1
                           1       0      0            1       0      1
                           1       1      1            1       1      1
         Рис. 4.1. Таблицы истинности элементарных логических операторов

                                                                           133
   Отметим, что в булевой алгебре отрицание обозначается горизонтальной
линией над соответствующей переменной.
   Поскольку переменная x может принимать значения 0 или 1, таблица
истинности отрицания содержит только две строки. В случае конъюнкции и
дизъюнкции таблицы истинности содержат четыре строки ― по одной строке
для каждой возможной комбинации 00, 01, 10 и 11 значений переменных x и y.
   Логические переменные и константы, объединенные с помощью операторов
¯, & и (, образуют логические выражения, например:
  	               1)	 x & y ∨ z;	                  4)	 1 & x ∨ y;
  	               2)	 x ∨ y & z;	                  5)	 0 ∨ x ∨ y.
   	              3)	 & y ∨ z;	            6)	 1 ∨ 0.
   Значения логических выражений могут быть вычислены с помощью таблиц
истинности элементарных операторов. Для вычисления выражений устанав-
ливается следующий приоритет логических операторов:
   1) отрицание;
   2) конъюнкция;
   3) дизъюнкция.
   Например, в выражении
                                x∨y&z
сначала выполняется операция &, а после нее ― операция (. В выражении
                                  x&y∨
выполняется отрицание, затем ― конъюнкция и в конце ― дизъюнкция.
   Порядок выполнения логических операторов может быть изменен с по-
мощью скобок „(” и „)”. Ясно, что в первую очередь выполняются операции,
заключенные в скобки.
   Например, в случае логического выражения
                            x∨y& ∨z
выполняются отрицание, конъюнкция и затем соответствующие операции
дизъюнкции. В случае выражения
                                (x ∨ y) & ( ∨ z)
после отрицания выполняются дизъюнкции и в конце ― конъюнкция.
   Для систематизации вычисление логических выражений выполняется с
помощью специальных таблиц, называемых таблицами истинности логи-
ческих выражений.
  Таблица истинности логического выражения включает все возмож-
  ные комбинации значений переменных рассматриваемого выражения
  и результаты логических операций в порядке их вычисления.
  Для примера на рис. 4.2 представлена таблица истинности выражения
                                     & y ∨ z,
а на рис. 4.3 ― таблица истинности выражения
                                    x & y ∨ z.

134
                 x y z                       &y        &y∨ z
                 0 0 0           1           0            0
                 0 0 1           1           0            1
                 0 1 0           1           1            1
                 0 1 1           1           1            1
                 1 0 0           0           0            0
                 1 0 1           0           0            1
                 1 1 0           0           0            0
                 1 1 1           0           0            1
          Рис. 4.2. Таблица истинности логического выражения   &y∨z

                 x y z         x&y       x&y∨ z       x&y∨ z
                 0 0 0           0           0            1
                 0 0 1           0           1            0
                 0 1 0           0           0            1
                 0 1 1           0           1            0
                 1 0 0           0           0            1
                 1 0 1           0           1            0
                 1 1 0           1           1            0
                 1 1 1           1           1            0
          Рис. 4.3. Таблица истинности логического выражения x & y ∨ z

  Отметим, что с целью упрощения записей в логических выражениях раз-
решается опускать символ оператора &. Например, логические выражения
                                   & y ∨ z,
                             (x ∨ y) & ( ∨ z)
могут быть записаны в виде:
                                   y ∨ z,
                              (x ∨ y)( ∨ z).


  Вопросы и упражнения
  Ê	 Какие значения могут принимать логические переменные?
  Ë	 Какие элементарные операторы используются в алгебре логики и как они
     определяются?
  Ì	 Запомните таблицы истинности отрицания, конъюнкции и дизъюнкции.
  Í	 Как составляются логические выражения? Укажите приоритет логических
     операций?
  Î	 Объясните роль скобок при вычислении логических выражений.

                                                                         135
  Ï	 Составьте таблицы истинности следующих логических выражений:
  	    a)	   y;	          h)	    y;

  	    b)	    ∨ y;	       i)	 xyz;

  	    c)	 x ∨ y;	        j)	 x ∨ y ∨ z;

  	    d)	   ;	           k)	 xy ∨ z;

  	    e)	   x;	          l)	 x (y ∨ z);

  	    f)	 xy;	           m)	 ∨ y ∨ z;

  	    g)	    ∨ x;	       n)	   (y ∨ z).

  Ð	 Напишите программу, которая считывает с клавиатуры значения логических
     переменных x, y, z и выводит на экран значения следующих выражений:

  	    a)	   ;	           f)	 x ∨ y ∨ z;

  	    b) 	 xy;	          g)	 xy ∨ z;

  	    c)	 x ∨ y;	        h)	 x ∨ y ∨ z;

  	    d)	 (x ∨ y) z;	    i)	 x ∨ xy;

  	    e)	 xy ∨ z;	       j)	   ∨ y ∨ z.
  Ñ	 Напишите программу, которая выводит на экран таблицы истинности конъ-
     юнкции и дизъюнкции.
  Ò	 Составьте циклический алгоритм, который формирует все возможные комби-
     нации значений переменных x, y и z. Выведите соответствующие комбинации
     на экран.
  Ó	 Для каждого из нижеприведенных логических выражений напишите про-
     грамму, которая выводит на экран соответствующую таблицу истинности:
  	    a)	 x ∨ ;	         f)	   y;

  	    b)	 x ;	           g)	 x ∨ y ∨ z;

  	    c)	 x ∨ y;	        h)	 xyz;

  	    d)	 xy;	           i)	 (x ∨ y)( ∨ y);

  	    e)	   ∨ y;	        j)	 (x ∨ y)(x ∨ y).
      	 ТВОРИТЕ! Соберите необходимую информацию и напишите эссе о жизни,
        учебе и профессиональной карьере английского математика Джорджа Буля.
      	 УЗНАЙТЕ! В отличие от двоичной логики, то есть логики, которая работает
        только с двумя возможными значениями, существуют ее расширения, ко-
        торые работают с тремя и даже более значениями. Исследуйте различные
        источники информации, узнайте эти расширения и области, в которых они
        используются.

136
  4.2. Логические функции
   Понятие логической, или булевой функции определяется таким же об-
разом, как и в случае классической алгебры.
   Обозначим через x1, x2, ..., xn произвольную группу булевых переменных,
где n = 1, 2, 3, ... .
   Поскольку каждая булева переменная может иметь только значения 0 или
1, количество всевозможных комбинаций значений переменных x1, x2, ..., xn
составляет 2n.
   Очевидно, для n = 1 имеем две комбинации (0 и 1); для n = 2 существуют
22 = 4 комбинации (00, 01, 10 и 11); для n = 3 существуют 23 = 8 комбинаций
(000, 001, 010, 011, 100, 101, 110 и 111) и т. д.
   Логическая функция n переменных y = f (x1, x2, ..., xn) есть отображе-
   ние, которое ставит в соответствие каждой комбинации значений
   переменных x1, x2, ..., xn значение 0 или 1 переменной y.
   Переменные x1, x2, ..., xn называются независимыми переменными, или
аргументами, а переменная y – зависимая переменная, или функция
аргументов x1, x2, ..., xn .
   Следовательно, область определения функции y = f (x1, x2, ..., xn ) ― это
множество всевозможных комбинаций
                                       0 0 ... 0
                                       0 0 ... 1
                                          ...
                                       1 1 ... 1
значений аргументов x1, x2, ..., xn (всего 2n комбинаций), а областью значений
логической функции является множество {0, 1}.
   Как и в случае классической алгебры, логические функции могут быть
определены с помощью таблиц, формул и графических методов.
   Таблица истинности логической функции y = f (x1, x2, ..., xn) ― это
   таблица, включающая все возможные комбинации значений ар-
   гументов x1, x2, ..., xn и соответствующие им значения зависимой
   переменной y.
   Например, на рис. 4.4 представлена таблица истинности некоторой
логической функции трех переменных.
                               x1 x 2 x 3            y
                               0   0   0             1
                               0   0   1             0
                               0   1   0             1
                               0   1   1             0
                               1   0   0             1
                               1   0   1             0
                               1   1   0             0
                               1   1   1             0
     Рис. 4.4. Таблица истинности некоторой логической функции трех переменных

                                                                                 137
                            3
   Таблица состоит из 2 = 8 строк и 2 столбцов: первого – для всевозможных
комбинаций значений аргументов x1, x2, x3 и второго – для соответствующих
значений зависимой переменной y. В рассматриваемой таблице комбинации
x1 = 0, x2 = 0, x3 = 0 соответствует значение y = f (0,0,0) = 1; комбинации x1 = 0, x2
= 0, x3 = 1 – значение y = f (0,0,1) = 0 и т. д.
   Определение логических функций с помощью формул осуществляется
присваиванием зависимой переменной y значений логического выражения,
содержащего аргументы x1, x2, ..., xn.
   Например:
   	                      1)	 y = x;	             3)	 y = 1x2 ∨ x3;
   	                      2)	 y = x1x2;	          4)	 y = x1x2 ∨ x3.
   Очевидно, что, зная формулу логической функции, можно составить ее
таблицу истинности. Например, таблица истинности функции
                                     y = x1x2 ∨ x3
будет такой же, как и приведенная на рис.4.4. Чтобы удостовериться в этом,
достаточно составить таблицу истинности логического выражения
                                      x1x2 ∨ x3 ,
представленную в других обозначениях на рис. 4.3 из параграфа 4.1.
  Существуют также графические методы определения логических
функций. Эти методы основываются на диаграммах, применяемых в теории
множеств, и изучаются в углубленных курсах информатики.


   Вопросы и упражнения
   Ê	 Сформулируйте определение понятия логическая функция.
   Ë	 Укажите область определения и область значений логической функции.
   Ì	 Какими способами может быть определена логическая функция n переменных?
   Í	 Как составляется таблица истинности логической функции n переменных?
      Сколько строк содержит такая таблица?
   Î	 Как можно составить таблицу истинности логической функции, если из-
      вестна ее формула?
   Ï	 Логическая функция трех переменных y = f (x1, x2, x3) определена с помощью
      таблицы истинности, приведенной на рис. 4.4. Укажите комбинации значений
      аргументов x1, x2, x3, для которых рассматриваемая функция имеет значение
      y = 1. Укажите соответствующие комбинации для значения функции y = 0.
   Ð	 Составьте таблицы истинности следующих функций:
   	    a)	 y = x;	                      f)	 y = x1 ∨ x2;
   	    b)	 y = ;	                       g)	 y = x1x2x3;
   	    c)	 y = x1x2;	                   h)	 y = x1(x2 ∨       3   );
   	    d)	 y = x1 ∨ x2;	                i)	 y =     1   ∨ x2 x3;
   	    e)	 y = x1x2;	                   j)	 y = x1 ∨ x2 x3.

138
  Ñ	 Напишите программы, которые считывают с клавиатуры значения логиче-
     ских переменных x1, x2, x3, x4 и выводят на экран значения одной из следу-
     ющих функций:
  	 a)	 y = x1x2 ∨ x3x4;	               g)	 y = x1 2 ∨ x3 4;
  	   b)	 y = (x1 ∨ x2)(x3 ∨ x4);	              h)	 y =    x ∨
                                                           1 2           x;
                                                                         3 4

  	   c)	 y = x1x2x3x4;	                        i)	 y =    1 2   ∨       3 4     ;
  	   d)	 y = x1 ∨ x2 ∨ x3 ∨ x4;	               j)	 y = x1x2x3x4 ∨                   xx;
                                                                                     2 3 4

  	   e)	 y = x1x2 ∨ x3x4;	                     k)	 y = x1 ∨ x2 x3 ∨ x4;
  	 f)	 y = (x1 ∨ x2)(x3 ∨ x4);	   l)	 y = x1 ∨ x2 ∨ x3 ∨ 1 2 3 4.
  Ò	 Напишите программы, которые составляют таблицы истинности следующих
     функций:
  	 a)	 y = x;	                    h)	 y = 1 2;
  	   b)	 y = ;	                                i)	   y = x1x2x3;
  	   c)	 y = x1x2;	                            j)	   y=   1   ∨     2   ∨       3   ;
  	   d)	 y = x1 ∨ x2;	                         k)	 y = x1 ∨ x2 ∨ x3;
  	   e)	 y = x1x2;	                            l)	   y=   1 2 3     ;
  	   f)	 y =   1   ∨   2   ;	                  m)	 y = x1 ∨ x2 ∨                1 2 3 4          ;
  	   g)	 y = x1 ∨ x2;	                         n)	 y = x1(x2 ∨              3   ∨       4   ).



  4.3. Часто используемые логические функции
    Рассмотрим n независимых переменных x1, x2, ..., xn. Возникает вопрос, сколько
логических функций n переменных существует в булевой алгебре? Количество воз-
можных логических функций можно получить путем следующих рассуждений.
    Поскольку любая логическая функция может быть определена с помощью
таблицы истинности, то число возможных функций n переменных совпадает
с количеством различных таблиц истинности.
    Для того чтобы определить логическую функцию, в столбце y таблицы истин-
ности указываются значения функции – 0 или 1 для каждой из всевозможных
2n комбинаций значений аргументов. Поскольку в таблице истинности 2n строк,
существует
                                           n
                                    m = 22
логических функций n переменных. Соответствующие функции обозначаются
yj, j = 0, 1, ..., m –1.
                                                  21    2
Например, в случае, когда n = 1, существует m = 2 = 2 = 4 логических функций,
представленных на рис. 4.5.
                                 x     y0        y1            y2                        y3
                                 0     0         1             0                         1
                                 1     0         0             1                         1
                            Рис. 4.5. Логические функции одной переменной

                                                                                                      139
     Очевидно,
                              y0 = f (x) = 0;
                              y1 = f (x) = ;
                              y2 = f (x) = x;
                              y3 = f (x) = 1.
   Функции y0 и y3 называются функция-константа 0 и функция-кон-
станта 1 соответственно. Функция y1 ― это логическая функция НЕ, или
отрицание, а функция y2 называется функцией повторения.
   Для n = 2 существует             2
                                  2      4
                            m = 2 = 2 = 16
логических функций, представленных на рис. 4.6.
x1 x2     y0   y1   y2     y3   y4   y5   y6   y7   y8   y9   y10   y11   y12   y13   y14   y15
 0    0   0    1    0      1    0    1    0    1    0    1    0     1     0     1     0     1
 0    1   0    0    1      1    0    0    1    1    0    0    1     1     0     0     1     1
 0    1   0    0    0      0    1    1    1    1    0    0    0     0     1     1     1     1
 1    1   0    0    0      0    0    0    0    0    1    1    1     1     1     1     1     1
                         Рис. 4.6. Логические функции двух переменных
     Функции y0 и y15 нам уже знакомы, константа 0 и константа 1 соответственно:
                               y0 = f (x1, x2) = 0;
                               y15 = f (x1, x2) = 1.
     Функция y8 может быть записана в виде:
                               y8 = f (x1, x2) = x1x2.
     Очевидно, что y8 имеет название логическая функция И, или конъюнкция.
     Функция y14 может быть записана в виде:
                        y14 = f (x1, x2) = x1 ∨ x2.
  Следовательно, функция y14 называется логической функцией ИЛИ
либо дизъюнкцией.
     Логические функции НЕ, И, ИЛИ, введенные с помощью элементарных
     операторов ¯, &, ( соответственно называются элементарными
     логическими функциями.
     Из рис. 4.6 следует, что
                                y1 = x1 ∨ x2.
     Рассматриваемая функция называется логической функцией ИЛИ-НЕ.
     Аналогичным образом функция y7 может быть представлена в виде
                            y7 = f (x1, x2) = x1x2.
  Рассматриваемая функция называется логической функцией И-НЕ.
  Функция
                           y9 = f (x1, x2) = 1 2 ∨ x1x2
принимает значение 1 только тогда, когда x1 = x2 = 0 или x1 = x2 = 1. Эта функция
называется логической функцией СОВПАДЕНИЕ, или ЭКВИВАЛЕНТ-
НОСТЬ и обозначается с помощью символа “≡”.
140
   Анализируя таблицу на рис. 4.6, также заметим, что
                    y3 = f (x1, x2) = 1 (отрицание переменной x1);
                    y12 = f (x1, x2) = x1 (повторение переменной x1);
                    y5 = f (x1, x2) = 2 (отрицание переменной x2);
                    y10 = f (x1, x2) = x2 (повторение переменной x2).
   Для лучшего запоминания на рис. 4.7 представлены таблицы истинности
логических функций НЕ, И, ИЛИ, И-НЕ, ИЛИ-НЕ и СОВПАДЕНИЕ.
                 НЕ                     И                  ИЛИ
             x                  x1 x2       x1x2     x1 x2   x1 ∨ x2
             0          1        0 0         0       0 0           0
             1          0        0 1         0       0 1           1
                                 1 0         0       1 0           1
                                 1 1         1       1 1           1


                 И-НЕ             ИЛИ-НЕ             СОВПАДЕНИЕ
            x1 x2     x1x2     x1 x2    x1 ∨ x2      x1 x2   x1 ∨ x2
            0 0         1       0 0          1       0 0           1
            0 1         1       0 1          0       0 1           0
            1 0         1       1 0          0       1 0           0
            1 1         0       1 1          0       1 1           1
                 Рис. 4.7. Часто используемые логические функции
   Аналогично можно рассматривать логические     функции от трех пере-
                                       23   8
менных, число которых составляет m = 2 =4 2 = 256; логические функции
                                          2   16
четырех переменных, число которых m = 2 = 2 = 65 536 и т. д. Заметим,
что, будучи конечным, число булевых функций все равно огромно. Однако
доказано, что любая логическая функция n переменных, n ≥ 2, может
быть выражена с помощью формулы, содержащей только элементар-
ные операторы ¯, &, (. Указанное свойство упрощает техническую реали-
зацию устройств, предназначенных для вычисления логических функций
произвольного числа аргументов.

  Вопросы и упражнения
  Ê	 Определите число логических функций пяти и шести переменных.
  Ë	 Назовите элементарные логические функции и составьте соответствующие
     им таблицы истинности.
  Ì	 Запомните таблицы истинности часто используемых логических функций
     НЕ, И, ИЛИ, И-НЕ, ИЛИ-НЕ и СОВПАДЕНИЕ.
  Í	 Напишите программу, которая выводит на экран таблицу истинности одной
     из логических функций y0, y1, y2, y3 двух переменных.
  Î	 Напишите программу, которая выводит на экран таблицу истинности одной
     из логической функций yj от n переменных.

                                                                       141
Глава 5
                                     ЛОГИЧЕСКИЕ СХЕМЫ

  5.1. Логические элементы
   Логическая схема ― это устройство, предназначенное для вычисления
логических функций. Для реализации логических схем необходимо, чтобы
двоичные значения 0, 1 аргументов и соответствующих логических функций
были представлены значениями определенных физических величин, напри-
мер давления, температуры, напряжения или силы электрического тока,
освещенности и т. п. В зависимости от используемых величин различаем следу-
ющие логические устройства: механические, пневматические, гидравлические,
электромеханические, электронные, оптические и т. п. В гидравлических и
пневматических устройствах логические значения 0, 1 могут представляться
малыми и соответственно большими значениями давления жидкости или
газа, в электромеханических и электронных устройствах ― присутствием или
отсутствием электрического тока, с помощью уровней напряжения и т. д.
   Для более ясного понимания принципов работы логических устройств рас-
смотрим сначала контактные схемы. Базовыми элементами этих схем являются
элементы коммутации ― нормально разомкнутые и нормально замкнутые
электрические контакты.
   В случае нормально разомкнутых контактов электрическая цепь разом-
кнута, если контакты выключены, и замкнута, если они включены. В случае
нормально замкнутых контактов электрическая цепь замкнута, если кон-
такты выключены, и разомкнута в противном случае (рис. 5.1).

                                    Выключены                Включены
 Нормально разомкнутые
 контакты
 Нормально замкнутые
 контакты
         Рис. 5.1. Нормально разомкнутые и нормально замкнутые контакты

   Например, контакты дверной кнопки электрического звонка являются
нормально разомкнутыми, а контакты кнопки Пауза обычного магнитофона
― нормально замкнутыми.
   В контактных схемах логические значения аргументов представлены со-
стояниями соответствующих электрических контактов. Логическому значению
1 соответствует состояние включен, а логическому значению 0 соответствует
состояние выключен.

142
   Электрическая схема, реализующая логическую функцию НЕ и исполь-
зуемое обозначение, представлена на рис. 5.2.




                                                            б)
                          а)

                  Рис. 5.2. Схема с контактами для реализации
            логической функции НЕ (a) и используемое обозначение (б)

   Аргумент x представлен с помощью нормально замкнутого контакта, а
значения зависимой переменной y ― с помощью состояний электрической
лампы: погашена (логическое значение 0) или горит (логическое значение 1).
Заметим, что лампа будет гореть (y = 1 ), если нормально замкнутый контакт
не включен (x = 0 ).
   Логическая функция И реализуется последовательным соединением
электрических контактов. Электрическая схема, реализующая функцию И
двух переменных, и используемое обозначение представлены на рис. 5.3.




                                                             б)
                           а)

                   Рис. 5.3. Схема с контактами для реализации
             логической функции И (a) и используемое обозначение (б)

   Переменные x1 и x2 представлены с помощью двух нормально разомкнутых
контактов, а значение переменной y – с помощью лампы. Заметим, что лампа
будет гореть (y = 1) только тогда, когда оба нормально разомкнутых контакта
одновременно включены (x1 = 1 и x2 = 1).
   Логическая функция ИЛИ реализуется параллельным соединением
электрических контактов. Соответствующая схема представлена на рис. 5.4.

                                                                       143
                                                                  б)
                               а)

                    Рис. 5.4. Схема с контактами для реализации
             логической функции ИЛИ (a) и используемое обозначение (б)

   Отметим, что лампа будет гореть ( y = 1), если хотя бы один из нормально
разомкнутых контактов будет включен ( x1 = 1 или x2 = 1).
   Поскольку скорость замыкания-размыкания электрических контактов очень
мала, то в современных компьютерах значения 0, 1 представлены уровнями
напряжения, а в качестве коммутирующего элемента используется транзистор.
   Транзистор ― это электронный прибор, изготовленный внутри или на
поверхности полупроводникового кристалла. Современные технологии по-
зволяют получать 106 – 107 транзисторов на 1 cм2 площади кристалла.
   В режиме коммутации транзистор можно рассматривать как обычный вы-
ключатель, который в одном состоянии проводит электрический ток (контакты
замкнуты), а в другом ― нет (контакты разомкнуты). Однако в отличие от
обычных выключателей открытие и закрытие транзистора осуществляются с
помощью электрического тока.
   Существуют различные типы транзисторов. На рис. 5.5 представлен тран-
зистор n-p-n (сокращение относится к внутренней структуре транзистора) и
эквивалентные схемы, иллюстрирующие его работу в режиме коммутации.


           обозначение                             эквивалентные схемы
                  К                            К                         К

       Б                   низкое   Б                 высокое Б
                         напряжение                 напряжение

                 Е                            Е                         Е
                                        разомкнут                 замкнут


                               Рис. 5.5. Транзистор n-p-n

144
   Транзистор n-p-n имеет три вывода: эмиттер Э, база Б и коллектор К. В
режиме коммутации эмиттер и коллектор могут рассматриваться как кон-
такты, замыкающиеся и размыкающиеся с помощью напряжения, поданного
на базу. Отметим, что современные транзисторы позволяют осуществлять до
106 – 109 переключений в секунду. Как и в случае электрических контактов,
рассмотренных выше, использование различных типов транзисторов и их
последовательное или параллельное соединение позволяют реализовать ло-
гические функции НЕ, И, ИЛИ.
   Логические схемы, предназначенные для вычисления часто используе-
   мых логических функций, называются элементарными логическими
   схемами, или логическими элементами.

  Обозначения логических элементов приведены на рис. 5.6.




                НЕТ                  И                    ИЛИ




                И-НЕ              ИЛИ-НЕ             СОВПАДЕНИЕ
                   Рис. 5.6. Обозначения логических элементов

   Известно, что любая логическая функция может быть выражена с помощью
формулы, включающей только элементарные операторы ¯, &, ∨. Следователь-
но, любая логическая функция произвольного количества аргументов
может быть реализована путем соединения логических элементов НЕ,
И, ИЛИ.
   Например, функция
                               y = x1x2 ∨ 2x3
может быть реализована с помощью следующих логических элементов:
   – элемента НЕ для вычисления x2;
   – двух логических элементов И для вычисления конъюнкций x1x2 и 2x;
   – элемента ИЛИ для вычисления дизъюнкции x1x2 ( 2x).
   Схема логической цепи для вычисления рассматриваемой функции пред-
ставлена на рис. 5.7.


  Вопросы и упражнения
  Ê	   Как можно представить двоичные значения 0 и 1?
  Ë	   Как работают нормально разомкнутые и нормально замкнутые контакты?
  Ì	   Какова роль транзистора в современных компьютерах?
  Í	   ЭКСПЕРИМЕНТИРУЙТЕ! Используя оборудование из физической лабо-

                                                                     145
             Рис. 5.7. Логическая схема для реализации функции y = x1x2 ∨    x
                                                                             2 3


       ратории, соберите схемы, изображенные на рис. 5.2, 5.3 и 5.4. Проверьте
       таблицы истинности функций, реализованных данными схемами.
  Î	   Как с помощью контактных схем реализуются функции НЕ, И, ИЛИ?
  Ï	   Какова роль элементов коммутации при реализации логических функций?
  Ð	   Какова роль транзистора в современных компьютерах?
  Ñ	   Запомните обозначения логических элементов. Объясните, как используются
       логические элементы для реализации произвольных логических функций.
  Ò	   ПРОЕКТИРУЙТЕ! Используя элементы НЕ, И, ИЛИ, составьте логические
       схемы для вычисления следующих функций:
  	    a)	 y = x1x2x3;	                    i)	   y = x1x2 ∨ x2x3;
  	    b)	 y = x1 ∨ x2 ∨ x3;	              j)	   y = (x1 ∨ x2) (x2 ∨ x3);	
  	    c)	 y =       x x ;	
                 1 2 3                     k)	 y = x1x2 ∨      x ∨ x3x4;	
                                                              1 3

  	    d)	 y =   1   ∨ x2 ∨ x3;	           l)	   y=    x ∨
                                                      1 2      x ∨ x2x3;	
                                                              1 3

  	    e)	 y = x1x2 ∨ x3x4;	               m)	 y =     x ∨ x1 2;	
                                                      1 2

  	    f)	 y = (x1 ∨ x2) (x3 ∨ x4);	       n)	 y = x1x2 ∨     1 2   ;
  	    g)	 y = x1x2;	                      o)	 y = x1(x2 ∨ x3 ∨ x4);
  	    h)	 y = x1 ∨ x2;	                   p)	 y = x1 ∨ x2x3x4.

  Ó	 ИССЛЕДУЙТЕ! Электромагнитное реле ― это устройство, с помощью кото-
     рого осуществляется замыкание и размыкание электрических контактов.
     Соответствующие контакты включаются электромагнитом. Как можно ис-
     пользовать реле для реализации логических функций НЕ, И, ИЛИ?
  	 ЭКСПЕРИМЕНТИРУЙТЕ! Из деталей школьного физического набора со-
     берите электромагнитное реле и проверьте работу схем, предложенных вами.
   	 ИССЛЕДУЙТЕ! Представляя двоичные значения переменных на выходе
     наличием (значение 1) или отсутствием (значение 0) жидкости, разработайте
     гидравлическую схему для реализации логических функций НЕ, И, ИЛИ. Со-
     берите соответствующие схемы, используя краны и принадлежности школьного
     химического набора. Проверьте таблицы истинности реализованных логиче-
     ских функций.

146
  5.2. Классификация логических схем
   Логические схемы классифицируются на комбинационные и последова-
тельностные.
   В комбинационной схеме значения переменных на выходе определяются
только текущими значениями переменных на входе в соответствии с логиче-
скими функциями схемы.
   В последовательностной схеме значения переменных на выходе зависят
не только от значений входных переменных в текущий момент времени, но и
от последовательности их подачи.
   Другими словами, комбинационные схемы представляют собой логические
устройства без элементов памяти, в то время как последовательностные схемы
содержат элементы двоичной памяти. Следовательно, комбинационная схема
выполняет числовую обработку информации, которую в общем случае можно вы-
разить с помощью логических функций, не содержащих временных параметров.
   Обозначение комбинационных схем приведено на рис. 5.8.




                                                          б)

     Рис. 5.8. Обозначение комбинационных схем: a ― детальное; б ― обобщенное

   Комбинационная схема имеет n входных переменных X = < x1, x2, ..., xn > и
m выходных переменных: Y = < y1, y2, ..., ym >. Соединения, осуществляющие
передачу (на вход или с выхода) значений группы переменных, обозначаются
с помощью двойной линии. В случае необходимости количество переменных
указывается возле наклонной черты, пересекающей двойную линию группы
переменных. Например, на рис. 5.8, б показано, что группа X содержит n пере-
менных, а группа Y ― m переменных.
   С точки зрения теории информации комбинационная схема представляет
собой преобразователь кодов: на вход подаются двоичные слова исходного кода,
а на выходе появляются соответствующие двоичные слова из кода, в который
осуществляется преобразование.
   Например, исходным кодом может быть EBCDIC, а результирующим ко-
дом ― ASCII.



  5.3. Сумматор
   При обработке информации одна из главных задач любого компьютера
состоит в выполнении арифметических операций и в особенности сложения и
вычитания. Устройства, осуществляющие указанные операции, основываются
на схемах, выполняющих сложение и вычитание двух двоичных цифр.

                                                                                147
   Полусумматор ― это комбинационная схема, предназначенная для сло-
жения двух двоичных цифр. Таблица истинности, поясняющая работу полу-
сумматора, основывается на правиле сложения двух двоичных цифр и пред-
ставлена на рис. 5.9. Здесь a и b представляют две суммируемые двоичные
цифры, s ― цифру суммы соответствующего разряда, а t ― цифру переноса в
следующий разряд.
                                    a b       s t
                                    0 0      0 0
                                    0 1      1 0
                                    1 0      1 0
                                    1 1       0 1
                            Рис. 5.9. Таблица истинности
                         для сложения двух двоичных цифр

  Для разработки одной из возможных схем полусумматора выразим функции
выходных переменных s и t:
                               s = b∨ a ;
                                  t = ab.
  Схема, реализующая функции s, t, и используемое обозначение представ-
лены на рис. 5.10.




          Рис. 5.10. Схема полусумматора (1) и используемое обозначение (2)

    Рассмотрим два двоичных числа
                              A = an–1 an–2 ... aj ... a0
и
                              B = bn–1 bn–2 ... bj ... b0,
где aj и bj представляют двоичные цифры разряда j. При суммировании цифр
aj и bj разряда j нужно учитывать и цифру переноса aj –1 из разряда j – 1:

148
  	                                              tj–1
  	                                an–1 an–2 ... aj ... a0
  	                            +
  	                                bn–1 bn–2 ... bj ... b0.
     Таким образом, получаем комбинационную схему, вычисляющую сумму
tj–1 + aj + bj, называемую элементарным сумматором.
     Элементарный сумматор может быть реализован путем каскадного соеди-
нения двух полусумматоров SS1 и SS2 (рис. 5.11).




      Рис. 5.11. Схема элементарного сумматора (1) и используемое обозначение (2)

    Полусумматор SS1 вычисляет сумму (aj + bj), а полусумматор SS2 суммирует
перенос tj–1 с суммой (aj + bj), вычисленной первым полусумматором. Перенос
tj в старший разряд j +1 вычисляется логическим элементом ИЛИ, который
объединяет промежуточные переносы полусумматоров SS1 и SS2.
    Сумма двоичных чисел A и B вычисляется с помощью комбинационной
схемы, называемой сумматором. Сумматор может быть реализован путем
каскадного соединения n элементарных сумматоров (рис. 5.12).
    Элементарный сумматор SM0 , соответствующий самой младшей значащей
цифре, может быть заменен полусумматором, поскольку для нулевого разря-
да перенос из предыдущего разряда отсутствует. Перенос, образующийся на
выходе элементарного сумматора SMn–1 самого старшего значащего разряда,
используется для указания переполнения емкости сумматора на n бит.
    Из анализа рис. 5.10, 5.11 и 5.12 следует, что сложное устройство – сумматор
на n бит ― получен соединением более простых устройств, то есть n элементар-
ных сумматоров. Каждый элементарный сумматор, в свою очередь, получен с
использованием двух полусумматоров и логического элемента ИЛИ.
    Метод разработки сложных устройств (например, сумматора) путем соеди-
нения необходимого числа более простых одинаковых устройств (например,
элементарных сумматоров) называется методом иерархического проек-
тирования. В соответствии с данным методом все компоненты компьютера
принадлежат определенным уровням иерархии, например:
    уровень 1 ― транзисторы;
    уровень 2 ― логические элементы;
    уровень 3 ― полусумматоры, элементарные сумматоры и т. д.;
    уровень 4 ― сумматоры, вычитатели и т. д.;
    уровень 5 ― арифметические устройства, устройства управления и т. д.

                                                                                    149
                            переполнение



           Рис. 5.12. Схема сумматора (1) и используемое обозначение (2)

   Компоненты нижнего иерархического уровня используются в качестве про-
стейших «кубиков» для построения компонентов верхнего уровня.
   Теоретически устройства любого цифрового компьютера могут быть разработаны
и без иерархического метода проектирования. Например, в случае элементарного
сумматора использование полусумматоров не обязательно. Достаточно составить
таблицу истинности элементарного сумматора, представить выходные функции
с помощью формул и использовать соответствующие логические элементы.
   Для компонентов более высокого уровня попытка обойтись без метода
иерархического проектирования делает невозможной разработку сложных
устройств. Например, в случае n-битового сумматора соответствующая таблица
                        2n                           2·16  32     9
истинности состоит из 2 строк. Для n = 16 получаем 2 = 2 ≈ 10 строк. Оче-
видно, что формулы выходных функций сумматора на 16 битов практически
не могут быть записаны. Следовательно, мы вынуждены использовать метод
иерархического проектирования и реализовать сумматор путем соединения
n элементарных сумматоров.

150
   Аналогичным образом, используя метод иерархического проектирования,
можно разработать комбинационные схемы, предназначенные для вычитания
двоичных чисел: полувычитатель, элементарный вычитатель и вычитатель.


  Вопросы и упражнения
  Ê	 Укажите назначение полусумматора; элементарного сумматора; сумматора
     на n битов.
  Ë	 ТВОРИТЕ! Составьте таблицу истинности элементарного сумматора. Таблица
     должна содержать пять столбцов: три для входов aj, bj, tj–1 и два для выходов sj, tj.
  Ì	 Напишите программу, которая моделирует работу элементарного сумматора.
     Двоичные цифры aj, bj и цифра переноса tj–1 от младшего разряда вводятся
     с клавиатуры, а цифра суммы sj и цифра переноса к старшему разряду ― tj
     должны быть выведены на экран.
  Í	 Объясните суть метода иерархического проектирования. Обязательно ли
     применение данного метода? Аргументируйте ваш ответ.
  Î	 Сколько логических элементов НЕ, И, ИЛИ содержит сумматор на 16 битов?
     А на 32 бита?
  Ï	 ПРОЕКТИРУЙТЕ! Полувычитатель ― это комбинационная схема, пред-
     назначенная для вычитания двух двоичных цифр. Соответствующая схема
     имеет входы a, b и выходы d, i. С помощью d обозначена разность a – b, а
     с помощью i ― заем из старшего ближайшего разряда. Составьте таблицу
     истинности и разработайте схему полувычитателя.
  Ð	 ПРОЕКТИРУЙТЕ! Элементарный вычитатель ― это комбинационная
     схема, способная вычислять разность dj и заем ij из ближайшего старшего
     разряда, если на вход подаются уменьшаемое aj, вычитаемое bj и заем ij–1 из
     предыдущего разряда. Используя метод иерархического проектирования,
     разработайте схему элементарного вычитателя.
  Ñ	 ПРОЕКТИРУЙТЕ! Используя метод иерархического проектирования, раз-
     работайте схему вычитателя на n битов.
  Ò	 Сколько логических элементов НЕ, И, ИЛИ содержит вычитатель на 16 битов?
     А на 32 бита?
  Ó	 ПРОАНАЛИЗИРУЙТЕ! Обязательно ли применение метода иерархического
     проектирования при разработке вычитателя на n битов? Аргументируйте
     ваш ответ.



  5.4. Часто используемые комбинационные схемы
   Часто используемые комбинационные схемы представлены на рис. 5.13.
   Сумматор ― это комбинационная схема, предназначенная для сложения
двух двоичных чисел. Таблица истинности и схема сумматора были рассмо-
трены в предыдущем параграфе.
   Компаратор ― это комбинационная схема, которая сравнивает два дво-
ичных числа A и B, указывая на трех выходах одну из возможных ситуаций:
A < B, A > B и A = B.

                                                                                      151
               Рис. 5.13. Часто используемые комбинационные схемы:
            a ― сумматор; b ― компаратор; c ― шифратор; d ― дешифратор;
                       e ― мультиплексор; f ― демультиплексор

   Шифратор ― это комбинационная схема, которая выполняет преобразова-
ние сообщений s1, s2, ..., sn в двоичные слова в соответствующем коде. Каждое
сообщение si представлено значениями x1 = 0, ..., xi = 1, ..., xn = 0, поданными
на вход шифратора, а закодированное (зашифрованное) слово ― с помощью
выходных переменных y1, y2, ..., ym.
   Например, переменные x1, x2, x3, ... могут представлять состояния клавиш
<A>, <B>, <C>, ... клавиатуры. Соответствующий шифратор обеспечит на вы-
ходе слово в коде ASCII для нажатой клавиши.
   Дешифратор ― это комбинационная схема, которая генерирует логический
сигнал 1 на выходе, различном для каждой комбинации входных перемен-
ных. Другими словами, дешифратор осуществляет операцию, обратную той,
которую выполняет шифратор.
   Дешифраторы используются для определения операций, которые должен
выполнять процессор, для определения состояния устройств ввода-вывода,
для синтеза символов и т. п.
   Мультиплексор ― это комбинационная схема, предназначенная для выбора
потока данных. На рис. 5.13, е представлен мультиплексор, который передает на
выход биты двоичного числа A (u = 0) или B (u = 1). В современных компьютерах
мультиплексоры используются для передачи данных от нескольких источников
к одному приемнику.
   Демультиплексор распределяет поток данных с входа X на один из выходов
Y (u = 0) или Z (u = 1). В качестве примера вспомним передачу информации от
одного источника к нескольким приемникам.


  Вопросы и упражнения
  Ê	 Объясните назначение часто используемых комбинационных схем: сумматора,
     компаратора, шифратора, дешифратора, мультиплексора и демультиплексора.
  Ë	 Составьте таблицу истинности компаратора на 2 бита.

152
Ì	 Сколько входов и сколько выходов может быть у шифратора? Сколько входов
   и сколько выходов может быть у дешифратора?
Í	 ТВОРИТЕ! На панели управления принтера установлены кнопки ON LINE
   (работа под управлением центрального устройства), OFF LINE (автономная
   работа), LINE FEED (продвинуть на строку) и FORM FEED (продвинуть на
   страницу). Составьте таблицу истинности шифратора, который вырабатывает
   на выходе следующие двоичные комбинации:
    00 – ON LINE;
    01 – OFF LINE;
    10 – LINE FEED;
    11 – FORM FEED.
Î	 ТВОРИТЕ! На панели управления принтера установлены светодиодные
   индикаторы: READY (готов), PAPER (отсутствие бумаги), TEST (режим
   тестирования) и LOAD (режим загрузки информации). Составьте таблицу
   истинности дешифратора, который управляет светодиодами. Соответствующие
   режимы закодированы с помощью следующих двоичных комбинаций:
    00 – READY;
    01 – PAPER;
    10 – TEST;
    11 – LOAD.
Ï	 ТВОРИТЕ! Клавиатура компьютера содержит функциональные клавиши
   <F1>, <F2>, ..., <F12>. Составьте таблицу истинности шифратора, который
   выдает на выходе двоичное число, соответствующее нажатой клавише.
Ð	 ТВОРИТЕ! Устройства ввода-вывода учебного компьютера имеют следующие
   адреса:
    0000 – клавиатура;	
    0001 – монитор;	
    0010 – механический принтер;
    0011 – струйный принтер;
    0100 – лазерный принтер;
    0101 – дисковод для гибких дисков A;
    0110 – дисковод для гибких дисков B;
    0111 – привод жесткого диска C;
     1000 – привод жесткого диска D.
	  Составьте таблицу истинности дешифратора, который выбирает устройство,
   указываемое соответствующим адресом.
Ñ	 ТВОРИТЕ! Арифметические операции учебного компьютера закодированы
   следующим образом:

                                                                      153
        Сложение	        – 000;
        Вычитание	       – 001;
        Умножение	       – 010;
        Деление	         – 011;
        Сравнение	       – 100.
  	  Составьте таблицу истинности дешифратора арифметических операций
     рассматриваемого компьютера.
  Ò	 ТВОРИТЕ! Составьте таблицу истинности мультиплексора с двумя входными
     линиями.



  5.5. RS-триггер
   Известно, что в последовательностных схемах значения выходных пере-
менных зависят не только от комбинаций входных переменных, но и от по-
следовательности их подачи. Другими словами, последовательностная
схема запоминает информацию о двоичных комбинациях, поданных на входы
схемы в предыдущие моменты времени. Такое возможно благодаря тому, что
последовательностные схемы состоят из комбинационных схем и элементов
двоичной памяти.
  Элемент двоичной памяти ― это схема с двумя различными состо-
  яниями, предназначенная для хранения одного бита информации.
  Соответствующая схема называется триггером.




      Рис. 5.14. Схема асинхронного RS-триггера (a) и используемое обозначение (b)

   На рис. 5.14 представлена схема простейшего триггера, выполненного на
логических элементах ИЛИ-НЕ, называемого асинхронным RS-триггером.
У схемы есть два входа, обозначаемые R и S, и два выхода, обозначаемые
Q и . Заметим, что выходные сигналы Q и        подаются на вторые входы
элементов ИЛИ-НЕ. Соответствующие соединения называются обратными
связями. Именно благодаря этим соединениям данная схема обладает двумя
различными состояниями и, следовательно, обеспечивает запоминание одного
бита информации.

154
   В самом деле, пусть входные сигналы R = S = 0, а выходы Q = 1, = 0. Из-
за обратной связи значение Q = 1 заставляет другой выход принять значение
   = 0. В свою очередь, благодаря обратной связи, значение = 0 подтверждает
выходной сигнал Q = 1. Точно так же в случае, когда выходы Q = 0, = 1, из-за
обратной связи значение = 1 удерживает другой выход в состоянии Q = 0.
Следовательно, входные значения R = S = 0 не изменяют состояние триггера,
обеспечивая хранение ранее записанной двоичной цифры.
   Удобно, чтобы состоянию Q = 1,      = 0 соответствовала двоичная цифра 1,
а состоянию Q = 0, = 1 ― двоичная цифра 0. Выход Q называется прямым,
или истинным выходом, а выход ― инверсным выходом, или выходом
отрицания. Состояние триггера указывается значением прямого выхода Q.
   Рассмотрим случай, когда R = 0, S = 1. Предположим, что триггер находится в
состоянии 0, то есть Q = 0 и = 1. В этом случае значение S = 1 переведет = 0,
который в свою очередь, через обратную связь, обеспечит Q = 1. Следовательно,
триггер переходит в состояние 1 (Q = 1,     = 0). Это состояние, как установлено
ранее, сохранится и после того, как сигнал S изменит свое значение с 1 на 0.
Вход S, который обеспечивает установку триггера в состояние 1, называется
входом установки.
   Аналогично можно установить, что в случае, когда триггер находится в со-
стоянии 1 (Q = 1, = 0), а S = 0, и R = 1, триггер перейдет в состояние 0 (Q = 0,
  = 1). Это состояние сохранится и после перехода сигнала R от значения 1 к
значению 0. Вход R, который обеспечивает установку триггера в состояние 0,
носит название входа сброса.
   Входная комбинация R = 1 и S = 1 заставляет выходы перейти в состояния
Q = 0 и = 0. Значения Q = = 0 не соответствуют условию противоположности
сигналов на выходах. Следовательно, для триггера RS входная комбинация
R = S = 1 является запрещенной.
   Режимы работы рассматриваемого триггера приведены в таблице 5.1.
                                                                   Таблица 5.1
               Режимы работы асинхронного RS-триггера
                   Входы           Режим
                  R     S          работы           Выход Q

                   0     0        хранение       хранимый бит
                   0     1        установка             1
                   1     0           сброс              0
                   1     1        запрещено             –

  Прилагательное асинхронный в названии RS-триггера указывает на
характер влияния управляющих сигналов R и S на состояние триггера.
После изучения схемы, приведенной на рис. 5.14, приходим к выводу, что
управляющие сигналы, поданные на входы R и S, могут изменять состояние
триггера в произвольные моменты времени.
  Последовательностные схемы, состояние которых может быть из-
  менено управляющими сигналами в произвольные моменты времени,
  называются асинхронными схемами.

                                                                            155
   Современный компьютер содержит десятки тысяч триггеров. Изменение их
состояний в произвольные моменты времени трудно контролировать, и это мо-
жет привести к ошибкам в работе. Для исключения ошибок необходимо, чтобы
поведение последовательностных схем контролировалось значениями управ-
ляющих сигналов, подаваемых на входы в точно определенные дискретные
моменты времени. Эти моменты времени задаются с помощью специальных
импульсов, называемых сигналами синхронизации.
  Последовательностные схемы, состояние которых может быть
  изменено управляющими сигналами только в моменты времени,
  определяемые сигналами синхронизации, называются синхронными
  схемами.
  Обычно сигнал синхронизации обозначается с помощью буквы C (от ан-
глийского clock ― «часы») и вырабатывается специальным устройством, на-
зываемым системными часами.




          Рис. 5.15. Схема синхронного RS-триггера (a) и его обозначение (b)

   На рис. 5.15 представлена схема синхронного RS-триггера. Данная схема
состоит из асинхронного RS-триггера (рис. 5.14) и двух логических элементов
И, которые разрешают подачу управляющих сигналов на входы асинхронного
триггера только тогда, когда сигнал синхронизации C принимает значение 1.


  Вопросы и упражнения
  Ê	 Чем отличаются комбинационные и последовательностные схемы?
  Ë	 В чем назначение триггера?
  Ì	 Как работает триггер на основе логических элементов ИЛИ-НЕ? Для чего
     предназначены обратные связи?
  Í	 Объясните режимы работы асинхронного RS-триггера. Почему комбинация
     R = S = 1 не может быть подана на входы рассматриваемого триггера?
  Î	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Чем отличаются асинхронные и
     синхронные последовательностные схемы?
  Ï	 Объясните, как работает синхронный RS-триггер. Каково назначение логи-
     ческих элементов И, входящих в состав данного триггера?

156
  Ð	 На рис. 5.16 представлена схема простейшего триггера, реализованного на
     основе логических элементов И-НЕ, называемого асинхронным        -триг-
     гером.




      Рис. 5.16. Схема асинхронного   -триггера (a) и используемое обозначение (b)

  Схема имеет следующие режимы функционирования:
  	 – хранение ( = 1, = 1);
  	 – установка ( = 1, = 0);
  	 – сброс ( = 0, = 1).
  	 Объясните, как работает рассматриваемый триггер. Почему входная ком-
     бинация = 0, = 0 является запрещенной?
  Ñ	 ТВОРИТЕ! Используя асинхронный        -триггер, разработайте схему син-
     хронного     -триггера.
  Ò	 ПРОЕКТИРУЙТЕ! Используя схемы рис. 5.14а и 5.15а, нарисуйте под-
     робную схему (на уровне логических элементов И, ИЛИ-НЕ) синхронного
     RS-триггера.
  Ó	 ПРОЕКТИРУЙТЕ! Нарисуйте подробную схему (на уровне логических эле-
     ментов И, И-НЕ) синхронного    -триггера.



  5.6. Часто используемые последовательностные схемы
  Регистр (рис. 5.17a) ― это цифровое устройство, предназначенное для вре-
менного хранения произвольного двоичного числа,
                                  D = dn–1 ...d1d0.
   Регистр состоит из триггеров и комбинационных схем, разрешающих за-
пись, чтение или перенос (сдвиг) информации. Запись информации в регистр
осуществляется путем подачи на вход W (от англ. write — «писать») соответ-
ствующего импульса. Так как каждый триггер может запомнить только один
бит, то емкость n регистра определяется числом используемых триггеров.
   В некоторых приложениях (например, при умножении и делении двоичных
чисел, при записи и чтении данных на диске, при передаче данных по теле-
фонным линиям и т. п.) появляется необходимость сдвига влево или вправо
информации, содержащейся в некотором регистре. Для этого используются
сдвигающие регистры (рис. 5.17b,c).
                                                                                     157
            Рис. 5.17. Часто используемые последовательностные схемы:
          a ― регистр; b ― регистр сдвига влево; c ― регистр сдвига вправо;
                       d ― прямой счетчик; e ― обратный счетчик

  Последовательность состояний регистра со сдвигом влево приведена на
рис. 5.18.

                        Моменты
                                           d3 d2 d1 d0
                         времени
                        начальный         0   1   0   1
                            t1            1   0   1   0
                            t2            0   1   0   0
                            t3            1   0   0   0
                            t4            0   0   0   0
                            t5            0   0   0   0
                            ...                 ...
        Рис. 5.18. Последовательность состояний регистра со сдвигом влево


   Предполагается, что начальным состояние регистра является 0101, а им-
пульсы подаются на вход C в момент времени t1, t2, t3 и т. д. Очевидно, что
рассматриваемый регистр вычисляет произведение D × 2.
   Аналогичным образом регистр со сдвигом вправо осуществляет деле-
ние D : 2.
   Счетчик ― это последовательностная схема, которая подсчитывает коли-
чество импульсов, поступивших на ее вход. Счетчики классифицируются по
следующим критериям:
   – способ кодирования информации на выходе (двоичные, двоично-деся-
тичные и т. д.);

158
   – порядок изменения состояний счетчика (прямые, инверсные и реверсив-
ные счетчики).
   В общем случае счетчики создаются путем соединения триггерных схем с
комбинационными схемами, определяющими режим изменения состояния
счетчиков при поступлении на вход каждого нового импульса.
   Двоичный счетчик подсчитывает в двоичной системе счисления коли-
чество импульсов, поступивших на его вход. Емкость двоичного счетчика
зависит от количества входящих в него триггеров. Считая, что двоичным
числам соответствуют различные выходные состояния счетчика, получаем
в результате диапазон счета от 0 до 2 – 1, где n ― это количество триггеров.
                                     n



                       Моменты
                                         d2 d1 d0
                        времени
                       начальный         0   0   0
                           t1            0   0   1
                           t2            0   1   0
                           t3            0   1   1
                           t4            1   0   0
                           t5            1   0   1
                           t6            1   1   0
                           t7            1   1   1
                           t8            0   0   0
                           t9            0   0   1
                           ...               ...
                    Рис. 5.19. Последовательность состояний
                     прямого двоичного счетчика на 3 бита


   Счетчики, изменяющие свое состояние в соответствии с таблицей на рис.
5.19, называются прямыми, поскольку содержимое счетчика увеличивается
на единицу с поступлением на вход «+1» каждого нового импульса. Если же
в счетчик предварительно записываются некоторое число и каждый новый
импульс, поступивший на вход «–1», уменьшает его содержимое на единицу,
то получим инверсный счетчик (рис. 5.17e).



  Вопросы и упражнения
  Ê	 В чем назначение регистра? От чего зависит емкость регистра?
  Ë	 ПРОАНАЛИЗИРУЙТЕ! В регистр со сдвигом влево (рис. 5.17b) загружено
     двоичное число 1001. Каким станет содержимое регистра после подачи на
     вход C одного импульса? Двух импульсов?
  Ì	 В регистр со сдвигом вправо загружено одно из следующих двоичных слов:
  	   a)	 00000;	           d)	 00100;		

                                                                        159
  	   b)	 10000;	          e)	 00010;		

  	   c)	 01000;	          f)	 00001;

  	   g)	 10001;	          i)	 01100;

  	   h)	 01010;	          j)	 00110.

  	  Каким станет содержимое регистра после поступления на вход C двух по-
     следовательных импульсов?
  Í	 ПРОГРАММИРУЙТЕ! Напишите программу, которая моделирует работу
     регистра сдвига слева направо на n битов.
  Î	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Для чего предназначены счетчики?
     Как меняются состояния прямого двоичного счетчика? А состояния инверс-
     ного счетчика?
  Ï	 ПРОАНАЛИЗИРУЙТЕ! Прямой счетчик на 4 бита находится в одном из
     следующих исходных состояний:
  	   a)	 0000;	           f)	 1010;

  	   b)	 0010;	           g)	 1100;

  	   c)	 0100;	           h)	 1111;

  	   d)	 1000;	           i)	 0101;

  	   e)	 1001;	           j)	 0110.
  	  Каким станет состояние счетчика после поступления на вход 5-и импульсов?
     А 8-и импульсов?
  Ð	 ПРОАНАЛИЗИРУЙТЕ! Инверсный счетчик на 4 бита находится в исход-
     ном состоянии 1001. Каким станет состояние счетчика после поступления m
     входных импульсов? Число m может принимать значения 1, 4, 5, 8, 11, 17.
  Ñ	 ПРОГРАММИРУЙТЕ! Напишите на ПАСКАЛЕ программу, которая моде-
     лирует работу прямого двоичного счетчика на n битов.



  5.7. Генераторы импульсов
   Импульсы используются в цифровых устройствах для того, чтобы обеспе-
чить их последовательную работу во времени. Как правило, генераторы им-
пульсов выполняются на основе логических элементов и элементов задержки.
   Элемент задержки представляет собой электронную схему, реализующую
логическую функцию повторения y = x, причем выходной сигнал y повторяет
входной сигнал x с задержкой (опозданием) на ∆ единиц времени.
   Из курса физики известно, что скорость распространения сигналов конеч-
на. Следовательно, любой проводник может рассматриваться как элемент
задержки. Для того чтобы увеличить «инерционность» электронных схем и

160
       Рис. 5.20. Обозначение (а) и временные диаграммы (b) элемента задержки

достичь значительных задержек, в их состав включаются конденсаторы и ре-
зисторы. В этом случае задержка ∆ определяется емкостью и сопротивлением
соответствующих компонентов.
   На рис. 5.20 представлены обозначение и временные диаграммы элемента
задержки.
   Простейшая схема генератора периодических импульсов, реализован-
ного на основе элемента задержки и логического элемента И-НЕ, представлена
на рис. 5.21. В исходном состоянии x = 0 и y = 1, а на выходе элемента задержки




      Рис. 5.21. Схема (a) и обозначение генератора периодических импульсов (b)




        Рис. 5.22. Временные диаграммы генератора периодических импульсов

                                                                                  161
поддерживается значение логической 1. Когда на вход подается сигнал запуска
x = 1, сигнал на выходе принимает значение 0 (рис. 5.22). Затем логическое
значение 0 с задержкой ∆ подается на второй вход логического элемента И-НЕ.
Следовательно, выход принимает значение 1. Уровень логической 1 после за-
держки ∆ вновь будет подан на вход логического элемента И-НЕ, заставляя
тем самым появиться на выходе значение y = 0, и т. д.
   Следовательно, на выходе y генератора вырабатывается последовательность
импульсов длительности ∆. Процесс генерации может быть остановлен путем
подачи на управляющий вход сигнала x = 0.


  Вопросы и упражнения
  Ê	 Для чего предназначен элемент задержки? Нарисуйте временные диаграм-
     мы рассматриваемого элемента.
  Ë	 Объясните, как работает генератор периодических импульсов. От чего за-
     висит длительность импульсов?
  Ì	 ПРОЕКТИРУЙТЕ! Замените логический элемент И-НЕ, входящий в состав
     генератора периодических импульсов, представленного на рис. 5.21, логи-
     ческим элементом ИЛИ-НЕ. Объясните, как будет работать данная схема.
     Нарисуйте временные диаграммы полученного генератора.
  Í	 ИССЛЕДУЙТЕ! Известно, что изменение физических параметров не может
     осуществляться мгновенно. Следовательно, любой логический элемент обла-
     дает задержкой δ, называемой паразитной задержкой, значение которой
     зависит от особенностей соответствующей схемы.
  	 Исключите из схемы, представленной на рис. 5.21, элемент задержки, по-
     давая выходной сигнал логического элемента И-НЕ прямо на его вход. Объ-
     ясните, как будет работать полученная схема. От чего зависит длительность
     импульсов на выходе логического элемента? Нарисуйте соответствующие
     временные диаграммы.
  Î	 ПРОАНАЛИЗИРУЙТЕ! Последовательностная схема состоит из логического
     элемента НЕ, сигнал с выхода которого подается прямо на его вход. Как
     будет работать данная схема?




162
Глава 6
                                         УСТРОЙСТВО
                               И РАБОТА КОМПЬЮТЕРА

  6.1. Функциональная схема компьютера
  Функциональная схема цифрового компьютера представлена на рис. 6.1.

                                               Процессор
                                         Арифметико-
                          Устройство       логическое
                          управления      устройство

                         Команды             Данные
        Данные,
        Команды                                                Результаты
                  Устройство        Память        Устройство
                     ввода                          вывода

                   Рис. 6.1. Функциональная схема компьютера

   В соответствии с данной схемой цифровой компьютер содержит следующие
функциональные блоки:
   – блок памяти, предназначенный для хранения исходных, промежуточных
и конечных данных задачи вместе с командами, указывающими последова-
тельность вычислений;
   – арифметико-логическое устройство, необходимое для выполнения эле-
ментарных арифметических и логических операций;
   – одно или более устройств ввода и соответственно вывода, необходимых
для связи компьютера с внешней средой;
   – центральное устройство управления, которое генерирует последовательно-
сти управляющих сигналов, необходимых для последовательного выполнения
команд.
   Арифметико-логическое устройство (АЛУ) и центральное устройство управ-
ления (ЦУУ) образуют центральное устройство обработки информации,
а проще говоря — процессор.
   Память современных компьютеров организована на двух уровнях: блок
внутренней памяти с высокой скоростью работы и один или более блоков
внешней памяти с низкой скоростью, но с емкостью во много раз большей,
чем у внутренней памяти.
   Внутренняя память (называемая иногда главной, центральной или опе-
ративной памятью) хранит программу и используемые ею данные во время

                                                                            163
выполнения этой программы. Ее наличие является одним из важнейших
условий работы компьютера.
   Внешняя память играет роль хранилища больших объемов информации
и часто используемых программ с возможностью их загрузки во внутреннюю
память за короткий интервал времени. В настоящее время в качестве внешней
памяти используются устройства на магнитных дисках или лентах, устройства
на оптических дисках, флэш-память и т. п.
   Блоки внешней памяти и устройства ввода-вывода называются перифе-
рийным оборудованием.
   Для обеспечения эффективного взаимодействия процессора, внутренней па-
мяти и периферийного оборудования, в случае персональных компьютеров, их
функциональная схема реализуется физически в соответствии с блок-схемой,
представленной на рис. 6.2



                                   Внутренняя
                                     память

                                                      Магистраль



         Арбитр           Контроллер       Контроллер        Контроллер

        Процессор

                         Устройство
                         ввода-вывода
                                            Память на        Память на
                                           гибком диске     жестком диске


                    Рис. 6.2. Блок-схема персонального компьютера

   Из рис. 6.2 видно, что все современные компьютеры имеют модульную
конфигурацию. Каждый модуль (контроллер, принтеры, устройства на
магнитных дисках и т. д.) функционирует независимо и, следовательно,
может включаться или исключаться из состава компьютера независимо от
остальных. Таким образом, конфигурация компьютера может быть изменена
в зависимости от области применения вычислительной системы.
   Например, типовая издательская система содержит несколько видов
принтеров: механический — для черновых текстов, лазерный или цветной
— для макетов страниц, рисунков и фотографий и т. п. Система оператив-
ного управления большим объемом данных должна содержать магнитные
диски большой емкости, а компьютер, предназначенный для видеомонтажа,
должен иметь в комплекте видеокамеры, мониторы с соответствующим раз-
решением, клавиатуры, аналогичные режиссерскому пульту, и т. п.

164
  Вопросы и упражнения
  Ê	 Назовите функциональные блоки компьютера и объясните их назначение.
  Ë	 В чем заключается роль внутренней памяти? Как реализуется внешняя
     память современных компьютеров?
  Ì	 Назовите известные вам периферийные устройства.
  Í	 Назовите компоненты персонального компьютера и объясните их назначение.
  Î	 Расскажите о структуре и взаимодействии компонентов компьютера.
  Ï	 Как может быть изменена конфигурация вычислительной системы? Какие
     преимущества имеет модульная конфигурация компьютера?
  Ð	 ИССЛЕДУЙТЕ! Нарисуйте блок-схему компьютера, на котором вы рабо-
     таете. Какие компоненты для функционирования компьютера являются
     обязательными, а какие — нет?
  Ñ	 ЭКСПЕРИМЕНТИРУЙТЕ! Как можно подключить к компьютеру дополни-
     тельное устройство на магнитных дисках? Лазерный принтер? Считыватель
     документов (сканер)? Видеокамеру?
  	 ИССЛЕДУЙТЕ! Используя поисковую систему, соберите информацию из
     Интернета об эволюции функциональных схем цифровых компьютеров и
     напишите краткое эссе на эту тему. Выделите факторы, которые привели к
     широкому использованию функциональных схем с магистралью.



  6.2. Форматы команд
   Для решения любой задачи компьютер должен знать в каждый момент вре-
мени как операцию, которая должна быть выполнена, так и данные, которые
в ней участвуют. Эти операции сообщаются компьютеру с помощью команд.
  Команда представляет собой последовательность двоичных цифр,
  с помощью которой процессору указывается операция, которую не-
  обходимо выполнить, и расположение операндов.



                   Код            Адрес             Адрес         Адрес
         а)                                       операнда 2
                 операции       операнда 1                     результата


                   Код             Адрес            Адрес
        б)                   операнда 1 и адрес   операнда 2
                 операции       результата


                   Код             Адрес
        в)                       операнда
                 операции


        Рис. 6.3. Формат команды с тремя (a), двумя (б) и одним адресом (в)


                                                                              165
   Соответствующая двоичная последовательность, называемая иногда словом
команды, разделена на поля, каждое из которых имеет строго определенное
назначение. Количество и назначение полей называются форматом команды.
На рис. 6.3 представлены форматы, используемые в современных компьютерах.
   В общем случае для выполнения заданной операции необходимо, чтобы ее
команда содержала три адреса (рис. 6.3a). Первые два адреса используются
для получения операндов, над которыми будет осуществлена операция, ука-
занная в поле Код операции. Результат операции будет помещен по адресу,
указанному в поле Адрес результата.
   Рассмотрим пример. Предположим, что арифметические и логические опе-
рации закодированы так, как указано ниже (для простоты будем использовать
десятичные эквиваленты соответствующих двоичных полей):
   				 01 – сложение;
   				 02 – вычитание;
   				 03 – логическая операция И;
   				 04 – логическая операция ИЛИ.
   				 Команда
      01 100 110 215
сообщает процессору, что необходимо сложить числа из ячеек 100 и 110 и
разместить полученную сумму в ячейку с адресом 215.
   Команда
      02 100 110 215
сообщает процессору, что из числа, записанного в ячейку 100, необходимо
вычесть число, записанное в ячейку 110. Полученный результат будет помещен
в ячейку 215.
   Аналогичным образом, команда
      03 200 300 100
задает логическую операцию И над битами слов из ячеек 200 и 300. Результат
будет размещен в ячейке 100.
   Отметим, что в команде указываются не значения операндов, а адреса яче-
ек, в которых находятся соответствующие данные. Указанное обстоятельство
делает возможным использование одних и тех же программ для обработки
любых исходных данных. Тот факт, что команды работают с адресами, содер-
жимое которых должно быть обработано, а не с самим содержимым, составляет
основной принцип работы цифровых компьютеров. Рассматриваемый принцип
позволяет разрабатывать и вводить в компьютер программы независимо от
конкретных данных, которые будут этой программой обрабатываться.
   В формате с тремя адресами (рис. 6.3a) адреса задаются явно. Для более
компактного представления команд используется неявное задание некоторых
адресов. В этом случае слово команды не содержит полей, предназначенных
для косвенных адресов.
   В частности, если результат, полученный после выполнения любой
операции, помещается по адресу одного из операндов, то в соответствующий

166
формат будут входить только два адреса (рис. 6.3б). Следовательно, адрес
результата задается неявно. Например, команда
      01 100 110
сообщает процессору, что необходимо сложить числа из ячеек 100 и 110 и
поместить полученную сумму в ячейку 100. Очевидно, что после записи суммы
исходное число, находившееся в ячейке 100, будет утеряно.
   Установлено, что формат с двумя адресами (самый распространенный в
настоящее время) обеспечивает написание программ с количеством команд,
сравнимым с количеством команд при использовании большего числа адресов.
   Формат с одним адресом (рис. 6.3в) применяется в компьютерах, процессор
которых содержит специальный регистр, называемый аккумулятором. В
аккумуляторе хранится первый операнд, и в него же помещается результат
выполнения соответствующей операции. Следовательно, адрес первого
операнда и адрес результата задаются неявно. Например, одноадресная
команда
      01 100
сложенное число из аккумулятора с числом, хранящимся в ячейке 100, а
полученная сумма будет помещена в аккумулятор. Естественно, исходное
число из аккумулятора будет утеряно.
   Команды с одним адресом эффективны с точки зрения длины слова и ско-
рости работы компьютера. Однако программа, написанная с использованием
одноадресных команд, будет длиннее, чем программа, написанная с исполь-
зованием двух- или трехадресных команд.
   Отметим, что современные компьютеры имеют команды различных фор-
матов. Формат каждой команды указывается в поле Код операции.


  Вопросы и упражнения
  Ê	 Перечислите форматы команд, применяемых в современных компьютерах.
     Объясните способ неявного задания адресов операндов.
  Ë	 Объясните назначение полей команд с тремя и двумя адресами.
  Ì	 Как определяются адреса операндов и адрес результата в случае одноадрес-
     ных команд?
  Í	 Объясните, как будут выполняться следующие трехадресные команды:
  	    a)	 01 200 201 202;	          c)	 03 100 150 250;
  	    b)	 04 202 201 200;	          d)	 02 250 300 310.
  	  Коды арифметических и логических команд приведены в предыдущем па-
     раграфе.
  Î	 Каким станет содержимое ячейки 100 после выполнения команды
        01 200 300 100,
  	    если в ячейки 200 и 300 записаны числа 17 и 31 соответственно?

                                                                         167
  Ï	 Объясните, как будут выполнены следующие двухадресные команды:
  	   a)	 01 200 201;	            c)	 03 100 150;
  	   b)	 04 202 201;	            d)	 02 250 300.
  Ð	 Каким станет содержимое ячейки 200 после выполнения команды
       01 200 100,
  	 если в ячейки 100 и 200 записаны числа 18 и 32 соответственно?
  Ñ	 Объясните, как будут выполнены следующие одноадресные команды:
  	   a)	 01 100;	                c)	 02 400;			
  	 b)	 03 200;	                 d)	 04 150.
  Ò	 Каким станет содержимое аккумулятора после выполнения команды
       01 100,
  	  если перед выполнением команды в ячейке 100 было записано число 12, а
     в аккумуляторе — число 26?
  Ó	 Назовите преимущества и недостатки форматов команд с тремя, двумя или
     с одним адресом.
   	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Найдите в Интернете информацию
     о типах компьютеров, которые используют трех-, двух- или одноадресный
     формат. Определите области применения, преимущества и недостатки этих
     типов компьютеров.
   	 ИССЛЕДУЙТЕ! Пользуясь любой поисковой системой, соберите информа-
     цию из Интернета об эволюции форматов команд, используемых в цифровых
     компьютерах, и напишите краткое эссе на эту тему. Выделите факторы,
     которые привели к широкому применению форматов, используемых в
     персональных компьютерах.



  6.3. Типы команд
   Команды любого компьютера делятся на четыре группы:
   – команды для обработки данных, которые осуществляют арифметические
и логические операции над данными, определенными с помощью операндов;
   – команды для передачи данных, которые пересылают информацию между
регистрами и/или ячейками без ее изменения;
   – команды перехода, которые в зависимости от результатов проверки неко-
торого условия изменяют последовательность выполнения команд программы;
   – команды ввода-вывода, которые обеспечивают связь компьютера с внеш-
ней средой.
   Команды для обработки данных обрабатывают данные, хранящиеся
во внутренней памяти и регистрах процессора. Наиболее известными среди
команд данной группы являются те, которые выполняют арифметические
операции: сложение, вычитание, умножение и деление.

168
   Логические команды типа И, ИЛИ, НЕ также являются командами для
обработки данных и выполняются над отдельными битами двоичной инфор-
мации. В класс команд для обработки данных включаются также и команды
типа: стирание содержимого некоторой ячейки или определенного регистра,
дополнение содержимого некоторой ячейки, увеличение на единицу (инкремен-
тация) содержимого некоторого регистра и т. п. Наконец, к классу команд для
обработки данных относятся команды сдвига двоичных слов, в которых часть
адреса команды содержит целое число, определяющее количество позиций, на
которое осуществляется сдвиг.
   Команды для передачи данных пересылают информацию между ячейка-
ми внутренней памяти, между регистрами и между ячейками и регистрами без
изменения передаваемой информации. В команде должны быть определены
явным или косвенным образом адрес источника и адрес приемника переда-
ваемой информации. Во время и после переноса информация источника оста-
ется неизменной. Наиболее часто употребляемые команды этой группы ― те,
с помощью которых содержимое произвольных ячеек памяти переносится в
определенный регистр или аккумулятор, а также команда обратного переноса:
из регистра ― в ячейку внутренней памяти.
   Команды перехода используют для изменения порядка выполнения ко-
манд. В обычном режиме команды любой программы анализируются и выпол-
няются последовательно ― точно в том же порядке, в котором они размещены
в памяти. Этот порядок может быть изменен с помощью команд условного и
безусловного перехода.
   Команды условного перехода обеспечивают выбор определенной ветви, по
которой будет продолжено выполнение программы в зависимости от проверя-
емого условия. Использование команд условного перехода дает программисту
возможность принимать логические решения в ходе выполнения программы.
   Команда безусловного перехода содержит адрес команды, на которую будет
осуществлен переход и которая тем самым будет выполнена следующей.
   Команды ввода-вывода обеспечивают связь компьютера с периферийным
оборудованием. Устройства, с которыми будет осуществлена операция ввода-
вывода, задаются в адресной части соответствующей команды. Как правило,
команды этого вида содержат не только информацию о характере обмена (ввод
или вывод), но и дополнительные параметры, необходимые для правильной
работы периферийных устройств. В этих же командах определяются регистры
или ячейки, в которые будут помещены или из которых будут взяты соответ-
ствующие данные.


  Вопросы и упражнения
  Ê	 Как классифицируются команды компьютера? Укажите назначение команд
     каждой группы.
  Ë	 Приведите несколько примеров команд для обработки данных. Дайте оценку
     числа всевозможных команд для обработки данных.
  Ì	 В чем назначение команд передачи данных? Оцените число всевозможных
     команд передачи данных.
  Í	 Когда и как применяют команды перехода? Какие условия проверки могут
     анализироваться этими командами?

                                                                       169
  Î	 Укажите назначение команд ввода-вывода. Какую информацию содержат
     эти команды?
  	 ИССЛЕДУЙТЕ! Узнайте классификацию и состав команд компьютеров, с
     которыми вы работаете.



  6.4. Машинный язык и язык ассемблера
   Для решения любой задачи в память компьютера необходимо загрузить
соответствующую программу и данные, предназначенные для обработки. Ко-
манды программы и обрабатываемые данные записываются во внутреннюю
память в виде последовательностей двоичных цифр, которые центральное
устройство управления может извлекать и исполнять.
  Программы, представленные в виде двоичных последовательностей,
  напрямую исполняемых компьютером, называются программами
  на языке машинных кодов (машинном языке).
   Для пользователя программа в машинных кодах может быть представлена
в виде последовательностей двоичных цифр или, более компактно, ― восьме-
ричных, десятичных или шестнадцатеричных чисел, записываемых в соот-
ветствующих ячейках памяти.
   Разработка программ на языке машинных кодов является утомительной
и неэффективной работой. Для упрощения процесса разработки программ
договорились записывать команды на некотором символическом языке, на-
зываемом языком ассемблера. В данном языке коды операций представ-
ляются группами символов так, чтобы они как можно лучше подсказывали
смысл операции. Эта группа символов длиной, как правило, три известна под
названием мнемоники команды.
   Например, коды команд учебного компьютера из предыдущего параграфа
могут быть обозначены символически в соответствии с таблицей 6.1.
                                                                Таблица 6.1
                           Мнемоника команд

              Код        Мнемоника         Значение команды

              01              ЗАГ       Загрузить аккумулятор
              02              ЗАП       Запомнить аккумулятор
              03              СЛЖ       Сложение
              04              ВЫЧ       Вычитание
              05               БП       Безусловный переход
              06               УП       Условный переход
              07             СТОП       Стоп
   Адреса ячеек внутренней памяти могут быть заданы с помощью символиче-
ских обозначений, выбранных пользователем. Названия должны напоминать
(подсказывать) назначение (смысл) содержимого соответствующих ячеек.
   Например, ячейка 185, в которой хранится число x, может быть обозначена
с помощью X; ячейку 213 для числа y обозначим через Y; ячейку 200, в которую

170
будет помещена сумма x + y, обозначим через S. На языке ассемблера фрагмент
программы для сложения чисел x и y примет форму:
      INC X
      ADU Y
      MEM S.
   В общем случае существует прямое соответствие между записью команд
на языке ассемблера и записью этих же команд на языке машинных кодов,
которое облегчает трансляцию (перевод) программ на языке ассемблера в
программы на языке машинных кодов.
  Трансляция состоит в замене мнемонических команд и символиче-
  ских адресов на соответствующие двоичные последовательности.
  Такая замена осуществляется специальной программой, которую
  называют программой ассемблера, или просто ассемблером.
   Язык машинных кодов и язык ассемблера относят к машинно-зависимым
языкам. Такая зависимость состоит в том, что форматы, коды и мнемоника
команд выражают (передают) внутреннюю структуру компьютера. Программы,
написанные на этих языках, являются самыми короткими и быстрыми, но
сам процесс программирования требует большого объема работы. Упрощение
процесса программирования обеспечивается использованием машинно-неза-
висимых языков (FORTRAN, BASIC, PASCAL, C и т. д.), в которых операции
обработки и типы данных не связаны с внутренним устройством конкретной
модели компьютера. Однако, к сожалению, отрыв пользователя от внутренней
структуры компьютера снижает эффективность соответствующих программ.


  Вопросы и упражнения
  Ê	 В чем отличие между машинным языком и языком ассемблера?
  Ë	 Как представляются коды команд и адреса ячеек на языке ассемблера?
  Ì	 В чем назначение трансляции и как она реализуется для программ,
     написанных на языке ассемблера?
  Í	 ПРОГРАММИРУЙТЕ! Пусть символ X обозначает ячейку 100, символ Y ―
     ячейку 101, а символ S ― ячейку 102. Представьте на языке ассемблера (см.
     табл. 6.1) следующие программы:
  	 a)	   01 100	 b)	 01 100	 c)	 01 101
  		      04 101		 02 100		 04 100
  		      02 102		 03 100		 02 102
  		      02 100	
  	
  	 d)	   01 101	 e)	     01 100	 f )	     01 100
  		      03 101		        02 101		         02 102
  		      03 101		        03 101		         01 101
  		      03 101		        02 100		         02 100		
  		      02 102
  	   Каким будет содержимое ячеек 100, 101 и 102 до и после выполнения каждой
      программы?

                                                                          171
  Î	 Пусть символические обозначения X, Y и S определяют соответственно
     ячейки 100, 200 и 300. Транслируйте (вручную) следующие программы,
     написанные на языке ассемблера:
  	 a)	 ЗАГ X	 b)	 ЗАГ X	 c)	 ЗАГ Y
  		 ВЫЧ Y		 ЗАГ X		 СЛЖ X
  		 ЗАП S		 УП        S		 ЗАП S
  		 ЗАГ Y		 СТОП		 СТОП	
  									
  	 d)	 ЗАГ Y	 e)	 ЗАГ X	 f )	 ЗАГ X
  		 СЛЖ Y		 ЗАП S		 ЗАП S
  		 СЛЖ Y		 ЗАГ Y		 ЗАГ Y
  		 СЛЖ Y		 ЗАП X		 ЗАП X
  		 ЗАП S		 ЗАГ X		 ЗАГ S
  	 Объясните, как будет выполнена каждая из программ.
  Ï	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Чем отличаются машинно-зависимые
     и машинно-независимые языки? Перечислите преимущества и недостатки
     каждого из названных типов языка.
  	 ИССЛЕДУЙТЕ! Пользуясь Интернетом в качестве источника информации,
     сделайте краткое описание машинных кодов и языков ассемблера компью-
     теров, с которыми вы работаете: коды и команды, их классификация.



  6.5. Аппаратные и программные ресурсы
  компьютера
   Общее число команд любого компьютера зависит, в первую очередь, от его
мощности. В случае большой вычислительной системы это число может пре-
высить 1000, в то время как для очень маленьких компьютеров оно не больше
100. Некоторая операция может быть выполнена на одних компьютерах с
помощью единственной команды, в то время как в других компьютерах, для
которых нет такой команды, эта же операция выполняется с помощью неко-
торой последовательности имеющихся в наборе команд.
   Операции, осуществляемые с помощью электронных компонентов ком-
пьютера, известны как аппаратно-реализуемые операции, в то время как
операции, выполняемые с помощью некоторой последовательности команд,
известны как программно-реализуемые операции. Например, операция
извлечения квадратного корня в одном типе компьютеров может быть выпол-
нена с помощью электронных компонентов, а в другом типе компьютеров ― с
помощью подпрограмм. Разделение на аппаратную и программную реализа-
цию зависит от типа компьютера. На рис. 6.4 представлено такое разделение
для компьютера средней мощности.
   Аппаратно-реализуемые операции выполняются с помощью одной команды,
в то время как программно-реализуемые операции требуют большего числа
команд. Следовательно, аппаратно-реализуемые операции выполняются
быстрее, хотя соответствующий компьютер сложнее и, следовательно, дороже.
Напротив, программно-реализуемые операции выполняются медленно, хотя
соответствующие компьютеры проще и, очевидно, дешевле.

172
                           Сложение
                          Вычитание

                           Умножение             Аппаратная
                            Деление              реализация

                     Операции с плавающей
                           запятой

                      Квадратный корень
                                                 Программная
                      Специальные функции        реализация
                     (тригонометрические,
                       экспоненциальные,
                     гиперболические и т. п.

         Рис. 6.4. Разделение между аппаратной и программной реализацией

   Из анализа принципов работы процессора следует, что все устройства лю-
бого компьютера становятся бесполезными в отсутствие программ, которые
управляют ходом выполнения операций, необходимых для решения постав-
ленных задач. Точно так же программы становятся бесполезными при отсут-
ствии соответствующих цифровых устройств. Следовательно, использование
вычислительной техники возможно только при наличии как оборудования,
называемого техническим обеспечением, так и соответствующих программ,
называемых программным обеспечением.
   Техническое обеспечение любой современной вычислительной системы
включает процессор, внутреннюю память, устройства внешней памяти, устройства
ввода-вывода и т. п. Программное обеспечение включает подпрограммы для
выполнения программно-реализуемых операций, программы для доступа к устрой-
ствам ввода-вывода, ассемблеры, редакторы текста, компиляторы алгоритмических
языков и, естественно, программы, разрабатываемые каждым пользователем.
   Отметим, что в специализированной литературе техническое обеспечение
иногда называют английским термином hardware (от англ. «металлические из-
делия»), а программное обеспечение ― термином software (от англ. «мягкие из-
делия»). Соответственно реализация с помощью аппаратных средств называется
реализацией с помощью hardware, а программная реализация ― реализацией
с помощью software.


  Вопросы и упражнения
  Ê	 От чего зависит общее количество команд произвольного компьютера?
  Ë	 Как выполняются операции по обработке данных в случае их аппаратной
     и программной реализации?
  Ì	 ИССЛЕДУЙТЕ! Изучите набор команд компьютера, на котором вы работа-
     ете, и определите метод реализации следующих операций:
  	 – умножение и деление двоичных чисел;
  	 – сложение и вычитание чисел с плавающей запятой;

                                                                           173
  	  – умножение и деление чисел с плавающей запятой;
  	  – извлечение квадратного корня;
  	  – вычисление тригонометрических функций.
  Í	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. В чем преимущества и недостатки
     аппаратной реализации? А программной реализации?
  Î	 ЭКСПЕРИМЕНТИРУЙТЕ! Из чего состоит техническое и программное обе-
     спечение вычислительной системы? Какими ресурсами обладает компьютер,
     на котором вы работаете?



  6.6. Внешняя память на магнитных лентах и дисках
   Принцип работы рассматриваемых видов памяти состоит в регистрации (за-
писи) информации на магнитном слое, находящемся в движении. Магнитный
слой нанесен на нейтральный носитель, как правило, на ленту из гибкого
материала или алюминиевый диск. В качестве магнитного слоя чаще всего
применяется окись железа или тончайшие металлические пленки из кобальт-
никелевого сплава, нанесенные (напыленные) в вакууме.
   Запись и чтение информации осуществляются с помощью магнитной го-
ловки, изображенной на рис. 6.5.

                                     Обмотка

                                                            Магнитный
                                                             сердечник

                                    Магнитная
                                     головка
                                                    Зазор
                 Магнитный слой



          Направление                                         Магнитная
           движения                                             лента

                                                 Носитель
                                                (подложка)

           Рис. 6.5. Магнитная головка для записи и чтения информации

   Головка состоит из сердечника, собранного, как правило, из очень тонких
пластин (0,05 мм) из пермаллоя, и обмотки.
   В ненамагниченном слое магнитные поля частичек окиси железа ориен-
тированы хаотично и взаимно компенсируют друг друга. Чтобы записать
двоичную цифру 0 или 1, через обмотку магнитной головки пропускается
соответствующий импульс тока. Импульс, проходящий по обмотке, создает в
зазоре сильное магнитное поле, которое намагничивает слой, находящийся
в данный момент времени под головкой. Направление намагничивания, а
значит, и записанная двоичная информация зависят от направления тока в

174
обмотке магнитной головки. На рис. 6.6 приведен пример записи двоичной
последовательности 101101 на подвижный магнитный слой.
                         Магнитный слой



                   а)
                                          Носитель




                   б)
                                Направление
                                намагничивания

             Рис. 6.6. Состояние магнитного слоя до записи (a) и после (b)

  Расстояние b определяет длину участка, необходимого для записи одной
двоичной цифры. Его величина зависит от скорости движения носителя, фи-
зических свойств магнитного слоя, от конструкции магнитной головки и т. д.
  Количество элементов двоичной памяти на единицу длины носителя
  называется плотностью записи информации.
   В случае магнитных носителей плотность записи задается величиной 1/b.
Конкретные значения плотности записи меняются в зависимости от устройств
записи и фирмы производителя, находясь в пределах сотен и тысяч битов на
миллиметр длины носителя.
   Во время операции чтения магнитное поле частичек окиси железа, про-
ходя мимо зазора магнитной головки (рис. 6.5), индуцирует в обмотке сигнал
           -3
порядка 10 вольт. Этот сигнал усиливается и преобразуется в стандартный
сигнал, который представляет соответствующую двоичную цифру 0 или 1.
   В большинстве случаев внешняя память на магнитной ленте представляет
собой автономное периферийное устройство, которое передает информацию из/во
внутреннюю память компьютера после приема соответствующих команд от про-
цессора. Устройство памяти на магнитной ленте (рис. 6.7) состоит из механизма
протяжки ленты, устройства записи-чтения и соответствующих схем управления.
   Операция чтения или записи осуществляется во время перемещения ленты.
Между двумя последовательными операциями записи/чтения лента останавливается.
Очевидно, что записанная информация может быть прочитана только в порядке ее
физического размещения на ленте. Вследствие этого устройства на магнитных лентах
называются устройствами внешней памяти с последовательным доступом.
  Время, необходимое для выбора требуемой информации из множества
  данных, записанных на некотором носителе, называется временем
  доступа.
   Время доступа устройства на магнитной ленте зависит от скорости движе-
ния ленты и места размещения читаемой информации: в начале, в конце или
в середине ленты. В случае информации, записанной в конце ленты, время
доступа может достигать нескольких минут.

                                                                             175
                  Подающая                       Принимающая
                  катушка                          катушка

                                   Ленто-
                                 протяжный
                                  механизм




                                 Устройство
                                записи-чтения

                Рис. 6.7. Устройство памяти на магнитной ленте

   Емкость памяти произвольной магнитной ленты зависит от плотности
                                                                8
записи, количества дорожек, длины ленты и составляет порядка 10 байтов.
   Из-за большого времени доступа и относительно малой емкости магнитные
ленты применяют, как правило, только для архивирования информации на
длительные периоды времени, до 50 лет.
   Устройство на магнитных дисках в настоящее время является самым
распространенным типом внешней памяти цифровых компьютеров. Носитель
информации составлен из набора дисков, которые могут быть фиксированны-
ми или съемными. Диски вращаются со скоростью порядка тысячи оборотов в
минуту. Каждый диск покрыт слоем ферромагнитного материала. Для записи
и чтения информации над каждой поверхностью диска установлена отдельная
магнитная головка (рис. 6.8).

                         Магнитные головки
                                                            Диски




                 Устройство
                   доступа




                                    Привод




             Рис. 6.8. Дисковое устройство с подвижными головками

176
   Головки смонтированы на подвижном держателе, управляемом механиз-
мом для точной установки на нужную дорожку. Все головки дискового блока
памяти позиционируются одновременно.
   Время доступа дисковых устройств складывается из времени, необходи-
мого для перемещения набора магнитных головок от текущего к требуемому
цилиндру (рис. 6.8), и из времени, необходимого для того, чтобы соответству-
ющий сектор диска переместился прямо под магнитную головку. На практике
пользуются средним временем доступа, которое для современных дисковых
устройств составляет порядка 10-3 секунд.
   Отметим, что в мощных компьютерах используются дисковые устройства с
неподвижными магнитными головками ― по одной головке на каждую дорож-
ку. Указанные устройства обеспечивают время доступа порядка 10-4 секунды,
однако они дорогостоящие.
   В прошлом для обмена информацией между компьютерами использова-
лись одиночные диски из гибкого материала, которые назывались гибкими
дисками, или дискетами. Дискета помещалась в кассету из пластмассы
или в особый конверт. Физическая организация данных на дискетах была
такая же, как и для пакетов из дисков, однако соответствующие устройства
были значительно проще, а значит, и дешевле. Для того чтобы отличать их от
гибких дисков, внутренние диски персональных компьютеров стали называть
жесткими дисками, hard-дисками или винчестерами (winchester).
   Емкость памяти пакета из магнитных дисков зависит от количества дисков,
количества цилиндров и плотности записи. В настоящее время достигнута
емкость порядка 1012 байтов для одного диска.
   Отметим, что в последние годы вместо жестких дисков стали применять
устройства хранения данных, использующие полупроводниковые запоминающие
устройства, называемые чип-накопителями или твердотельными накопителя-
ми (Solid-State Drive). Твердотельные накопители более устойчивы к механиче-
ским воздействиям и имеют меньшее время доступа. Однако на данный момент
емкость этих накопителей ниже, чем у жестких дисков, а их стоимость выше.

  Вопросы и упражнения
  Ê	   Как представляются двоичные цифры 0 и 1 при магнитной записи?
  Ë	   Для чего предназначена магнитная головка?
  Ì	   От чего зависит плотность магнитной записи информации?
  Í	   Как считывается информация, записанная на магнитном слое?
  Î	   Объясните, как работает устройство памяти на магнитной ленте, изобра-
       женное на рис. 6.7.
  Ï	   ИССЛЕДУЙТЕ! От чего зависит емкость памяти магнитной ленты?
  Ð	   Магнитная лента имеет длину 750 м. Запись информации осуществляется
       на 8 дорожках плюс одна дорожка для бита чётности. Объем записанной
       информации составляет 47 МБ. Определите плотность записи информации
       на магнитной ленте.
  Ñ	   Скорость магнитной ленты равна 2 м/с. На подающей катушке (рис. 6.7)
       имеется 750 м ленты. Определите время доступа к данным, которые нахо-
       дятся в середине ленты.
  Ò	   Как работает устройство на магнитных дисках с подвижными головками?

                                                                        177
  Ó	 Как организована информация на пакете магнитных дисков?
   	 В чем отличие между устройствами внешней памяти с прямым и последова-
     тельным доступом?
   	 От чего зависит время доступа устройств на магнитных дисках?
   	 ТВОРИТЕ! Используя источники информации в Интернете, напишите
     краткое эссе об эволюции дискет.
   	 ЭКСПЕРИМЕНТИРУЙТЕ! Для жесткого диска, с которым вы работаете,
     определите:
  	 – емкость диска;
  	 – среднее время доступа.
   	 ТВОРИТЕ! Используя источники информации в Интернете, напишите
     краткое эссе об эволюции жестких дисков.
   	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Разработайте небольшое исследование,
     в котором осветите преимущества и недостатки жестких дисков и полупроводни-
     ковых запоминающих устройств (SSD). Проанализируйте частоту использования
     этих запоминающих устройств в настольных и портативных персональных
     компьютерах (ноутбуках/лэптопах), продаваемых в нашей стране.



  6.7. Внешняя память на оптических дисках
   Принцип работы устройств памяти на оптических дисках состоит в хране-
нии информации на движущемся отражающем слое. Отражающий слой из
алюминия, золота или серебра нанесен на прозрачную основу из пластмассы.
   В зависимости от режима записи и чтения информации различаем:
   1) Оптические диски только для чтения. Информация на такие диски за-
писывается производителем и не может быть изменена пользователем. Для та-
ких дисков используется английское обозначение CD-ROM (Compact Disc-Read
Only Memory).
   2) Записываемые оптические диски. Информация на такие диски за-
писывается самим пользователем, но только один раз. В дальнейшем таким
диском можно пользоваться многократно только для чтения. Английское обо-
значение таких дисков CD-R (Compact Disc-Recordable).
   3) Перезаписываемые оптические диски. Рассматриваемые диски до-
пускают многократные циклы записи-чтения информации и обозначаются
как CD-RW (Compact Disc-ReWritable).
   Для обеспечения совместимости устройств записи/чтения формат данных
и размеры оптических дисков стандартизованы. На рис. 6.9 представлена
структура оптического диска CD-ROM только для чтения, предназначенного
для широкого круга пользователей.
   На таких дисках записанные двоичные цифры представляют собой по-
следовательность углублений (на английском pit) на одной из поверхностей
диска. Углубления размещены на поверхности с небольшими перерывами, а
их последовательность образует дорожку спиральной формы.
                                                                 –3
   Размеры углублений имеют порядок одного микрона (1 мкм = 10 мм), рас-
стояние между витками спирали 1,6 мкм, длина спирали 5300 м. Диск содер-
                                                              9
жит 20 000 дорожек (витков), на которых находятся около 6 · 10 углублений.
Емкость памяти диска равна 640 Мегабайтам.

178
                                Направление вращения (вид с активной стороны)
                                                         Центральное отверстие
                                 1,6 мкм                 Стартовое кольцо

                                                          20 000 дорожек
        а)                                                6 000 000 000 углублений



                                                          Кольцо останова

                                                          углубления
                                                          (впадины)
                     1,6 мкм                              этикетка
                                                          защитная
        б)                                                пленка
                                                          отражающий
               0,5 мкм                                    слой

                     сторона для чтения                   прозрачная
                                                          пластмасса

                     Рис. 6.9. Структура оптического диска CD-ROM:
             a ― расположение дорожек на диске; б ― вид на диск в разрезе
                               (перпендикулярно дорожкам)

   Чтение оптического диска осуществляется с помощью лазерного луча,
который, отразившись от активной поверхности, попадает на фоточувстви-
тельную ячейку (рис. 6.10).

                         направление       точка
                          движения         фокусировки
                                                            отражающий
                                                            слой


                                                            прозрачный
                                                            слой

                                                   фоточувствительная
                 лазер                             ячейка


                             Рис. 6.10. Чтение оптических дисков


   Проходя вдоль соответствующих дорожек, лазерный луч отражается, когда
свет попадает в точку фокусировки и рассеивается в противном случае.
Другими словами, углубления на рабочей поверхности оптического диска
изменяют (модулируют) интенсивность отраженного пучка. Вследствие этого
на выходе фотоячейки формируется сигнал, который воспроизводит последо-
вательности двоичных цифр 0, 1, записанных на диск на этапе его создания.

                                                                                     179
   В современных устройствах памяти на оптических дисках источник света ―
лазер и фоточувствительная ячейка ― фотодиод выполняются в едином блоке,
именуемом оптической головкой считывания. Угловая скорость диска со-
ставляет 200–600 оборотов в минуту, а линейная скорость ― 1,4 м/с. Несмотря
на очень большие скорости, оптический диск практически не изнашивается,
так как между оптической головкой и диском отсутствует прямой механиче-
ский контакт. Вследствие этого длительность эксплуатации диска CD-ROM
определяется качеством отражающего и защитного слоев. При использовании
алюминия из-за окисления отражающий слой темнеет, ограничивая срок экс-
плуатации такого диска 10–15 годами. При использовании отражающего слоя
из золота только преднамеренные механические воздействия, разрушающие
защитный слой, могут повлиять на качество оптического диска.
   Как правило, оптические диски CD-ROM используются для тиражирования
операционных систем, трансляторов, энциклопедий, электронных игр, а также
другой информации, предназначенной для очень большого числа пользователей.
   Структура CD-R и CD-RW оптических дисков приведена на рис. 6.11.

            отражающий
                   слой

                    слой
              для записи

             прозрачный
                    слой
                                       направление для       зачерненные участки
                                  записи / чтения / стирания



                Рис. 6.11. Структура CD-R и CD-RW оптических дисков

   На рис. 6.11 видим, что рассматриваемые диски содержат особый слой, называ-
емый слоем для записи. В случае CD-R дисков данный слой состоит из специ-
ального органического материала (цианина или фталоцианина), который темнеет
при нагревании. Запись информации осуществляется с помощью мощного лазер-
ного луча, вызывающего потемнение соответствующих участков слоя для записи.
   При чтении затемненные области блокируют прохождение лазерного луча
к отражающему слою, изменяя, таким образом, интенсивность света, попада-
ющего на светочувствительную ячейку (рис. 6.10). Поскольку лазерный луч,
используемый для чтения, является слабым, ранее записанный диск можно
читать многократно без разрушения хранимой на нем информации.
   В случае CD-RW дисков материал слоя для записи подбирается так,
чтобы он вновь становился прозрачным при нагреве до особой температуры,
называемой критической температурой. Очевидно, что после стирания
на перезаписываемый диск можно записывать новые двоичные данные. Со-
временные CD-RW диски выдерживают до 10 000 циклов записи/стирания.
   Общим недостатком записываемых и перезаписываемых оптических дисков
является их повышенная чувствительность к температуре. Продолжительность
их эксплуатации меньше, чем CD-ROM дисков. Такие диски дороже, поскольку
их отражающий слой выполнен из серебра или золота.

180
   Обычно CD-R и CD-RW диски используются для распространения оперативной
информации, предназначенной для определенного круга пользователей ― баз
данных, специализированных пакетов программ, отчетов особо важных симпо-
зиумов, картин со знаменитых выставок, мультимедийных документов и т. п.
   Отметим, что в результате непрерывного развития компьютерных техно-
логий в последние годы широкое распространение получили DVD оптические
диски (Digital Versatile Disc ― Цифровой Многоцелевой Диск). Емкость DVD
диска примерно в семь раз больше, чем емкость CD диска. Позже были раз-
работаны еще более новые диски, такие как HVD (Holographic Versatile Disc
― Многофункциональный Голографический Диск). Емкость такого диска в
тысячи раз больше, чем у компакт-диска.
   В настоящее время в персональных компьютерах общего назначения оп-
тические, а иногда и жесткие диски заменяются флэш-памятью. В этих запо-
минающих устройствах информация хранится с помощью электронных схем,
которые обеспечивают запись, чтение и удаление данных на гораздо более
высоких скоростях.


  Вопросы и упражнения
  Ê	 Как представляются двоичные цифры 0, 1 при оптической записи?
  Ë	 Укажите емкость памяти оптического диска.
  Ì	 Как записывается информация на оптический диск CD-ROM ?
  Í	 От чего зависит емкость памяти оптического диска?
  Î	 Известно, что длина спирали, вдоль которой записывается информация
     оптического диска, равна 5300 м. Емкость памяти диска составляет 640
     Mбайт. Определите плотность записи информации на оптическом диске.
  Ï	 В каких областях применяются CD-ROM диски?
  Ð	 От чего зависит время доступа к информации на оптическом диске?
  Ñ	 Линейная скорость оптического диска составляет 1,4 м/с. Зная плотность записи
     информации d = 128 Кбайтов/м, определите скорость передачи данных
     от дискового устройства к центральному устройству. Напомним, что скорость
     передачи данных измеряется в битах, Кбитах или Мбитах в секунду.
  Ò	 На 20 000 дорожках (витках) оптического диска записано около 640 Mбайтов
     информации. Сколько информации содержит одна дорожка оптического диска?
  Ó 	На одном CD-ROM диске записано в двоичном коде около 74 минут музы-
     ки. Определите, сколько информации содержит одна песня длительностью
     4 минуты 30 секунд. Сколько дорожек занимает соответствующая песня?
   	 Как считывается информация с оптического диска? В чем назначение оп-
     тической головки считывания?
   	 Объясните назначение слоев записываемого оптического диска. Как осу-
     ществляется запись информации на рассматриваемый диск?
   	 От чего зависит длительность эксплуатации CD-ROM диска? Дисков CD-R
     и CD-RW?
   	 Как записывается и стирается информация на перезаписываемом оптиче-
     ском диске?
   	 В каких областях применяют CD-R и CD-RW диски?

                                                                              181
      	 ЭКСПЕРИМЕНТИРУЙТЕ! Найдите технические параметры дисковых оп-
        тических устройств, которые, возможно, были установлены на компьютерах
        в кабинете информатики вашего лицея.
      	 ТВОРИТЕ! Пользуясь источниками информации из Интернета, напишите
        краткое эссе об эволюции оптических дисков.



  6.8. Видеомонитор и клавиатура
   Видеомонитор ― это устройство вывода, с помощью которого информация
отображается на экране.
   В прошлом у первых видеомониторов информация отображалась на экране
электронно-лучевой трубки. Функциональная схема такого видеомонитора
представлена на рис. 6.12.

                                                               Видеосигналы
                           Устройство       Цифро-аналоговый
                           управления        преобразователь
          К центральному
              устройству                                                 Электронно-
                                                                           лучевая
                           Видеопамять       Устройство                    трубка
                                             отклонения


      Рис. 6.12. Функциональная схема видеомонитора с электронно-лучевой трубкой

   Как и в случае обычных телевизоров, изображение на экране электронно-лу-
чевой трубки формируется из точек. Точки светятся под воздействием электрон-
ного луча. Цвет и яркость каждой точки задаются видеосигналами, поданными
на соответствующие входы электронно-лучевой трубки. Обход точек в заранее
установленном порядке, как правило, по строкам слева направо и сверху вниз
осуществляется с помощью устройства отклонения электронного луча.
   Каждой точке на экране соответствует одна ячейка в памяти видеомонитора.
Ячейки видеопамяти содержат информацию относительно цвета и яркости
соответствующих точек на экране электронно-лучевой трубки. Управляющее
устройство читает ячейки видеопамяти в порядке обхода точек на экране. Со-
держимое каждой ячейки интерпретируется как команда, задающая цвет и
яркость соответствующей точки. Видеосигналы, необходимые для управления
электронным лучом, формируются цифро-аналоговыми преобразователями.
   Данные в видеопамяти монитора записываются центральным устройством
компьютера. В любой момент времени компьютер может изменить содержимое
видеопамяти. Как следствие, изменяется и изображение на экране видеомо-
нитора. Изображения можно сделать движущимися путем изменения содер-
жимого видеопамяти с частотой, используемой в кинематографии.
   В общем случае видеомонитор может функционировать в одном из двух
режимов: текстовом или графическом.
   В текстовом режиме экран делится на условные зоны, каждая из которых
называется знакоместом. Как правило, эти зоны образуют 25 строк по 80 сим-
волов в каждой. На каждом знакоместе может быть отображен любой символ из

182
общего набора в 256 символов. Набор символов состоит из прописных и строчных
букв латинского алфавита, десятичных цифр, математических символов, знаков
пунктуации, букв национальных алфавитов и некоторых псевдографических
символов, используемых для вывода на экран таблиц, диаграмм, рамок и т. п.
Каждое знакоместо может иметь отдельные цвета для символа и фона, на котором
он изображен. Это позволяет выводить на экран текст с разноцветными буквами.
   В графическом режиме пользователь может управлять выводом на экран
каждой точки в отдельности. Количество точек по горизонтали и вертикали
определяет разрешение монитора. Например, выражение «разрешение 640×200»
означает, что видеомонитор отображает 640 точек по горизонтали и 200 ― по
вертикали.
   Существует множество международных стандартов, которые регламентируют
разрешение и количество цветов видеомониторов. Эти характеристики являются
общепринятыми и соблюдаются фирмами-производителями.
   Например, в случае персональных компьютеров самые распространенные
стандарты – это EGA, VGA и SVGA. Стандарт EGA устанавливает, что видео-
монитор имеет разрешение 640×350 точек, допуская использование 64 цветов.
   Стандарт VGA, сохраняя совместимость с EGA, предлагает как дополнитель-
ную характеристику разрешение 640×480 точек при 256 различных цветов.
   Для улучшения качества изображения стандарт SVGA дополнен разреше-
нием 1024×768 точек.
   Отметим, что технические достижения последних лет сделали возможной замену
электронно-лучевых трубок на плоские экраны. Плоский экран состоит из матри-
цы (массива) светоизлучающих ячеек, по одной ячейке для каждой из микрозон
цифрового изображения, предоставляемого компьютером. Использование свето-
излучающих ячеек привело к существенному уменьшению габаритов мониторов
и значительному улучшению качества изображений. Такие мониторы характе-
ризуются уменьшенным энергопотреблением и разрешением до 2560×2048 точек.
   Клавиатура ― это устройство ввода, которое преобразует нажатие клавиш
в двоичные слова, воспринимаемые компьютером.
   Электронная часть любой клавиатуры состоит из шифратора. На входы
шифратора подаются логические сигналы, формируемые при нажатии клавиш.
На выходе появляется слово из определенного двоичного кода, стандартного
для каждого семейства компьютеров (ISO, ACSII, UNICOD и т. п.). Некоторые
виды клавиатур снабжаются аудиогенератором, который при нажатии клавиш
издает специфический звук.
   У нас в Молдове, как и в англоязычных странах, самой распространенной
является клавиатура типа (с раскладкой) QWERTY, название которой проис-
ходит от расположения символов Q, W, E, R, T и Y в верхнем ряду алфавитно-
цифровых клавиш. Во франкоговорящих странах используется клавиатура
AZERTY, в Германии ― QWERTZ и т. п.
   Несмотря на то что раскладка клавиш и их количество могут отличаться,
назначение основных клавиш на всех клавиатурах одинаково.
   Клавиши делятся на следующие группы: алфавитно-цифровые, функ-
циональные и специальные. Группа алфавитно-цифровых клавиш включает
клавиши десятичных цифр, клавиши символов английского и русского ал-
фавитов, клавиши математических символов и знаков пунктуации. Группа
функциональных клавиш включает клавиши <F1>, <F2>, ... ,<F12>. Данные

                                                                         183
клавиши не имеют предопределенного назначения и их использование зависит
от программы, выполняемой на компьютере. Специальные клавиши применяют
для управления положением курсора, для ввода в компьютер двоичных слов,
не имеющих отдельных клавиш, и т. п.
   В мощных компьютерах видеомонитор и клавиатура могут образовывать еди-
ное устройство, именуемое консолью. Консоль, применяемая для управления
вычислительной системой, называется монитором.
   В случае планшетных компьютеров и компьютеров, встроенных, напри-
мер в смартфоны, применяют с цифровым управлением в бытовой технике
и др., в качестве устройств ввода-вывода используются сенсорные экраны
(touchscreen), которые позволяют отображать визуальную информацию, а также
вводить команды и данные путем перетаскивания и касания к отображаемым
на них элементам управления.


  Вопросы и упражнения
  Ê	 Объясните, как работает видеомонитор. Назовите назначение основных
     частей видеомонитора.
  Ë	 Как можно изменить изображение, выводимое на экран видеомонитора?
     Как «оживить» изображение на экране?
  Ì	 Чем отличаются режимы работы видеомонитора?
  Í	 Перечислите основные показатели качества видеомонитора.
  Î	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите тип видеомонитора, на котором вы
     работаете. Определите разрешение экрана и количество доступных цветов.
  Ï	 Укажите составные части клавиатуры. Как определить тип клавиатуры?
  Ð	 Назовите группы клавиш и их назначение.
  Ñ	 ИССЛЕДУЙТЕ! Пользуясь информацией из Интернета, проведите сравни-
     тельное исследование видеомониторов с электронно-лучевыми трубками и
     с плоским экраном, выделите как преимущества, так и недостатки каждого
     из них. Укажите области применения каждого типа видеомониторов.
  Ò	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. С помощью поисковой системы най-
     дите в Интернете описания видеомониторов, предлагаемых торговыми пред-
     приятиями. Узнайте, как технические параметры видеомониторов влияют
     на их цену, каковы преимущества, недостатки и области их применения.
  Ó 	ТВОРИТЕ! Используя Интернет в качестве источника информации, на-
     пишите небольшое эссе об эволюции видеомониторов как промышленных,
     так и для персонального пользования.



  6.9. Принтеры
   Принтеры ― это устройства вывода, которые предоставляют результаты
в виде отпечатанного документа. В зависимости от используемого принципа
печати принтеры классифицируются на:
   – механические принтеры, в которых печать осуществляется с помощью
молоточков или иголок;
   – лазерные принтеры, в которых печать осуществляется с использованием

184
электростатических методов, как в копировальных аппаратах;
   – струйные принтеры;
   – термопринтеры, работа которых основывается на применении специаль-
ной бумаги, меняющей цвет при нагревании.
   Принцип работы матричного игольчатого принтера представлен на
рис. 6.13.

                             Цилиндр для продвижения бумаги



                  Печатающая                                  Бумага
                       головка                                Красящая лента



                                 Печатающее устройство


            Рис. 6.13. Принцип работы матричного игольчатого принтера

   Печатающая головка содержит группу тонких металлических иголок, кото-
рые в нужный момент ударяют через красящую ленту по бумаге. Конфигура-
ция ударяющих игл в каждый из моментов времени и продвижение головки
вдоль линии печати определяют печатаемые изображения.
   Матричные принтеры могут работать как в графическом, так и в алфавит-
но-цифровом (текстовом) режиме.
   В графическом режиме компьютер управляет печатью каждой точки в
отдельности. Ясно, что из точек могут быть сформированы любые изображения:
графики, эскизы, а также символы, разработанные пользователем. Печать
информации в графическом режиме является очень медленной из-за большого
количества перемещений печатающей головки и пошаговой подачи бумаги.
   В алфавитно-цифровом режиме компьютер посылает печатающему
устройству только коды печатаемых символов. Каждому коду соответствует
изображение из точек, хранящееся в специальной памяти принтера. Соот-
ветствующие изображения печатаются за один или, самое большее, два-три
прохода печатающей головки.
   Печать в алфавитно-цифровом режиме выполняется быстрее, однако можно
печатать только те символы, изображения которых записаны в памяти прин-
тера. У простых матричных принтеров есть несколько стандартных наборов
символов, записанных в постоянную память. Более производительные матрич-
ные принтеры обеспечивают возможность программной загрузки множества
наборов символов, конфигурация которых задана пользователем.
   Отметим, что чем больше количество игл в печатающей головке, тем выше
качество печати. В настоящее время применяют принтеры с 9 или с 24 игла-
ми. Качество печати можно улучшить с помощью повторной печати (2–4 раза)
одного и того же символа на том же месте. Скорость печати механических
игольчатых принтеров составляет 150–500 символов в минуту.
   Принцип работы лазерных принтеров представлен на рис. 6.14.
   Главным элементом такого принтера является барабан, покрытый полу-

                                                                               185
                                        Лазер

                    Красящий
                     порошок
                                                Устройство
                                                электризации

                                                  Устройство
                                                  очистки
                      Барабан

                                                 Бумага
                                Пресс


                 Рис. 6.14. Принцип действия лазерного принтера

проводящим слоем, который изменяет свои электрические свойства под воз-
действием света.
   При печати текущей страницы сперва электризуется поверхность барабана.
Далее с помощью лазерного луча на заряженную поверхность барабана проеци-
руются точки печатаемого изображения. Поскольку освещенные участки изменя-
ют свою электрическую проводимость, соответствующие заряды нейтрализуются.
Следовательно, на поверхности барабана формируется невидимое электрическое
изображение. Проявление изображения осуществляется с помощью очень мелких
частиц красящего порошка, притягиваемых заряженными участками барабана.
Изображение с барабана переносится на бумагу и закрепляется путем нагрева.
   Далее все электрические заряды с поверхности барабана нейтрализуются,
а остатки порошка удаляются.
   Лазерные принтеры обладают самыми лучшими характеристиками среди
современных принтеров. Тексты и графика, отпечатанные с помощью та-
ких принтеров, не отличаются от типографских. Скорость печати составляет
5–15 страниц в минуту.
   Струйные чернильные принтеры формируют точки печатаемого изобра-
жения из микроскопических капель, наносимых на бумагу через специальные
сопла. Они обеспечивают очень хорошее качество, их применяют для цветной
печати. Данные принтеры дороже, чем механические, и требуют особого техни-
ческого ухода.
   Термопринтеры используют матрицу из игл, селективный кратковремен-
ный нагрев которых осуществляется в зависимости от того, какой символ должен
быть напечатан. Скорость печати у них относительно низка, около 300 строк в
минуту, их основное преимущество состоит в малых габаритах.


  Вопросы и упражнения
  Ê	 Как классифицируются принтеры в зависимости от принципа печати?
  Ë	 Какие узлы входят в состав любого принтера?

186
  Ì	 В чем принцип действия матричного игольчатого принтера? Как работает
     такой принтер?
  Í	 Объясните, как работает лазерный принтер. В чем главное преимущество
     лазерного принтера?
  Î	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите тип принтера, которым пользуетесь
     вы. Найдите технические параметры принтера: набор символов, режимы
     функционирования, емкость буферной памяти, скорость печати.
  Ï	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ! С помощью поисковой системы
     найдите в Интернете описания принтеров, предлагаемых торговыми пред-
     приятиями. Узнайте, как технические параметры принтеров влияют на их
     цену, каковы преимущества, недостатки и области их применения.
  Ð	 ТВОРИТЕ! Используя Интернет в качестве источника информации, на-
     пишите небольшое эссе об эволюции принтеров как промышленных, так и
     для персонального пользования.



  6.10. Классификация компьютеров
   Характеристика любого компьютера включает следующие показатели:
   – скорость выполнения операций;
   – емкость внутренней памяти;
   – состав, емкость и время доступа устройств внешней памяти;
   – состав и соответствующие технические параметры периферийного обо-
рудования;
   – масса и габариты;
   – стоимость.
   В зависимости от этих параметров современные компьютеры делятся на
4 категории:
   – суперкомпьютеры;
   – большие компьютеры;
   – мини-компьютеры;
   – микрокомпьютеры (персональные компьютеры).
                                                    15
   Суперкомпьютеры могут выполнять около 10 (1000 триллионов) опе-
раций в секунду, а их цена превышает 20 миллионов долларов. Исследова-
тельские и конструкторские разработки в области суперкомпьютеров осущест-
вляют в США и Японии фирмами IBM, Gray Research, Fujitsu ETA Systems,
Dell, Sutherland и др. Суперкомпьютеры применяют в чрезвычайно сложных
системах обработки данных в аэронавтике, ядерной физике, астронавтике,
сейсмологии, при прогнозировании погоды и т. п.
   Большие компьютеры (также мэйнфрейм, от анлийского mainframe ―
«основной шкаф») могут выполнять сотни триллионов операций в секунду, их цена
составляет от 20 тысяч до нескольких миллионов долларов. Как правило, большие
компьютеры включают в свой состав десятки устройств на магнитных дисках,
десятки принтеров, сотни консолей, находящихся на различных расстояниях
от центрального устройства. Данные компьютеры используются в больших
вычислительных центрах и работают в круглосуточном режиме. Главные фирмы-
производители больших компьютеров ― IBM, Hitachi, Amdahl, Fujitsu и др.

                                                                         187
   Мини-компьютеры выполняли десятки и сотни миллионов операций в
секунду, а их цена не превышала 200–300 тысяч долларов. Периферийное
оборудование одного мини-компьютера включало в себя несколько магнит-
ных дисков, один или два принтера, множество консолей. Мини-компьютеры
были более простыми в обращении, чем большие компьютеры. Их применяли
в системах автоматизированного проектирования, в промышленной автома-
тике, для обработки данных в научных экспериментах и т. п. Среди фирм,
которые производили мини-компьютеры, отметим такие, как IBM, Wang, Texas
Instruments, Data General, DEC, Hewlett-Packard и т. п. В настоящее время
мини-компьютеры полностью вытеснены персональными компьютерами.
   Микрокомпьютеры, называемые также персональными компьютера-
ми, продают по относительно низким ценам ― между 100 и 15 000 долларов и
обеспечивают скорость вычислений порядка миллиарда операций в секунду.
Блок-схема персонального компьютера представлена на рис. 6.2 (с. 164).
   Как правило, периферийное оборудование персонального компьютера вклю-
чает в себя одно или несколько устройств на жестком диске или SSD (Solid-
State Drive), устройство на оптических дисках, принтер и консоль. Модульная
конструкция и группирование всего оборудования вокруг одной магистрали для
передачи данных обеспечивают возможность реконфигурации микрокомпью-
тера в зависимости от индивидуальных потребностей каждого пользователя.
   Для этого микрокомпьютеры имеют несколько портов USB (Universal Serial
Bus ― универсальная последовательная шина), которые позволяют подключать
различные дополнительные периферийные устройства, включая флэш-память.
Также персональные компьютеры, предназначенные для размещения на столе
(desktop), портативные компьютеры (называемые ноутбуками или лэптопа-
ми) и планшетные компьютеры оснащены периферийными устройствами,
обеспечивающими связь с другими цифровыми техническими системами через
радиоволны (Wi-Fi, Bluetooth) или инфракрасные лучи.
   Корпорации, производящие микрокомпьютеры, находятся в очень многих
странах. Современные всемирно признанные лидеры ― это фирмы Lenovo,
Apple, Hewlett-Packard, Dell, Asus, Acer, Samsung и др.


  Вопросы и упражнения
  Ê	 ЭКСПЕРИМЕНТИРУЙТЕ! Назовите основные параметры, характеризу-
     ющие современный компьютер. Определите технические и экономические
     параметры компьютера, на котором вы работаете.
  Ë	 Как классифицируются компьютеры в зависимости от их технических и
     экономических параметров?
  Ì	 ТВОРИТЕ! На основе информации из Интернета, дайте краткую харак-
     теристику каждой категории компьютеров: суперкомпьютеров, больших
     компьютеров, мини-компьютеров и микрокомпьютеров. Выделите области
     использования компьютеров из каждой категории.
  Í	 ИССЛЕДУЙТЕ! Используя один из поисковых серверов, найдите в Интер-
     нете подробную информацию об основных производителях персональных
     компьютеров. Составьте рейтинг этих производителей в соответствии с их
     долевым участием на рынке.

188
  	 ПРОАНАЛИЗИРУЙТЕ! Определите процент прибыли крупных компаний,
     производящих компьютеры, по категориям (суперкомпьютеры, большие
     компьютеры, макрокомпьютеры, мини-компьютеры, микрокомпьютеры), и
     проведите небольшое исследование, которое отразит эволюцию этого важного
     сектора мировой экономики.
  	 ИССЛЕДУЙТЕ! Используя данные, опубликованные Национальным стати-
     стическим бюро и Национальным агентством по регулированию в области
     электронных коммуникаций и информационных технологий (ANRCETI),
     проведите небольшое исследование о производстве и продаже компьютеров
     в нашей стране.
  	 ИССЛЕДУЙТЕ! Международная группа ИТ-специалистов реализует так
     называемый проект «Топ 500». Этот проект, запущенный в 1993 году, дважды
     в год публикует список 500 самых мощных суперкомпьютеров. Проведите
     небольшое исследование первых десяти суперкомпьютеров, выделяя тех-
     нические параметры, их назначение, компании, которые их производят,
     а также роль международного сотрудничества в развитии информатики и
     информационных технологий.




  6.11. Микропроцессор
   Микропроцессор ― это интегральная схема, которая выполняет функции
центрального устройства обработки информации ― выборки и исполнения команд.
   Как правило, микропроцессор содержит арифметическое и управляющее
устройства, группу регистров, предназначенных для временного хранения
часто используемых данных, магистрали и соответствующие схемы управления
(рис. 6.15).


                Центральное      Арифметическо-        Регистры
                устройство          логическое          общего
                 управления        устройство         назначения



                                                    Внутренная магистраль

                          Схема управления магисталью



                        Данные       Адреса       Команды


                Рис. 6.15. Функциональная схема микропроцессора

  Микропроцессор взаимодействует с устройствами памяти и периферийны-
ми устройствами с помощью трех магистралей: Данные, Адреса и Команды.

                                                                            189
Поток информации через магистрали контролируется Схемой управления
магистралью.
   Выборка и выполнение команд происходят под управлением центрального
устройства управления. Для этого с помощью магистрали адреса указы-
вается адрес ячейки внутренней памяти, а с помощью магистрали команд
передаются сигналы для записи или чтения. Данные для чтения или записи
передаются по магистрали данных.
   Микропроцессоры характеризуются следующими параметрами:
   – длина слова;
   – частота системных часов;
   – емкость магистралей.
   Длина слова представляет количество битов двоичной последовательно-
сти, которая может быть записана в регистрах и обработана арифметическим
устройством микропроцессора. Большинство микропроцессоров имеют длину
слова 32, 64 и более бита.
   Частота системных часов представляет собой количество импульсов в
секунду, вырабатываемых генератором тактовых импульсов, входящим в состав
центрального устройства управления. Частота системных часов измеряется в
                         6
Мегагерцах (1 MГц = 10 Гц). Поскольку тактовые импульсы синхронизируют
выполнение микроопераций во всех устройствах микропроцессора, частота
системных часов характеризует быстроту микропроцессора.
   Емкость магистрали представляет собой количество разрядов двоичных слов,
передаваемых по магистрали. Желательно, чтобы емкость магистрали данных
была равна или больше длины слова микропроцессора. В противном случае
для того, чтобы передать одно слово, необходимо несколько циклов магистрали
данных.
   Емкость магистрали адреса определяет пространство адресов, которое
напрямую доступно микропроцессору. Так, микропроцессор с емкостью ма-
гистрали адреса в 16 бит имеет доступ к 216 ячейкам внутренней памяти, а
микропроцессор с емкостью магистрали адресов в 32 бита может адресовать
             32
напрямую 2 ячеек.
   Длина слова, частота системных часов и емкость магистралей определяют
производительность микропроцессора, которая измеряется в Mips ― мил-
лионов команд в секунду. Для примера в таблице 6.2 представлены главные
характеристики микропроцессоров из семейства Intel.
                                                                Таблица 6.2
                            Главные характеристики
                       микропроцессоров из семейства Intel
                              Длина       Частота,   Производительность,
  Микропроцессор
                            слова, бит     МГц              Mips
4040 (1974)                      4          0,7                  0,06
8085 (1976)                      8            5                  1,25
80286 (1982)                    16           16                     8
Pentium 4 (2004)                32         3800                 2500
Pentium D (2005)                64         3400                 4000
Intel Core i9 (2017)            64         4500                 5500

190
   Из приведенной таблицы видно, что за 1974–2017 годы длина слов, с кото-
рыми работает микропроцессор, увеличилась в 8 раз, частота системных часов
примерно в 6 500 раз, а их производительность примерно в 9 200 раз. Произ-
водительность современного микропроцессора примерно в 6 000 раз больше,
чем компьютера Лунного Модуля Apollo, с которым в 1969 году первые люди
Земли высадились на Луну.
   Тип микропроцессора и частоту системных часов персонального компьютера,
с которым вы работаете, можно узнать с помощью контекстного меню пикто-
граммы „My computer”. Напоминаем, что контекстное меню выводится на экран
с помощью щелчка правой кнопкой мыши по соответствующей пиктограмме.


  Вопросы и упражнения
  Ê	 Объясните назначение устройств, входящих в состав микропроцессора
     (рис. 6.15).
  Ë	 Назовите главные параметры микропроцессора. Объясните смысл каждого
     параметра.
  Ì	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите тип и главные параметры микро-
     процессора из состава компьютера, на котором вы работаете.
  Í	 ИССЛЕДУЙТЕ! Помимо Intel, в современных компьютерах используют
     микропроцессоры других компаний. Анализируя информацию о персональ-
     ных компьютерах, продаваемых в нашей стране, выявите производителей,
     входящих в их состав микропроцессоров. Обратите внимание на то, как
     цена персональных компьютеров варьирует в зависимости от используемых
     микропроцессоров.
  Î	 ТВОРИТЕ! Разработайте небольшое исследование микропроцессоров для
     настольных ПК, ноутбуков, планшетов и для смартфонов, широко исполь-
     зуемых в нашей стране.
  Ï	 ИССЛЕДУЙТЕ! Сформулированный в 1965 году «закон» Мура, основателя
     Intel, описывает долгосрочную тенденцию в истории компьютеров: коли-
     чество транзисторов, которые можно разместить на интегральной схеме,
     удваивается примерно каждые два года. Эта тенденция продолжается более
     полувека. Анализируя данные о количестве транзисторов в интегральных
     схемах, опубликованные в Интернете, выясните, правильно ли этот «закон»
     описывает эволюцию микропроцессоров в последние годы.




                                                                        191
Глава 7
                                 КОМПЬЮТЕРНЫЕ СЕТИ

  7.1. Введение в компьютерные сети
   Одновременно с расширением области использования компьютеров вы-
росло и количество пользователей, желающих иметь доступ к средствам для
эффективной обработки и хранения совместно используемой информации.
   Например, при проектировании нового здания большое число специали-
стов ― архитектор, инженер, пожарный и др. ― хотят одновременно получать
доступ и вносить, если необходимо, изменения в строительные чертежи, на-
ходящиеся в процессе разработки. Авиакомпании могут продавать билеты на
один и тот же рейс в агентствах, находящихся в разных городах.
   Простейшее решение данной задачи состоит в подключении к центральному
компьютеру большой мощности множества терминалов (рис. 7.1).

                            Центральный компьютер




                                   Терминалы

               Рис. 7.1. Централизованная вычислительная система


   Как правило, терминал состоит из монитора, клавиатуры и, если необхо-
димо, принтера. Главным недостатком централизованной системы обработки
данных является низкая надежность и неэффективное использование вычис-
лительных ресурсов.
   Со временем появилась тенденция к переходу от централизованных си-
стем к размещению компьютеров у каждого пользователя и обеспечению их
эффективного взаимодействия с помощью специальных соединений (рис. 7.2).

  Компьютерной сетью называется множество компьютеров, которые
  могут обмениваться информацией с помощью системы связи.

  Компьютеры любой сети подключаются к системе связи с помощью специально
предназначенных блоков ввода-вывода, называемых сетевыми адаптерами.

192
                               Компьютеры




                                 Система
                                  связи




                         Рис. 7.2. Компьютерная сеть

Естественно, что в пределах одной определенной сети каждый компьютер, точ-
нее каждый сетевой адаптер, имеет уникальный адрес, называемый сетевым
адресом.
   Например, компьютерная сеть может быть построена с использованием в
качестве системы связи существующей телефонной сети. В таком случае сетевой
адаптер включает в себя модулятор для преобразования цифровых сигналов
компьютера в телефонные сигналы и демодулятор для обратного преобразования.
Соответствующее устройство ввода-вывода носит название модем (модулятор-
демодулятор). Сетевой адрес задается номером телефона, к которому подключен
модем.
   Главным образом система связи состоит из линий передачи сигналов.
Этими линиями могут быть:
   – кабели на основе витых проводов («витая пара»);
   – коаксиальные кабели;
   – оптические кабели;
   – микроволновые радиоканалы (наземные и спутниковые).
   Кабели на основе витых пар аналогичны телефонным и обеспечива-
ют скорость передачи до 1 Mбит/с. Коаксиальные кабели похожи на те,
которые применяют в телевизионных кабельных сетях. Они обеспечивают
скорость передачи до 1 Гбит/с. Оптический кабель состоит из стеклянного
или прозрачного пластмассового волокна, покрытого защитной оболочкой.
Оптический сигнал от лазера-источника распространяется по волокну и при-
нимается фоточувствительной ячейкой. Скорость передачи информации по
оптическому кабелю может достигать 1 Tбит/с.
   Микроволновые радиоканалы состоят из ретрансляционных станций,
которые обеспечивают прием и передачу сигналов на сантиметровых волнах.
На Земле приемопередающие станции расположены в радиусе прямой види-
мости антенн, на расстоянии 40–50 км друг от друга. В случае космических
линий связи соответствующие станции размещены на спутниках. Скорость
передачи микроволновых радиоканалов составляет около 10 Гбит/с.
   В зависимости от площади охвата различают следующие типы сетей:
   – локальные сети;
   – региональные сети;
   – глобальные сети.

                                                                       193
   В локальных сетях компьютеры охватывают незначительную по площади
зону (диаметром до 2 км) и обслуживают одну организацию. Как правило,
локальные сети состоят из компьютеров, находящихся в пределах одного или
нескольких зданий. Обычно линии передачи обеспечивают в данном случае
кабели на основе витой пары или коаксиальные кабели.
   В последние годы для маленьких и очень маленьких локальных сетей все
большее распространение получили средства, обеспечивающие связь цифрового
оборудования с помощью радиоволн (Wi-Fi, Bluetooth) или инфракрасных лучей.
   Региональные сети покрывают площадь одного города или района. Линии
связи реализуются на основе коаксиальных кабелей или маленьких приемо-
передающих станций, называемых радиомодемами.
   Глобальные сети охватывают территории стран и континентов. В каче-
стве линий передачи служат оптические или микроволновые радиоканалы
(наземные и спутниковые).
   Главное преимущество сетей состоит в возможности обмениваться или,
другими словами, совместном использовании данных, программ и ком-
пьютеров каждой сети.
   Например, локальные сети позволяют совместно пользоваться файлами,
дисками, принтерами, сканерами, другим периферийным оборудованием.
Возможность одновременного доступа нескольким пользователям к устрой-
ствам и оборудованию повышает эффективность его использования. Таким
образом, сотрудники одной организации могут работать совместно над
общими проектами: годовым бюджетом, планом продаж, обновлением баз
данных и т. п.
   Говоря о глобальных сетях, коллективы исследователей могут осуществлять
сложные расчеты на уникальном суперкомпьютере или совместно анализиро-
вать результаты особо дорогостоящих научных экспериментов. На основе суще-
ствующих сетей создаются различные службы: передача файлов, электронная
почта, передача новостей, группы общения по интересам, электронные игры,
реклама, денежные переводы, банковские операции и др.


  Вопросы и упражнения
  Ê	 Назовите причины, которые привели к появлению компьютерных сетей.
  Ë 	Укажите недостатки централизованных вычислительных сетей.
  Ì	 Назовите главные компоненты компьютерной сети.
  Í	 Объясните назначение системы связи из состава компьютерной сети.
  Î	 Какие функции выполняет сетевой адаптер? Как идентифицируются компью-
     теры, входящие в состав сети? Определите тип сетевого адаптера, с которым
     вы работаете.
  Ï	 Из чего состоит система связи?
  Ð	 Для чего предназначен модем? Для чего предназначен радиомодем?
  Ñ	 Назовите скорость передачи данных по следующим линиям связи:
  	 – кабель на основе витой пары;
  	 – коаксиальный кабель;
  	 – оптический кабель;
  	 – микроволновой радиоканал.

194
  Ò	 Оцените время передачи одного видеофильма (≈800 Гбит) по известным
      вам линиям связи.
  Ó	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите тип линий связи компьютерной
      сети, в которой вы работаете.
    	 Как классифицируются компьютерные сети в зависимости от площади охвата?
    	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите тип компьютерной сети (локальная,
      региональная или глобальная), в которой вы работаете.
    	 В чем преимущества компьютерных сетей? Какие услуги предлагает ком-
      пьютерная сеть?
    	 ИССЛЕДУЙТЕ! Узнайте скорость передачи для следующих коммуникаци-
      онных средств компьютерных сетей:
  –	 Wi-Fi;
  –	 Bluetooth;
  –	 с инфракрасными лучами.



  7.2. Технологии взаимодействия
  в компьютерной сети
   Ресурсами компьютерной сети являются: периферийное оборудование, линии
связи, сами компьютеры, файлы, базы данных, исполняемые программы и т. п.
Эффективное использование перечисленных ресурсов предполагает совместную
работу или, другими словами, кооперацию компьютеров и программ, которые
на них выполняют.
  Технологией взаимодействия называется способ совместной работы
  компьютеров и программ в сети.
   Наиболее часто в компьютерных сетях используется технология клиент-
сервер и равный-с-равным.
   В технологии клиент-сервер общим ресурсом (например, цветным прин-
тером или диском большой емкости) управляет специально выделенный
компьютер ― сервер. Компьютер, цель которого получить доступ к данным
ресурсам, называется клиентом. Для использования соответствующего ресурса
клиент посылает серверу запрос. Сервер анализирует принятые запросы и, в
зависимости от статуса каждого клиента, принимает или отвергает их (рис. 7.3).
                                     запрос


                           Клиент             Сервер


                                    ответ

                         Рис. 7.3. Модель клиент-сервер

   Ясно, что компьютер, который управляет общими файлами, будет назы-
ваться сервером файлов, или файл-сервером, а компьютер, управляющий
принтерами, ― сервером печати.
   Компьютер, который управляет линиями связи, другими общими ресурсами
и, возможно, обеспечивает доступ к внешним сетям, называется сервером

                                                                          195
сети. Как правило, именно на этом компьютере работает сетевая операцион-
ная система. Остальные компьютеры сети имеют более скромные параметры
и называются рабочими станциями.
   Главными преимуществами технологии клиент-сервер являются:
   – эффективное использование дорогого оборудования;
   – рациональное распределение работы (заданий) между компьютерами в
зависимости от их мощности;
   – надежная защита особо важных данных, которые хранятся только на сервере.
   К сожалению, технология клиент-сервер сложна и требует мощных компью-
теров. Эти факторы можно отнести к основным недостаткам данной технологии.
   В технологии равный-с-равным функции всех компьютеров в сети иден-
тичны.
   Каждый компьютер в сети работает одновременно и как сервер, и как ра-
бочая станция, предоставляя в общее распоряжение ресурсы, которыми рас-
полагает: часть файлов на жестком диске, устройство на оптическом диске,
принтер и т. п. Как более простая, данная технология применяется в малых
локальных сетях. Для больших сетей технология равный-с-равным не обе-
спечивает надежной защиты данных.
   Аналогичным образом технология клиент-сервер применяется и для орга-
низации совместной работы двух и более программ.
  Программа, предоставляющая во время своего выполнения определен-
  ные услуги, называется программой-сервером, а программы, которые
  обращаются к этим услугам, называются программами-клиентами.
   Например, программа-сервер, которая управляет базой данных, выполняет
следующие функции:
   – обеспечивает защиту и безопасность данных;
   – принимает и, если клиент получил соответствующую авторизацию, вы-
полняет запросы на модификацию (изменение) данных;
   – принимает запросы на чтение данных и в зависимости от статуса клиента
разрешает или запрещает доступ к соответствующим данным;
   – ведет журнал, в который заносит все операции, осуществляемые над
базой данных.
   Программа-клиент обеспечивает взаимодействие пользователя с базой
данных и выполняет следующие функции:
   – предлагает пользователю простой и удобный интерфейс;
   – проверяет и редактирует данные, вводимые пользователем;
   – направляет запросы программе-серверу;
   – выводит информацию, извлеченную из базы данных.
   Программы-серверы и программы-клиенты могут выполняться на одном
и том же или на разных компьютерах. В последнем случае обработка данных
является распределенной. Передача данных между программой-клиентом
и программой-сервером осуществляется с помощью системы связи (рис. 7.2).
Компьютер, на котором выполняется программа-сервер, называется хостом (от
англ. host ― хозяин).
   Обычно в локальных сетях программа-клиент выполняется на рабочих
станциях, а программа-сервер ― на сетевом сервере. В случае региональных
или глобальных сетей на каждом мощном компьютере выполняется несколько
программ-серверов, которые предлагают разнообразные услуги программам-
клиентам, выполняющимся на других компьютерах.

196
  Вопросы и упражнения
  Ê	 Объясните термин технологии взаимодействия в сети. Какие технологии
     взаимодействия в сети вы знаете?
  Ë	 Как организована работа компьютеров в сети в случае технологии клиент-
     сервер?
  Ì	 Каковы основные преимущества и недостатки технологии клиент-сервер?
  Í	 Объясните назначение сетевого сервера, файл-сервера, сервера печати и
     рабочей станции.
  Î	 Как организована работа компьютеров в сети в случае технологии равный-
     с-равным? Каковы преимущества и недостатки данной технологии?
  Ï	 Определите технологию взаимодействия, реализованную в вашей сети. Есть
     ли в вашей сети файловый сервер и/или сервер печати?
  Ð	 Существует ли в сети, с которой вы работаете, сетевой сервер? Обоснуйте
     ваш ответ.
  Ñ	 Реализована ли в вашей сети технология равный-с-равным? Обоснуйте ваш
     ответ.
  Ò	 Как взаимодействуют программы в случае технологии клиент-сервер?
  Ó	 Назовите функции программы-сервера и программы-клиента.
   	 Объясните термин хост.
   	 ИССЛЕДУЙТЕ! Компания открыла в разных городах страны агентства по
     продаже авиабилетов. Данные обо всех авиарейсах и о наличии свободных
     мест хранятся в компьютере, расположенном в центральном офисе компании.
  	 Какие сетевые технологии могут обеспечить эффективную работу агентств
     по продаже авиабилетов? Необходимы ли в данном случае программы-
     серверы и программы-клиенты? Какие функции будут выполнять данные
     программы?
   	 ПРОАНАЛИЗИРУЙТЕ! Коллективные электронные игры возможны при
     совместной работе 5–10 компьютеров, объединенных в сеть. В такой игре
     каждый играет против всех. Соответствующие компьютеры предлагают для
     общего пользования раздел на жестком диске.
  	 Какая сетевая технология обеспечивает совместную работу компьютеров?
   	 ПРОЕКТИРУЙТЕ! Разработайте технологию сетевого взаимодействия для
     компьютеров:
  	 a) 	складов фирмы;
  	 б) 	выставочных залов музея;
  	 в) 	читальных залов библиотеки;
  	 г) 	кассовых аппаратов магазинов, принимающих банковские карточки;
  	 д) 	системы выдачи наличных через банкоматы;
  	 е) 	 системы оперативной проверки регистрационных номеров автомобилей
         (каждая бригада полиции оснащена микрокомпьютером с радиомодемом);
  	 ж) лаборатории (класса) по информатике.



  7.3. Топология и архитектура компьютерных сетей
   Система связи любой компьютерной сети (рис. 7.2) обеспечивает передачу
данных между компьютерами. Обычно передаваемые данные группируются
в пакеты.

                                                                        197
   Каждый пакет данных содержит следующую информацию:
   – адрес получателя;
   – собственно данные;
   – управляющую информацию;
   – адрес отправителя.
   Заметим, что пакет данных можно представить себе как обычный конверт,
который пересылается с помощью традиционной почтовой службы. Путь, ко-
торый проходит пакет, зависит от топологии сети.
  Геометрическая конфигурация связей между компьютерами назы-
  вается топологией сети.




            а)                                б)




            в)                                г)




                               Рис. 7.4. Топологии сетей:
             a ― звезда; б ― кольцо; в ― магистраль; г ― распределенная

   В топологии типа звезда связь между двумя компьютерами Ci, Cj обеспе-
чивается через центральный компьютер C1. По этой причине компьютер C1,
называемый главным компьютером, играет важную роль в работе сети,
осуществляя диспетчеризацию пакетов данных. Ясно, что выход из строя
главного компьютера прерывает работу всей сети. Следовательно, главный
компьютер должен быть очень надежным.
   В топологии типа кольцо соединения между компьютерами образуют
замкнутую цепочку. Пакет, посланный компьютером Ci, принимается ком-
пьютером Ci+1, который в свою очередь отсылает его компьютеру Ci+2 и т. п.,
пока пакет не достигнет компьютера-приемника Cj. Поскольку выход из строя
любого компьютера прерывает работу всей сети, все компьютеры C1, C2, ..., Cn
должны быть очень надежными.
   В топологии типа магистраль присутствует один канал, к которому под-
ключены все компьютеры. Каждый компьютер «подслушивает» магистраль и
принимает пакеты, адресованные только ему. Любой компьютер может послать
пакет только тогда, когда магистраль свободна.
   Сети, основанные на топологии типа магистраль, очень надежны, поскольку
связь между компьютерами Ci, Cj сохраняется даже в том случае, когда все
другие компьютеры не работают.

198
   В распределенных топологиях между каждой парой компьютеров су-
ществует несколько путей передачи данных. Например, один пакет данных,
посланный компьютером C1 компьютеруCn (рис. 7.4г), может достичь адресата
по маршруту C1 – C2 – C5 – Cn, а другой пакет ― по маршруту C1 – C4 – Cn.
Очевидно, сеть будет функционировать даже в том случае, если один или не-
сколько компьютеров и линий связи выйдут из строя.
   Обычно топологии типа звезда, кольцо и магистраль применяют для
локальных сетей. Региональные и глобальные сети имеют распределенную
топологию. Объединение локальных сетей в региональные и глобальные сети
осуществляется в соответствии с основными типологиями, представленными
на рис. 7.4, где каждый узел C1, C2, ..., Cn представляет собой подсеть. Следо-
вательно, современные сети имеют иерархическую структуру.
  Набор правил для управления процессами обмена данными в сети
  называется протоколом обмена или просто протоколом.
   Любой протокол определяет режимы адресации компьютеров, длину
и состав пакетов данных, алгоритмы обнаружения и исправления ошибок,
режимы физического подключения сетевых адаптеров и кабелей и т. п. Одно-
временно с появлением первых компьютерных сетей каждый производитель
вычислительной техники создавал свои собственные протоколы связи, что
делало невозможным взаимное соединение компьютеров от разных произво-
дителей. Этот недостаток был устранен путем стандартизации протоколов.
Напоминаем, что стандарт представляет собой документ, в котором регла-
ментируется качество, характеристики, форма и т. п. определенного изделия.
Международные стандарты разрабатывает Международная организация по
стандартизации (ISO ― International Standards Organisation). Другой орга-
низацией, играющей важную роль в стандартизации изделий электроники и
вычислительной техники, является Институт инженеров по электротехнике
и радиоэлектронике (IEEE ― Institute of Electrical and Electronics Engineers).
  Архитектурой сети называется набор ее основных характеристик:
  топология, протоколы связи, технология взаимодействия.
   Далее рассматриваются наиболее распространенные архитектуры компью-
терных сетей.
   Ethernet (сеть в эфире) ― локальные сети, реализованные в соответствии со
стандартом IEEE 802.3. Используют магистраль из кабеля с витыми парами,
из коаксиального или оптоволоконного кабеля. Скорость передачи данных
достигает 100 Mбит/с. Данная архитектура была разработана фирмами
XEROX, Intel и DEC.
   Token–Ring (кольцо с жетоном) ― локальные сети, реализованные в соот-
ветствии со стандартом IEEE 802.5. Используют кольцо из кабеля с витыми
парами или из коаксиального кабеля. Скорость передачи данных достигает
16 Mбит/с. Данная архитектура разработана фирмой IBM.
   DATAKIT ― локальные, региональные или глобальные сети, разработан-
ные фирмой Bell Laboratories. С точки зрения топологии эта сеть состоит из
множества соединенных друг с другом звезд. Для оптоволоконного кабеля
достигнута скорость передачи до 1,5 Гбит/с.
   SNA (System Network Architecture) ― архитектура, разработанная фирмой
IBM для локальных, региональных и глобальных сетей. Протоколы данной

                                                                           199
архитектуры основаны на стандартах ISO. Поначалу топология имела тип
звезды, но в настоящее время изменилась на распределенную топологию,
поддерживая и локальные сети.
   ARPANET ― архитектура, спроектированная несколькими университетами
и корпорациями под эгидой Министерства обороны США (Advanced Research
Projects Agency). Данная архитектура базируется на распределенной топологии
и использует различные линии связи ― от телефонных линий до спутниковых
микроволновых каналов. Соответствующие линии связи соединяют отдельные
суперкомпьютеры и разнообразные локальные и региональные сети, занима-
ющие около половины земной поверхности. Архитектура ARPANET включает
в себя следующие протоколы:
   – протокол IP (Internet Protocol), предназначенный для соединения друг с
другом локальных, региональных и глобальных сетей;
   – протокол сервисов, основанных на соединениях, именуемый TCP
(Transmission Control Protocol);
   – протокол передачи файлов, называемый FTP (File Transfer Protocol);
   – протокол электронной почты ― SMTP (Simple Mail Transfer Protocol);
   – протокол для удаленного подключения к компьютеру ― TELNET.
   На основе архитектуры ARPANET была разработана глобальная компью-
терная сеть Internet, которая будет изучена в следующем параграфе.
   Подчеркнем, что с внедрением микрокомпьютеров в различные механизмы,
приборы и устройства (в частности, в бытовую технику) появилась возможность
подключения их к сетям, называемым сетями объектов или Интернетом
вещей (от англ. Internet of Things, сокращенно IoT).
   Объектами, подключенными к Интернету вещей, можно управлять уда-
ленно, что открывает новые возможности для повышения производительности
труда и улучшения качества жизни людей. В то же время все более широкое
распространение этих технологий сопровождается возникновением важных
проблем, связанных с безопасностью сетей и подключенных к ним объектов.
Возможные угрозы безопасности относятся не только к конфиденциаль-
ности и целостности обрабатываемой информации, но также к возможному
материальному ущербу и угрозам безопасности людей, который может быть
причинен объектами, вышедшими из-под контроля или контролируемыми
злоумышленниками.

  Вопросы и упражнения
  Ê	 Объясните термин пакет данных. Какую информацию содержит каждый
     пакет данных?
  Ë	 Объясните термин топология сети.
  Ì	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Нарисуйте основные типы топологии
     сетей. Назовите преимущества и недостатки каждой из топологий.
  Í	 Объясните, как передаются пакеты данных в следующих сетях: звезда,
     кольцо, магистраль, распределенная топология.
  Î	 Уточните путь, по которому пойдет пакет, посланный компьютером C2 ком-
     пьютеру C4 (рис. 7.4 a).
  Ï	 Найдите путь, по которому пойдут пакеты, посланные компьютером C2
     компьютеру C4 (рис. 7.4б).

200
  Ð	 Сколько путей передачи пакетов существует между компьютерами C1, Cn на
     рис. 7.4г? Какой путь самый короткий?
  Ñ	 Что произойдет с сетями на рис. 7.4, если выйдет из строя компьютер C1? А
     если выйдет из строя компьютер C2?
  Ò	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите топологию локальной сети, с которой
     вы работаете. Перечислите преимущества и недостатки данной топологии.
  Ó	 Для чего предназначен протокол? Какие нормы содержит протокол?
   	 Аргументируйте необходимость стандартизации протоколов. Кто разраба-
     тывает соответствующие стандарты?
   	 ЭКСПЕРИМЕНТИРУЙТЕ! Назовите протоколы, используемые в локальной
     сети, с которой вы работаете.
   	 Объясните, как объединяются локальные сети в региональные и глобальные
     сети. Нарисуйте топологию региональных или глобальных сетей, к которым
     вы имеете доступ.
   	 Объясните термин архитектура сети.
   	 Приведите примеры архитектур локальных, региональных и глобальных
     сетей.
   	 Охарактеризуйте архитектуру сети, с которой вы работаете.
   	 Перечислите протоколы, используемые в архитектуре ARPANET. Приме-
     няются ли эти протоколы в сети, с которой вы работаете?
   	 Объясните термин «Интернет вещей».
   	 ИССЛЕДУЙТЕ! На основе информации, опубликованной в Интернете, уз-
     найте, как и в какой степени Интернет вещей влияет на технологические
     процессы и повседневную жизнь людей.
   	 ТВОРИТЕ! Напишите короткое эссе, в котором осветите возможности,
     предлагаемые Интернетом вещей, и способы преодоления препятствий, с
     которыми он сталкивается.



  7.4. Глобальная сеть Интернет
   Глобальная сеть Интернет основывается на распределенной топологии и
состоит из отдельных компьютеров, локальных, региональных и глобальных
подсетей (рис. 7.5).
   Соединение сетей друг с другом осуществляется с помощью специальных
сетевых устройств, называемых шлюзами и маршрутизаторами. Шлюз
(gateway) ― это специальный компьютер, предназначенный для соединения
двух сетей с различными протоколами. Маршрутизатор (router) – это вы-
деленный компьютер, с помощью которого соединяются сети, использующие
одинаковые протоколы, и который используется для определения наилучшего
пути передачи пакетов. Компьютеры, подключенные к Интернету, называ-
ются хостами (host). Работу сети регламентируют около 100 протоколов.
   Идентификация компьютеров в пределах сети производится с помощью
интернет-адресов. Они могут быть двух типов: цифровые и символические.
   Цифровой адрес состоит из 32 двоичных цифр (4 байтов) и имеет струк-
туру, представленную на рис. 7.6.

                                                                          201
                                        Региональная
                                            сеть               Локальная
               Глобальная                                        сеть
                  сеть


                                       Глобальная            Региональная
                                          сеть                   сеть

                Региональная
                    сеть


                                                       Глобальная
                           Локальная                      сеть
                             сеть

                            Рис. 7.5. Топология Интернета

   Поскольку Интернет ― это «сеть сетей», цифровой адрес содержит адрес
подсети (поле Адрес сети) и адрес компьютера внутри самой подсети (поле
Адрес компьютера). В зависимости от максимального количества компью-
теров, которые можно идентифицировать внутри подсети, адреса делятся на
классы A, B и C. Адреса, принадлежащие классам D и E, имеют специальное
назначение. Характеристика интернет-адресов представлена в таблице 7.1.

                     Общая        Класс        Адрес       Адрес
                   структура      адреса       сети     компьютера


                                       Адрес            Адрес
                     Класс А                         компьютера
                                       сети


                                           Адрес          Адрес
                     Класс В                           компьютера
                                           сети


                                            Адрес          Адрес
                     Класс С                            компьютера
                                            сети

                      Рис. 7.6. Структура цифровых адресов

                                                              Таблица 7.1
                   Характеристика цифровых адресов
                            Количество доступных адресов
             Класс
                               сетей                 компьютеров
                       7                        24
               A      2 =128                   2 = 16 777 216
               B      214=16 384               216 = 65 536
               C      221=2 097 152            28 = 256

202
   Адреса класса A выделены для больших сетей, как правило, для глобаль-
ных. Сеть такого рода может содержать около 16 миллионов компьютеров.
Адреса класса B предназначены для средних сетей, как правило, для реги-
ональных. Сеть такого рода может содержать около 65 тысяч компьютеров.
Адреса класса C зарезервированы за относительно малыми сетями, вклю-
чающими до 256 компьютеров. Каждый интернет-адрес уникален. Адре-
са компьютерам присваивает Информационный центр сети (Network
Information Center).
   Например, двоичное число
                   10010010 00110011 00001001 11110111
является адресом класса B и идентифицирует компьютер под номером
                            00001001 11110111,
который входит в состав сети с номером
                             010010 00110011.
  Для удобства двоичные адреса представлены в десятичной форме (каждый
байт в отдельности). Десятичные числа, соответствующие каждому байту, от-
делены друг от друга точками.
  В случае рассмотренного выше примера получаем:
    (10010010)2=(146)10;	
    (00110011)2=(51)10;	
    (00001001)2=(9)10;	
    (11110111)2=(247)10.	
   Значит, в десятичной форме это адрес вида: 146.51.9.247.
   Адреса в десятичной и тем более в двоичной форме неудобны для большин-
ства пользователей. Поэтому чаще используются символические адреса.
   Символический адрес состоит из имени компьютера-хоста и имен до-
менов, отделенных друг от друга точками. Домен представляет собой группу
компьютеров, образованную по тематическим или географическим признакам.
Любой домен может быть разделен на субдомены, приобретая таким образом
иерархическую структуру. Доменные имена указаны в порядке увеличения
зоны покрытия.
   Например, символические адреса
    c1.lme.ch.md

    c5.lme.ch.md

идентифицируют компьютеры c1 и c5 из домена lme (Лицей “Михай Еминеску”).
  Символические адреса
    c1.lic.ch.md

    c9.lic.ch.md

                                                                     203
идентифицируют компьютеры c1 и c9 из домена lic (Лицей “Ион Крянгэ”). До-
мены lme и lic ― это поддомены домена ch (Кишинэу). В свою очередь, ch ― это
поддомен домена md (Республика Молдова).
  Аналогичным образом, символические адреса
      rector.ase.men.ro

      decan.ase.men.ro

определяют компьютеры rector и decan домена ase (Академия экономических
знаний). Домен ase ― это поддомен домена men (Министерство народного об-
разования), а men ― это поддомен домена ro (Румыния).
   Обычно домен самого верхнего уровня является страной (md, ro, us и т.п.)
или видом организации (com ― коммерческая, mil ― военная, edu ― образо-
вательная и т. п.).
   Отношения включения между доменами можно отобразить с помощью
диаграмм Эйлера, часто используемых в теории множеств. Для примера на
рис. 7.7 представлена такая диаграмма для некоторых символических адресов
домена md.




                 Рис. 7.7. Диаграмма Эйлера для символических адресов

   Для преобразования символических адресов в цифровые и обратно в
каждом домене имеется сервер имен (name server). Эта программа управляет
соответствующим доменом без вмешательства серверов верхнего уровня иерар-
хии. Следовательно, в Интернете не существует центрального компьютера,
                                     10
отвечающего за приблизительно 10 адресов сети.
   В случае примера, приведенного ранее (рис. 7.7), адреса компьютеров c1 и c5
обрабатываются на сервере lme, а адреса компьютеров c1 и c9 ― на сервере lic.
Сервер ch будет работать только с адресами серверов lic и lme, не вмешиваясь
в обработку адресов из доменов lic и lme. Аналогично сервер men не обрабаты-
вает адреса компьютеров rector и decan, предоставляя эту работу серверу ase.

204
Вопросы и упражнения
Ê	 Нарисуйте топологию Интернета. Как соединяются друг с другом подсети
   внутри Интернета?
Ë	 Для чего предназначены шлюзы и маршрутизаторы?
Ì	 Как идентифицируются компьютеры в Интернетe? В чем преимущества и
   недостатки цифровых адресов? А символических адресов?
Í	 На какие классы подразделяются цифровые адреса? Для чего предназначена
   такая классификация?
Î	 Объясните назначение полей Адрес сети и Адрес компьютера, входящие в
   состав цифрового адреса.
Ï	 Кто выделяет адреса для компьютеров из Интернета?
Ð	 Определите классы следующих адресов. Уточните адрес подсети и адрес
   компьютера в подсети:
	    a)	 45.201.19.63;	              d)	 192.109.58.170;	
	    b)	 201.165.213.91;	            e)	 15.21.207.250;	
	    c)	 154.36.79.200;	             f)	217.15.69.113.
Ñ	 По каким критериям компьютеры объединены в домены? Приведите при-
   меры нескольких доменов верхнего уровня.
Ò	 Даны следующие символические адреса:
	    a)	 c1.lme.ch.md;	              f)	 c4.lme.ch.md;
	    b)	 c3.lme.ch.md;	              g)	 c5.lme.ch.md;
	    c)	 c1.lic.ch.md;	              h)	 c9.lic.ch.md;
	    d)	 director.lic.ch.md;	        i)	 prof.lic.ch.md;
	  e)	 elev1.lic.ch.md;	        j)	 elev4.lic.ch.md.	
	  Уточните домены каждого компьютера и отношения включения между
   доменами. Нарисуйте диаграммы Эйлера для рассматриваемых адресов.
Ó	 Нарисуйте диаграммы Эйлера для перечисленных символических адре-
   сов. Уточните домены компьютеров и соответствующие отношения вклю-
   чения.
	 a)	 rector.ase.men.ro;	          d)	 rector.ase.met.md;
	    b)	 decan.ase.men.ro;	            e)	 decan.ase.met.md;
	    c)	 student.info.ase.men.ro;	     f)	 student.cib.met.md.
    	 В чем назначение сервера имен? Какие адреса обрабатывают эти серверы?
    	 Уточните серверы имен для адресов из упражнений 9 и 10. Укажите адреса,
      обрабатываемые каждым сервером.
    	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите цифровой и символический адреса
      компьютера, на котором вы работаете. Уточните класс адресов, адрес под-
      сети и адрес компьютера в рамках подсети. Нарисуйте диаграмму Эйлера,
      представляющую отношения включения между доменами, к которым при-
      надлежит ваш компьютер.

                                                                         205
  7.5. Сервисы Интернета
   В спектр услуг Интернета входит:
   – удаленный доступ к компьютерам;
   – передача файлов;
   – электронная почта;
   – новости и конференции (дискуссии);
   – распространение и поиск информации и т. п.
   Взаимодействие компьютеров и программ, которые представляют данные
услуги, основывается на модели клиент-сервер. Обычно на компьютере потре-
бителя выполняется программа-клиент, а на компьютере, предоставляющем
сервис (оказывающем услугу), выполняется программа-сервер.
   Сервис Telnet позволяет пользователю получить доступ к другому ком-
пьютеру, находящемуся на произвольном расстоянии (так называемый уда-
ленный доступ). После установления соединения компьютер пользователя
используется как простой терминал, находящийся на большом расстоянии
от центрального компьютера. Пользователь может запускать на удаленном
компьютере различные программы, просматривать файлы, изменять текущую
директорию и т. п. Защита компьютеров и соответствующих данных обеспе-
чивается применением паролей. Сервис Telnet применяется для совместного
использования дорогостоящих ресурсов, например суперкомпьютеров.
   Сервис передачи файлов, или коротко ― сервис FTP (File Transfer
Protocol) позволяет пользователю копировать файлы, находящиеся на ком-
пьютерах, размещенных в различных географических точках. Данный сервис
предлагает два режима передачи файлов:
   – двоичный режим, при котором сохраняется последовательность битов
файла, так что оригинал и копия идентичны с точностью до бита;
   – текстовой режим, в котором передаются наборы символов в коде ASCII.
   Как правило, для получения доступа к серверу FTP клиент должен ввести
пароль. Однако существуют публичные серверы (FTP anonymous), которые
разрешают доступ к файлам без необходимости ввода специального пароля.
   Сервис электронной почты (electronic mail, или сокращенно ― e-mail)
имитирует режимы работы обычной почты.
   В электронное письмо, называемое сообщением (message), входят:
   – адрес получателя;
   – тема сообщения, выраженная в нескольких словах;
   – адрес отправителя;
   – текст письма;
   – файлы, которые могут быть присоединены к сообщению.
   Присоединенные файлы могут быть любого типа: текстовые, звуковые,
графические, программы и т. п.
   Письма хранятся в специальных файлах, называемых почтовыми ящи-
ками (mailbox). Адрес любого почтового ящика имеет вид:
      <Имя ящика>@<Адрес компьютера> ,
где
   <Имя ящика> ― это название почтового ящика (обычно фамилия пользова-
теля или аббревиатура);

206
   @ ― символ коммерческого „at”;
   <Адрес компьютера> ― символический адрес компьютера ― клиента, на
котором создан почтовый ящик.
  Примеры:
  1)	 petrescu@c1.lme.ch.md		
  2)	 florea@director.lic.ch.md
  3)	 ionescu@c1.lme.ch.md
  4)	 barbu@director.lic.ch.md
  Читатели могут отправлять письма авторам данного учебника по адресу:
    Anatol_Gremalschi@yahoo.com

   Сообщения пересылаются через сеть почтовых серверов, которые выполняют
роль обычных почтовых отделений.
   Сервис электронной почты очень популярен благодаря его неоспоримым
преимуществам ― скорости, возможности присоединять к письмам файлы
любого типа и развитым возможностям редактирования писем.
   Самым современным сервисом распространения и поиска информации в
Интернете является сервис WWW (World Wide Web ― Всемирная паутина).
В данном сервисе информация представлена в форме Web-страниц.
   Web-страница – это файл, написанный на языке HTML (Hypertext Markup
Language ― Язык разметки гипертекста), который содержит, кроме самой ин-
формации, ссылки на другие страницы Web. Адресуемые ссылками страницы
могут быть размещены на этом же компьютере или на компьютерах, располо-
женных в различных географических точках (рис. 7.8).




                                  Рис. 7.8. Web-страницы

                                                                     207
   Взаимодействие программ в рамках сервиса WWW выполняется по типу
клиент-сервер. Пользователь, который хочет предложить широкой публике
определенную информацию, устанавливает на своем компьютере программу
WWW-сервер и разрабатывает одну или несколько Web-страниц. Сервер при-
нимает запросы, поступающие от других компьютеров, и предоставляет доступ к
соответствующим страницам. Компьютер, на котором размещены Web-страницы
и WWW-сервер, носит название сайт (англ. site — «местонахождение»).
   Программа-клиент обеспечивает прием и отображение на экране Web-
страниц, которые считываются с различных компьютеров (серверов) в Интер-
нете. Сразу после запуска эта программа отображает установленную по умол-
чанию домашнюю страницу (home page) и ожидает указаний пользователя.
Когда пользователь активизирует ссылку, программа-клиент устанавливает
соединение с Web-сервером и копирует с него страницу, определенную ссылкой.
Скопированная страница выводится на экран.
   Далее, когда пользователь активизирует другую ссылку, программа-клиент
вновь устанавливает соединение с одним из компьютеров сети, вновь читает Web-
страницу и т. п. Другими словами, пользователь «перелистывает» Web-страницы,
находящиеся на различных компьютерах, независимо от их географического рас-
положения. По этой причине программы-клиенты называются программами
перелистывания или программами навигации (с англ. browser или explorer).
   В рамках сервиса WWW ресурсы сети определяются с помощью специальных
адресов, называемых адресами URL (Uniform Resource Locator ― Универсаль-
ный указатель ресурсов). Данные адреса имеют вид:
      <протокол>: // <Символический адрес>[:<Порт>]/<Путь>/<Файл>
где
   <Протокол> ― определяет название протокола для передачи данных по сети;
   <Символический адрес> ― адрес компьютера, содержащего соответствую-
щий файл;
   <Порт> ― порт доступа (необязателен);
   <Путь>/<Файл> ― спецификация файла.
   Вот пример нескольких URL-адресов, которые содержат полезную инфор-
мацию:
   http://www.mecc.gov.md ― сайт Министерства образования, культуры и ис-
следований, Республика Молдова;
   http://www.ctice.gov.md ― сайт Центра информационных и коммуникаци-
онных технологий в образовании, Республика Молдова;
   https://www.sciencemuseum.org.uk – сайт Лондонского Музея науки;
   http://www.nasa.gov ― сайт агентства NASA, США.
   Напоминаем, что обозначение http определяет протокол передачи гипер-
текста (Hypertext Transfer Protocol).
   В настоящее время количество файлов в Интернете исчисляется мил-
лиардами. Естественно, не может быть и речи о поиске необходимой инфор-
мации путем чтения каждого файла в отдельности. Для упрощения поиска
информации в Интернете были созданы специальные поисковые серверы
(search engine).
   Поисковый сервер ― это компьютер, который непрерывно исследует сеть
и читает Web-страницы или другие ресурсы.

208
   Их классификация зависит от содержания, а их адреса запоминаются в
базе данных на поисковом сервере.
   Программа-клиент посылает поисковому серверу запрос, в котором указы-
вает признаки необходимой информации. Сервер опрашивает базу данных
и передает клиенту список адресов, по которым может быть найдена запро-
шенная информация.
   Для примера приведем адреса наиболее популярных серверов поиска:
   http://www.yahoo.com ― сервер YAHOO (Yet Another Hierarchically Organized
Oracle ― Еще Один Иерархически Организованный Оракул) компании Yahoo!
Inc.;
   http://www.google.com ― сервер GOOGLE корпорации Google Inc.;
   http://www.bing.com ― сервер BING корпорации Microsoft Inc.;
   http://www.yandex.ru ― сервер YANDEX компании «Яндекс»;
   Доступ к данным серверам свободный, т. е. бесплатный.


  Вопросы и упражнения
  Ê	 Назовите гамму услуг, предлагаемых в Интернете. Как взаимодействуют
     компьютеры сети в процессе оказания некоторой услуги?
  Ë	 Для чего предназначен сервис FTP? Какие файлы можно передавать с по-
     мощью данного вида сервиса?
  Ì	 Изучите программу FTP, установленную на вашем компьютере. Скопируй-
     те несколько файлов с публичных серверов FTP или с других серверов, к
     которым вы имеете доступ.
  Í	 От чего зависит скорость передачи файлов? Определите скорость передачи
     файлов с нескольких серверов FTP, расположенных в Республике Молдова,
     Румынии, США и России.
  Î	 Как задаются адреса в сервисе электронной почты?
  Ï	 Объясните, как взаимодействуют компьютеры клиентов и сервер почты в
     рамках соответствующей службы.
  Ð	 Назовите составляющие электронного письма? Какие из них необязательны?
  Ñ	 Объясните, как формируется электронный адрес. Узнайте email-адреса
     ваших друзей.
  Ò	 Изучите программу электронной почты, установленную на компьютере, с
     которым вы работаете. Проверьте, имеет ли данная программа следующие
     возможности:
  	 – использование нескольких почтовых ящиков;
  	 – сортировку и хранение писем в папках;
  	 – написание писем по шаблонам;
  	 – шифрование и дешифрование корреспонденции;
  	 – оповещение в момент поступления новой корреспонденции;
  	 – проверку получения адресатом посланного письма;
  	 – использование электронных подписей.
  Ó	 В чем преимущества электронной почты? Может ли она заменить традици-
     онную почту?

                                                                        209
      	 РАБОТА В ГРУППАХ. Создайте группы по четыре пользователя электронной
        почты и экспериментально определите скорость передачи корреспонденции.
      	 Какую информацию содержит Web-страница? Как эти страницы образуют
        всемирную паутину?
      	 Для чего предназначен Web-сервер? A Web-клиент? Как взаимодействуют
        эти программы?
      	 Объясните, как работает Web-клиент. Как данная программа находит Web-
        страницы, размещенные на разных компьютерах?
      	 Объясните способ указания ресурсов в Интернете с помощью адресов URL.
        Для чего предназначены различные поля таких адресов?
      	 ЭКСПЕРИМЕНТИРУЙТЕ! Определите тип программы просмотра Интер-
        нета, установленной на вашем компьютере. Каковы возможности данной
        программы? Прочитайте Web-страницы, адреса которых приведены в данном
        параграфе.
      	 Для чего предназначен поисковый сервер? Какие услуги предлагает такой
        сервер?
      	 ИССЛЕДУЙТЕ! Найдите с помощью любого поискового сервера поставщиков
        услуг (провайдеров) Интернет в Республике Молдова.
      	 ИССЛЕДУЙТЕ! Кроме сервисов, изученных в данном параграфе, сеть Ин-
        тернет предлагает и другие сервисы, такие как Archie, Gopher, WAIS, под-
        писки новостей, конференции и т. п. Используя поисковый сервер, найдите
        информацию об этих службах.
      	 ПРОЕКТЫ. Создайте Web-страницы вашего класса и лицея.




210
Глава 8
                                   МОДУЛИ ПО ВЫБОРУ

   Модули в этой главе не являются обязательными. Что это значит? Вы можете
выбрать один из них и изучить его с помощью компьютерного обучения в удоб-
ном для вас темпе самостоятельно или с коллегами, выполняя практические
упражнения и разрабатывая проекты. После того, как вы выбрали модуль,
вместе с учителем информатики необходимо решить, какие прикладные про-
граммы вы будете использовать. Также необходимо убедиться, что эти програм-
мы лицензированы или распространяются бесплатно, что они установлены на
компьютерах в компьютерных классах и, в зависимости от обстоятельств, на
ваших персональных компьютерах.
   Масштабные проекты (например, в рамках города, села, школы) будут раз-
рабатывать команды учеников, и каждый член команды будет специализиро-
ваться на определенном аспекте (например, историческом, демографическом,
экономическом, культурном, этнографическом и др.).
   Также команды будут разрабатывать проекты, связанные с богатым мульти-
медийным контентом, специализация членов команды будет осуществляться по
типу и специфике материалов (например, изображения, аудио, видео, дизайн гра-
фических интерфейсов, программирование алгоритмов обработки данных и т. п.).



  8.1. Техники аудио-видео обработки
   Данные техники будут изучаться поэтапно следующим образом.
   1. Оцифровка аудиоинформации. Вспомните из физики характеристики
звука как физического явления и параметры, которые влияют на восприятие
звуковых волн человеком. Из информатики вспомните цифровое кодирова-
ние аудиоинформации. Используя богатые ресурсы Интернета, узнайте, как
осуществляются сжатие и распаковка аудиоданных, каковы форматы файлов,
содержащих аудиоданные.
   Особое внимание уделите оборудованию для цифровой записи и воспроизве-
дения звука: технические параметры, взаимодействие с персональными ком-
пьютерами, соотношение цены и качества, области применения. В зависимости
от оборудования компьютерного класса и имеющегося у вас персонального циф-
рового оборудования, например: цифровых записывающих устройств, звуковых
карт, микрофонов, динамиков, усилителей, цифровых мультимедийных студий
и т. д., решите, как создавать, хранить и воспроизводить звуковые записи.
   Упражнения, рекомендуемые для данного этапа:
   −	 объяснение принципов кодирования и декодирования аудиоданных;
   −	 определение объема несжатых аудиоданных, зная параметры кодирования;
   −	 определение аудиоформата по расширению имени файла;

                                                                         211
   −	 распознавание и объяснение основных параметров и характеристик
оборудования, наиболее часто используемого для сбора, записи, обработки и
воспроизведения звуковых фрагментов.
   Для более глубокого понимания физических и информационных процессов,
связанных с цифровой записью и воспроизведением звука, рекомендуются
следующие тематические исследования:
   −	 аналоговая и цифровая запись звука;
   −	 сравнительный анализ устройств, предназначенных для цифровой об-
работки звука;
   −	 сравнительный анализ форматов аудиофайлов.
   Закрепление и углубление знаний из области оцифровки звуковой инфор-
мации возможны, работая над следующими исследовательскими проектами:
   −	 влияние частоты дискретизации звуковых сигналов на качество их вос-
произведения;
   −	 влияние величины шага квантования звуковых сигналов на качество их
воспроизведения;
   −	 влияние степени сжатия звуковых сигналов на качество их воспроизве-
дения.
   2. Обработка цифровых аудиозаписей. Внимательно изучите пред-
лагаемые на рынке программных продуктов лицензионные и свободно рас-
пространяемые программные приложения, предназначенные для цифровой
обработки аудиоданных. Решите, какую программу вы будете использовать,
и установите ее на том компьютере, на котором будете работать.
   Изучите рабочую среду и преимущества, предоставляемые звуковым ре-
дактором, с которым вам предстоит работать. Особое внимание обратите на
поддерживаемые форматы аудиофайлов, способы их хранения и организации,
совместимость редактора с внешними устройствами записи и воспроизведения
звука. Убедитесь, что графический интерфейс редактора достаточно интуити-
вен и прост для использования.
   Экспериментируя с различными цифровыми аудиозаписями, постарайтесь
развить следующие навыки по их обработке:
   −	 разбивка звуковой записи на фрагменты и их склеивание;
   −	 преобразование амплитуды (увеличение, микширование, нормализация);
   −	 изменение тона и длительности звука;
   −	 фильтрование звуковых сигналов;
   −	 применение эффектов.
   В процессе обработки звуковых записей используйте средства для анализа
звука, предлагаемые редактором: анализ спектра, изменение объема.
   С целью рациональной организации аудиофайлов на носителях информа-
ции и с учетом повышенных требований к качеству воспроизведения оцифро-
ванного звука произведите конверсию звуковых форматов.
   Упражнения, которые помогут вам закрепить теоретические знания и раз-
вить практические навыки применения цифровых устройств и программных
продуктов, предназначенных для обработки звука, включают:
   −	 применение средств, предоставляемых звуковым редактором;
   −	 сравнительный анализ одной и той же записи, представленной в раз-
личных аудиоформатах;
   −	 анализ качества воспроизведения звука в зависимости от параметров
записи и хранения аудиоданных;

212
   −	 конверсию аудиоформатов звуковых файлов;
   −	 передачу аудиофайлов через различные средства цифровых коммуника-
ций.
   Синергия информационных и специализированных аудиовизуальных
средств может быть обеспечена путем разработки следующих проектов:
   −	 разработка звукового фона для важных событий в личной жизни, семье,
классе, школе, обществе;
   −	 запись и микширование аудиоинформации из нескольких источников
во время праздничных, спортивных, художественных, развлекательных ме-
роприятий;
   −	 разработка саундтреков к видеофильмам о различных событиях школьной
и общественной жизни.
   3. Оцифровка видеоинформации. Для начала вам нужно вспомнить из
физики о волновой и корпускулярной природе света и иметь в виду, что в ин-
форматике свет рассматривается как электромагнитная волна. Затем узнайте
в Интернете, как человеческий глаз воспринимает свет и как цвета, яркость и
контраст изображения зависят от величины физических параметров электро-
магнитных волн. Для более глубокого понимания процессов оцифровки видео-
информации вам необходимо освежить свои знания о методах квантования
динамических изображений и расчета количества информации, которую они
содержат. Обратите особое внимание на частоту дискретизации во времени,
частоту дискретизации в пространстве, шаг квантования видеосигнала, мощ-
ность разрешения, количество основных цветов.
   Исходя из того, что очень часто видеоизображения содержат информацию,
избыточную для человеческого восприятия, ознакомьтесь с методами сжатия
и распаковки видеоданных с соответствующими этим методам форматами
файлов. Определите связь между скоростью передачи данных и качеством
воспроизведения видео, записанного в цифровой форме.
   Закрепите теоретические знания, изучив оборудование для цифровой
записи видеоинформации и ее воспроизведения: технические параметры,
взаимодействие с персональными компьютерами, соотношение цены и каче-
ства, области применения. В зависимости от оснащения вашей компьютерной
лаборатории и имеющегося у вас личного цифрового оборудования, например:
цифровых видеокамер, видеокарт, объективов, средств просмотра, мультиме-
дийных проекторов, цифровых мультимедийных студий и т. д., решите, как
вы будете создавать, хранить и воспроизводить цифровые видеозаписи.
   Упражнения, рекомендуемые для данного этапа:
   −	 описание сфер человеческой деятельности, в которых используется ви-
деоинформация;
   −	 описание и сравнение параметров электромагнитных волн с точки зрения
их восприятия человеком;
   −	 описание и объяснение видеофакторов, потенциально опасных для здо-
ровья человека;
   −	 объяснение принципов кодирования и декодирования видеоданных;
   −	 определение объема несжатых видеоданных, зная параметры кодирования;
   −	 определение формата видео, зная расширения имени файла;
   −	 определение и объяснение основных параметров и характеристик обору-
дования, часто используемого для сбора, записи, обработки и воспроизведения
видеофрагментов.

                                                                       213
   Рекомендуется провести следующие тематические исследования:
   −	 аналоговая запись и цифровая запись видеоинформации;
   −	 восприятие человеком различных электромагнитных волн;
   −	 влияние изменения параметров электромагнитных волн на их восприя-
тие человеком.
   Перечисленные исследовательские проекты предназначены для более
глубокого понимания того, как теоретические достижения информатики
влияют на технологии сбора, записи, хранения, обработки и воспроизведения
видеоинформации:
   −	 влияние изменения частоты дискретизации видеосигналов на качество
их воспроизведения;
   −	 влияние изменения шага квантования видеосигналов на качество их
воспроизведения;
   −	 влияние степени сжатия видеосигналов на качество их воспроизведения.
   4. Цифровая обработка видео. На рынке программных продуктов и в
свободном распространении можно найти продвигаемые самые разнообразные
компьютерные программы, предназначенные для обработки видеозаписей.
Пользователи могут выбирать как профессиональные, так и любительские
программные приложения. Обычно практически во всех операционных си-
стемах есть приложения для воспроизведения видео, а в некоторых из них
даже есть видеоредакторы.
   Поэтому перед прохождением данного этапа каждый ученик под руковод-
ством учителя информатики должен решить, какие программные продукты
использовать с учетом их совместимости с цифровым оборудованием, исполь-
зуемым для записи и воспроизведения видеоинформации. Необходимо также
учитывать тот факт, что редакторы цифровых видео требуют значительных
вычислительных ресурсов, таких как память (порядка гигабайт) и быстродей-
ствие (порядка гига операций в секунду).
   Изучение возможностей предлагаемых цифровых видеоредакторов будет
направлено на формирование и развитие следующих навыков:
   −	 разбиение видео на фрагменты и их склеивание;
   −	 редактирование видеофрагментов;
   −	 временные преобразования;
   −	 ассоциация звукового сопровождения;
   −	 изменение времени воспроизведения;
   −	 фильтрация видеосигналов;
   −	 применение эффектов;
   −	 субтитры в видеофрагментах;
   −	 преобразование формата.
   Упражнения, рекомендуемые для данного этапа:
   −	 использование основных возможностей цифрового видеоредактора;
   −	 сравнительный анализ записей одних и тех же видеофрагментов в разных
видеоформатах;
   −	 анализ качества воспроизведения видеофрагментов в зависимости от
параметров записи и хранения;
   −	 конвертация форматов видеофайлов.
   Тематика рекомендуемых проектов будет аналогична той же, что и в
случае цифровой обработки аудиофрагментов:

214
   −	 разработка видеофона для важных событий в личной жизни, семье, классе,
школе, обществе;
   −	 запись и микширование видеоинформации, поступающей из нескольких
источников во время праздничных, спортивных, художественных, развлека-
тельных мероприятий;
   −	 монтаж видеофильмов о различных событиях школьной и общественной
жизни.
   5. Распространение мультимедийной информации. На данном этапе,
самостоятельно или под руководством учителя информатики, изучите онлайн-
сервисы, которые предлагают вам возможность:
   −	 осуществлять поиск нужных мультимедийных ресурсов;
   −	 распространять собственные мультимедийные разработки;
   −	 редактировать онлайн мультимедийные фрагменты.
   Рекомендуется разработать каталог предпочитаемых услуг и подробно изу-
чить каждую из наиболее часто используемых пользователями услуг.
   На данном этапе предлагаем следующие упражнения:
   −	 регистрация и создание собственных профилей в онлайн-сервисах;
   −	 публикация собственных мультимедийных разработок;
   −	 передача мультимедийных файлов различными цифровыми средства-
ми связи;
   −	 поиск мультимедийной информации в Интернете;
   −	 включение ссылок в личные, классные, школьные, ассоциативные веб-
страницы на собственные мультимедийные ресурсы в Интернете.
   В качестве исследования рекомендуем провести сравнительный анализ
онлайн-сервисов распространения мультимедийной информации, выявив
их преимущества и недостатки, области применения с учетом специфики
мультимедийной информации, предназначенной для распространения в
виртуальном пространстве.
   6. Цифровая этика и соблюдение авторских прав. Если в древние
времена тексты, высеченные на каменных плитах или написанные на па-
пирусе, были доступны очень небольшому кругу людей, то с появлением
книгопечатания количество людей, получивших доступ к книгам, а затем и к
газетам, увеличилось в геометрической прогрессии. Хотя радио и телевидение
еще больше упростили процесс распространения информации, такие струк-
туры, как типографии, радио- и телестанции, принадлежали и по-прежнему
принадлежат государству или крупным компаниям. В результате у простых
граждан не было возможности самостоятельно публиковать для максимально
возможного количества людей созданные ими книги, фотографии, фонограм-
мы, фильмы. Ситуация радикально изменилась с появлением Интернета и
услуг онлайн-мультимедийного вещания, которые позволяют каждому из
нас публиковать ту информацию, которую мы считаем важной, интересной,
оригинальной или ценной с научной или художественной точки зрения.
   Несомненно, эта свобода выражения мнений способствует консолидации и
развитию демократических обществ, но требует от каждого из нас соблюдения
в виртуальном пространстве определенных правил. Вы изучали эти правила,
обычно называемые правилами цифровой этики, начиная с гимназических
классов. Однако мы настоятельно рекомендуем вам освежить свои знания в
этой области, строго соблюдать правила и помнить, что в многокультурном и

                                                                        215
многоконфессиональном мире слова, изображения, звуковые и видеоматериалы
могут быть интерпретированы и поняты по-разному. Поэтому прежде чем раз-
мещать в Интернете разработанный вами мультимедийный продукт, убедитесь,
что он несет позитивную информацию, продвигает общечеловеческие ценности,
поощряет участие и инклюзию.
   Другой очень важный аспект, связанный с распространением мультиме-
дийных продуктов, это необходимость соблюдения авторских и смежных прав.
Обратите внимание, что авторское право распространяется на литературные,
художественные и научные произведения, выраженные в следующих формах:
   −	 письменная (рукопись, машинописный текст, партитура и т. д.);
   −	 устная (публичное исполнение и др.);
   −	 аудио или видео печать (механическая, магнитная, цифровая, оптиче-
ская и др.);
   −	 изображение (рисунок, эскиз, картина, план, фотография и др.);
   −	 трехмерная (скульптура, модель, макет, конструкция и др.).
   Поэтому прежде чем включать в свои разработки фрагменты из каких бы то
ни было произведений, уточните, допускают ли это обладатели авторских прав.
   Также не представляйте в качестве личных творений идеи, фрагменты
текста, изображения, фонограммы, видеограммы, взятые из произведений и
мультимедийных продуктов, созданных другими, так как это плагиат, а проще
говоря ― воровство и противоправное деяние, наказуемое соответствующими
статьями закона.
   Если авторы произведений и мультимедийных продуктов разрешают ис-
пользование материалов (об этом можно осведомиться, внимательно прочитав
лицензию), обязательно укажите источник: имя автора, название работы,
издательство, название студии, URL-адрес и т. д.
   Рекомендуемые упражнения для данного этапа:
   −	 идентификация знаков, декларирующих авторские права;
   −	 разъяснение правил соблюдения авторских прав;
   −	 определение типов лицензий на распространение;
   −	 использование лицензий на распространение.
   В качестве тематических исследований рекомендуется проанализировать
соблюдение авторских прав в собственных мультимедийных продуктах, в
мультимедийных продуктах, разработанных и опубликованных в Сети одно-
классниками и учениками вашей школы, учащимися других учебных заве-
дений. Используйте функции, предоставляемые поисковыми системами, для
поиска текстовой, графической, аудио- и видеоинформации. Пригодятся вам и
программы по борьбе с плагиатом, доступные в Интернете, в режиме онлайн.



  8.2. Визуальное программирование
  Исторически первые программы были написаны на языке машинного кода.
Впоследствии программисты перешли на языки ассемблера и языки програм-
мирования высокого уровня. В случае языков программирования высокого
уровня программы представляют собой тексты, которые для «понимания»
компьютером «переводятся» в двоичные коды.
  В течение длительного периода времени программные продукты разрабаты-
вались с использованием языков программирования высокого уровня, перво-

216
начально пользуясь для написания кода простыми текстовыми редакторами,
а затем интегрированными средами разработки программ. Эти среды, помимо
редактирования текстов и быстрого внесения изменений, позволяют запускать
и отлаживать разрабатываемые программы. Вы уже знаете такие среды про-
граммирования и даже разрабатывали и отлаживали в них программы.
   Независимо от среды разработки программ, используемых в учебных или
производственных целях, в них работают с текстами. Однако с ростом слож-
ности программ тексты стали объемными и трудными для восприятия даже
их авторами, что стимулировало развитие так называемого визуального про-
граммирования ― способа разработки программ не путем написания текстов,
а путем манипулирования графическими объектами.
   Вам уже знакома среда визуального программирования Scratch, специально
разработанная для изучения информатики, начиная с начальных классов. В
этой среде программирования учащиеся реализуют алгоритмы управления
так называемыми спрайтами, манипулируя графическими объектами, которые
представляют самих спрайтов, команды, которые они должны выполнять, и
блоки управления потоком выполнения: ветвление в зависимости от соблю-
дения определенных условий, организацию циклов и подпрограмм.
   Классическими средствами визуального программирования, разрабо-
танными для производственных целей, являются приложения для работы с
электронными таблицами, изучаемые в гимназических классах. В этих при-
ложениях пользователь реализует алгоритмы обработки числовых данных не
путем написания программ на языке высокого уровня, например на PASCAL
или C ++, а путем работы с конкретными графическими объектами, такими как
рабочие листы, ячейки, строки, столбцы, диаграммы, графики, формы и т. д.
   В настоящее время известные компании, работающие в области инфор-
мационных и коммуникационных технологий, предлагают очень широкий
спектр средств визуального программирования, что значительно облегчает
реализацию даже самых сложных алгоритмов. Всё более широкое использова-
ние визуального программирования открывает новые возможности не только
для людей, которые хотят сделать профессиональную карьеру в области ин-
форматики, но и для тех, кто увлечен цифровым искусством, компьютерным
обучением, разработкой интерактивных компьютерных игр.
   Таким образом, знание визуального программирования позволит ученикам
принимать обоснованные решения относительно продолжения учебы после
окончания лицея, а также поможет им применять компьютер в тех сферах
профессиональной деятельности, в которых они намерены специализировать-
ся. А чтобы облегчить процесс изучения визуального программирования, мы
рекомендуем ученикам пройти следующие этапы:
   1. Выбор среды визуального программирования. Очевидно, что любая
программа, разработанная в средах визуального программирования, имеет
свой эквивалент в текстовой форме, написанный на языке программирования
высокого уровня. Более того, чтобы эффективно реализовать определенные
алгоритмы обработки данных, иногда даже в визуальном программировании,
требуется писать подпрограммы на языке высокого уровня. Поэтому при вы-
боре среды визуального программирования будет приниматься во внимание
не только простота ее использования, но и ориентация на определенный язык
программирования высокого уровня.

                                                                     217
   Например, ученики, изучавшие язык PASCAL, выберут среды визуального
программирования Delphi или Lazarus, а те, кто изучал языки семейства C ―
среды визуального программирования Microsoft Visual Studio или Code :: Blocks.
   Ученики, которые хотят изучать только основы визуального программиро-
вания, не прибегая к профессиональному языку программирования высокого
уровня, могут сделать это с помощью MIT App Inventor, который использует
визуальный язык и графические интерфейсы, аналогичные тем, которые при-
меняют в среде программирования Scratch.
   Рекомендуем ученикам, прежде чем выбирать определенную среду визу-
ального программирования, ознакомиться с их классификацией, с их техни-
ческими и эргономическими параметрами, с требованиями, которые эти про-
дукты предъявляют к компьютерам, которые будут использоваться в процессе
обучения, а также к требованиям относительно возможности передачи через
Интернет. Ученики также должны учитывать свои цели: углубить навыки
разработки графических интерфейсов для консольных и веб-приложений или
развить новые навыки в областях, где пересекаются информационные техно-
логии и искусство: цифровая анимация, компьютерные игры, дополненная
реальность (англ. augmented reality, AR) и др.
   2. Изучение понятий и основных принципов визуального про-
граммирования. На этом этапе вам нужно будет ознакомиться с понятиями
графического объекта, связей и действий, с типами первичных графических
объектов и метаобъектов, со свойствами объектов. Особое внимание необходимо
уделить пониманию специфики событийно-ориентированного программиро-
вания в визуальном контексте: ситуации, действия и результаты.
   Основные упражнения, рекомендуемые для данного этапа:
   −	 объяснение принципов визуального программирования;
   −	 объяснение основных понятий визуального программирования;
   −	 классификация объектов / графических команд;
   −	 контроль событий, действий, состояний.
   Следующие тематические исследования будут способствовать более глу-
бокому пониманию специфики визуального программирования:
   −	 графические команды в сравнении с письменными командами;
   −	 гибкость визуального программирования;
   −	 средства отладки программ: визуальные и процедурные;
   −	 средства отладки программ: визуальные и объектно-ориентированные.
   3. Формирование и развитие навыков использования сред визу-
ального программирования. Используя в качестве обучающего инстру-
мента систему поддержки среды визуального программирования, выбран-
ную на первом этапе и установленную, при необходимости, на компьютере,
определите основные компоненты используемого программного продукта
и особенности графического пользовательского интерфейса. Подробно изу-
чите структуру проекта, типологию файлов в составе проектов и способы их
организации.
   Работая над дидактическими проектами, предложенными преподавателем
информатики, сформируйте необходимые навыки для ввода и редактирования
программ, их запуска и отладки. Основные упражнения, рекомендуемые для
этой цели:
   −	 определение главных компонентов среды визуального программирования;

218
   −	 объяснение структуры проектов в средах визуального программирования;
   −	 идентификация файлов проекта;
   −	 включение графических команд в программы;
   −	 отладка визуальных программ;
   −	 запуск визуальных программ.
   Работа над следующими тематическими исследованиями поможет фор-
мированию углубленного видения богатого разнообразия средств, предна-
значенных для визуального программирования:
   −	 преимущества и недостатки сред визуального программирования;
   −	 сравнительный анализ визуальной и традиционной сред программи-
рования;
   −	 представление некоторых широко используемых сред и языков визуального
программирования (Alice, Kodu, Scratch, ToonTalk, Cameleon, Filter Forge и др.).
   4. Формирование и развитие компетенции визуального программи-
рования. Этот этап начнется с изучения графических команд и критериев их
классификации. Далее вам необходимо ознакомиться и изучить на небольших
примерах средства, обеспечивающие:
   −	 выполнение движения: движение, вращение, контроль наступления
определенного события, контроль наступления определенной ситуации;
   −	 настройку внешнего вида: изменение размера, отображение сообщений, ото-
бражение значений, изменение объектов, настройка видимости, настройка слоев;
   −	 управление звуком: настройка, запуск, остановка, продолжительность,
применение эффектов;
   −	 обработка событий: запуск / остановка программ, действия клавиш,
действия кнопок мыши, действия над графическими объектами, управление
потоком сообщений;
   −	 управление потоком выполнения: команды выбора, циклические коман-
ды, паузы, остановки, клонирование;
   −	 контроль ситуаций: настройка свойств объекта, ввод данных, настройка
свойств периферийных устройств, последовательное распределение во вре-
мени;
   −	 создание и вызов подпрограмм.
   Упражнения, рекомендуемые для данного этапа:
   −	 перемещение и контроль графических объектов;
   −	 отображение сообщений;
   −	 настройка геометрических / цветовых / визуальных / графических свойств
объекта;
   −	 интеграция звуковых компонентов (мультимедиа) в визуальные про-
граммы;
   −	 управление динамическими графическими объектами с помощью кла-
виатуры и мыши;
   −	 создание и вызов подпрограмм.
   Также на этом этапе начинается разработка проектов со следующими ре-
комендуемыми темами:
   −	 взаимодействие между двумя и более визуальными персонажами (объ-
ектами);
   −	 проигрывание диалогов между персонажами;
   −	 элементарные игры (прототип тенниса, ловля падающих предметов,
погони);

                                                                            219
   −	 анимированные рассказы.
   Ученикам предлагается самостоятельно или под руководством учителя
информатики конкретизировать тему проекта, над которым они хотели бы
работать, решить, как организовать, индивидуально или в группах, работу
над предлагаемым ими проектом и разработать план работы над ним.
   5. Обработка внешних данных. За любыми графическими объектами
скрываются определенные данные: информация об их форме и внешнем виде,
их расположении в пространстве, траектории движения в рабочем простран-
стве, сообщениях, полученных от других объектов, и т. д. Результаты обработки
соответствующих данных определяют поведение объектов во времени и про-
странстве, взаимодействие между собой и с внешней средой.
   Чтобы изучить способы реализации алгоритмов обработки данных, вспом-
ните о простых и составных типах данных, а также об операциях, которые
могут быть выполнены с соответствующими данными. Особое внимание уде-
лите специфике преобразования типов и арифметическим, реляционным и
логическим операциям, которые можно выполнять с конкретными данными
в средах визуального программирования.
   Далее мы рекомендуем изучить визуальные объекты для ввода и ото-
бражения данных, события и действия, предназначенные для модификации
данных: ситуации, возникшие в процессе выполнения программы, команды
с клавиатуры, мыши, другого периферийного оборудования.
   Упражнения, способствующие развитию навыков обработки данных в ви-
зуальных программах:
   −	 объявление и использование переменных, относящихся к простым и со-
ставным типам данных;
   −	 использование арифметических, реляционных и логических операций в
визуальных программах;
   −	 изменение значений переменных посредством действий и реакций на
события (нажатие клавиш и кнопок мыши, получение сообщений от других
графических объектов или извне и т. д.);
   −	 отображение результатов путем связывания их с графическим объектом;
   −	 объявление и использование переменных, принадлежащих к составным
типам данных;
   −	 поиск информации в структурах данных;
   −	 изменение структуры данных.
   Более глубокое понимание специфики обработки данных в случае визу-
ального программирования может быть обеспечено путем проведения тема-
тического исследования, в котором будут проанализированы преимущества
и недостатки того, как реализовать вычислительные алгоритмы посредством
текстового и визуального программирования. Такое тематическое исследо-
вание также поможет выявить возможности привязки текстовых программ к
определенным объектам в составе визуальных программ.
   Проекты, рекомендуемые для данного этапа:
   −	 вычисление максимального числа из множества чисел, указанных пер-
сонажами (объектами);
   −	 подсчет суммы множества чисел, указанных персонажами;
   −	 нахождение простых чисел из множества чисел, указанных персонажами;
   −	 вычисление наибольшего общего делителя;

220
   −	 сортировка массивов.
   В целом интеграцию знаний и развитие навыков визуального программи-
рования можно обеспечить путем разработки сложных проектов, таких как
графические интерфейсы для консольных и веб-приложений, обучающие игры,
развлекательные игры, компьютерные обучающие программы, анимационные
фильмы (мультфильмы), продукты с дополненной реальностью (рекламные
материалы, динамические модели, динамические реконструкции историче-
ских объектов и др.). Разработка таких проектов возможна путем создания
команд учеников, в которых, помимо тесного сотрудничества, должно быть
четкое разграничение ролей и обязанностей, специализация в соответствии с
призванием и интересами каждого ученика.



  8.3. Языки разметки гипертекста
   Возможно, в предыдущем классе вы изучали дополнительный модуль
веб-дизайна. Изучив этот модуль, вы узнали, как создавать веб-документы,
используя как приложения общего назначения, такие как офисные приложе-
ния, так и специализированные приложения, называемые веб-редакторами.
В обоих случаях ученики, возможно будущие веб-дизайнеры, работали с
объектами создаваемых веб-страниц, то есть с текстом, изображениями,
элементами навигации, вводом информации, воспроизведением аудио- и
видеофрагментов и т. д.
   И универсальные, и специализированные приложения, предназначенные
для разработки веб-документов, которые вы изучали в предыдущих курсах,
работают в WYSIWYG (What You See Is What You Get ― англ., то, что вы види-
те, это именно то, что вы получаете). В этом режиме веб-разработчик работает
напрямую только с объектами веб-страниц, не прибегая к возможностям,
предлагаемым языком HTML.
   Напомним, что язык HTML (Hyper Text Markup Language) был специально
разработан для форматирования текстов веб-страниц, вставки в них элемен-
тов управления и ссылок на различные объекты (другие веб-страницы, изо-
бражения, аудио-, видеофрагменты и т. д.), находящиеся как на локальном
компьютере, так и в любом месте в Интернете.
   Хотя работа в режиме WYSIWYG намного удобнее для разработчиков веб-
страниц, чем разметка текста с помощью HTML, во многих случаях прямое
«написание» веб-страниц на языке HTML обеспечивает значительную эконо-
мию памяти и дает дизайнеру больше возможностей размещения объектов на
странице и их форматирования.
   Рекомендуется проводить изучение языка HTML поэтапно, а именно:
   1. Разработка простых веб-документов. На этом этапе особое внимание
следует уделить пониманию концепции языка HTML, роли маркеров (тегов),
способов их вставки в простые неформатированные тексты, отображают про-
граммы навигации как веб-страницы. Необходимо просмотреть список мар-
керов и уточнить их назначение.
   Само создание веб-страниц начинается с разработки их общей структуры,

                                                                        221
установления объектов, которые будут в них вставлены. На этом этапе будут
подробно изучены только инструменты HTML для форматирования текста:
   −	 заголовки;
   −	 абзацы;
   −	 комментарии;
   −	 физические стили;
   −	 логические стили;
   −	 разделители;
   −	 упорядоченные списки;
   −	 неупорядоченные списки;
   −	 списки определений.
   Изучение инструментов форматирования текста в составе документов HTML
будет проводиться в тесной связи с элементами обработки текста, изученными
в гимназических классах. При этом особое внимание необходимо уделить клю-
чевым словам в составе меток, способам организации меток попарно, в начале и
в конце. Поскольку репертуар атрибутов тегов очень широк, усилия по об-
учению будут сосредоточены не на их запоминании, а на формировании
навыков использования онлайн- и автономных систем поддержки, которые
могут предоставить подробную информацию о каждом теге и о каждом из
его атрибутов.
   Рекомендуемые практические упражнения для этого этапа включают
создание веб-страниц, которые для начала содержат только текст, отформа-
тированный так, чтобы выделить суть информации:
   −	 Мой дом/Моя школа/Мой город/Родное село.
   −	 Мой класс/Мой школьный кружок/Моя спортивная секция.
   −	 Студенческий совет / Молодежный совет.
   −	 Волонтерство в моей школе, моем селе/городе.
   −	 Книжный магазин/Библиотека/Дом культуры/Музыкальный салон.
   −	 Музей села/Городской музей.
   −	 История моего села/города.
   −	 Знаменитости из моего села/города.
   −	 Искусство в моей жизни (в сферах: музыка, пластика, декоративное ис-
кусство).
   −	 Спорт в моей жизни.
   −	 Здорово быть здоровым.
   −	 Тренажерные залы / фитнес-залы.
   −	 Салоны красоты / Салоны моды.
   −	 Швейные / ремонтные мастерские (автомобили, компьютеры, бытовая
техника, аудио, видео).
   −	 Крестьянское хозяйство.
   −	 Магазины (детские товары, школьные товары, хозтовары, одежда).
   Если вы ранее уже разрабатывали такие страницы, рекомендуется ото-
бражать HTML-файлы в режиме View Source (Просмотр исходного кода) и
анализировать, как использовать маркеры (теги) для форматирования вхо-
дящих в них текстов.
   2. Создание ссылок. Самый распространенный сервис Интернета ― WWW
(World Wide Web ― Всемирная сеть [паука]) основан на документах HTML,
связанных между собой, и внешних по отношению к ним файлах. Переход от

222
одного документа HTML к другому и отображение внешних файлов в програм-
ме навигации осуществляются с помощью специальных ссылок, называемых
в последнее время линками (от англ. link).
   В документе HTML ссылки создаются путем связывания URL-адресов с
активными областями страницы. Активные области могут быть фрагмента-
ми текста или изображений, а щелчок по такой области требует, чтобы про-
грамма навигации нашла связанный ресурс на локальном компьютере или
в виртуальном пространстве, в зависимости от случая, и отобразила его на
локальном компьютере.
   Рекомендуется, чтобы процесс изучения того, как создавать ссылки, вы-
полнялся следующим образом:
   −	 ознакомление с используемой терминологией: привязка, URL, внутрен-
няя ссылка, внешняя ссылка, путь, комментарий к ссылке;
   −	 развитие возможностей создания / выбора активных областей HTML-
документов, состоящих как из текстовых фрагментов, так и из изображений;
   −	 доработка с использованием форматов маркеров, предназначенных для
создания ссылок;
   −	 создание ссылок на внешний документ, на документ, находящийся в том
же или другом каталоге на локальном компьютере;
   −	 создание ссылок на сайт;
   −	 создание ссылок на фрагмент того же или другого HTML-документа;
   −	 создание средств для запуска приложения для обмена сообщениями;
   −	 создание средств копирования файлов.
   На начальном этапе в качестве HTML-документов, в которых будут созда-
ваться ссылки, используются файлы, предложенные преподавателем, а после
развития необходимых навыков, путем создания ссылок в документах HTML,
разработанных учениками в проектах, предложенных для практической де-
ятельности на предыдущем этапе (Мой дом, Мой класс, Студенческий совет,
Волонтерство в моей школе и т. д.).
   3. Вставка мультимедийных объектов. Первоначально HTML-страницы,
отображаемые на экране, содержали только текст. Позже, с развитием инфор-
мационных и коммуникационных технологий, в них начали появляться ссылки
на различные мультимедийные объекты: статические рисунки, анимирован-
ные изображения, фотографии, аудио-, видеофрагменты и т. д.
   Процесс изучения того, как вставлять ссылки на мультимедийные объекты
в HTML-документы, будет состоять из следующих шагов:
   −	 знакомство с форматами графических, аудио- и видеофайлов;
   −	 организация файлов, содержащих мультимедийные объекты, в каталогах,
связанных с разрабатываемыми HTML-документами;
   −	 ознакомление со свойствами мультимедийных объектов, актуальными
для их вставки в HTML-документы: размеры, границы, комментарии, элемен-
ты управления, ссылки;
   −	 изучение специфики интегрируемых мультимедийных объектов: управ-
ляющих элементов, интеграционных атрибутов;
   −	 вставка в HTML-документы изображений, звуковых фрагментов, видео-
фрагментов;
   −	 настройка свойств мультимедийных объектов, вставляемых в HTML-
документы.

                                                                     223
   На начальном этапе отработка практических навыков вставки мультиме-
дийных объектов в HTML-документы будет осуществляться с использованием
HTML-файлов и мультимедийных объектов, предложенных преподавателем.
В дальнейшем развитие этих навыков будет достигаться в рамках проектов,
разработанных учениками, ориентировочная тема которых указана ранее, в
соответствующем списке первого этапа. С этой целью ученики самостоятель-
но, индивидуально или в группах/командах подготовят те мультимедийные
объекты (изображения, фотографии, звуковые фрагменты, видеофрагменты),
которые значительно помогут развить предложенную тему.
   В процессе создания и/или выбора мультимедийных объектов, используемых
для включения в состав HTML-документов, будут строго соблюдаться правила
цифровой этики и авторские права. Плагиат исключён!
   4. Организация контента. Современные версии языка HTML предлага-
ют несколько возможностей для организации контента. В рамках лицейской
программы будем изучать только организацию контента с помощью таблиц.
С этой целью мы рекомендуем ученикам:
   −	 освежить свои знания о таблицах: заголовок, строка, столбец, ячейка,
заголовок строки, заголовок столбца, свойства ячейки, свойства содержимого
ячейки;
   −	 ознакомиться с маркерами, используемыми для создания и форматиро-
вания таблиц и их атрибутами;
   −	 организовать содержимое разрабатываемых веб-страниц, используя макет
страницы с помощью таблиц;
   −	 придать веб-страницам дизайн, который будет выделять информацию,
необходимую передать путем редактирования соответствующих таблиц: объ-
единение и разделение ячеек, применение цветовых и градиентных эффектов,
установка свойств границ.
   Как и на предыдущих этапах, первоначально маркеры таблиц и их атрибуты
будут изучаться с использованием очень простых документов HTML, пред-
ложенных учителем или созданных учениками самостоятельно, а затем ― в
проектах, разработанных учениками индивидуально или в группах/командах.
   5. Тестирование документов HTML. Для начала документ HTML будет
протестирован локально с помощью программы навигации. В процессе те-
стирования будет проверена доступность всех объектов в HTML-документах,
правильность ссылок, работа инструментов навигации, правильность отобра-
жения рисунков, правильность воспроизведения аудио- и видеофрагментов.
   В случае ошибок необходимо вернуться к этапу создания веб-страниц и
объектов, из которых они состоят.
   В конце изучения данного модуля ученикам предлагается провести кол-
лективный анализ разработанных ими HTML-документов, используя для этой
цели как технические критерии (используемые шрифты и их размер, макет,
качество изображения, точность воспроизведения аудио и видео, удобство на-
вигации), так и художественные (оригинальность, актуальность содержания
по отношению к передаваемой информации, способ выделения сообщений,
соответствие цветов и стилей отображения).




224
