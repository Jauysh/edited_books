







# ИНФОРМАТИКА
# Учебник для 10-го класса
# СОДЕРЖАНИЕ

	 Повторение:
  Recapitulare:Алгоритмы,
               algoritmi, programe
                           программы
                                   şi executanţi	
                                       и исполнители	   	   	   6

1.	
Глава
    VOCABULARUL
       1. Словарь и ŞI
                    синтаксис
                       SINTAXAязыка
                               LIMBAJULUI
                                    ПАСКАЛЬ/C++	
                                          PASCAL/C++	   	   	
	 1.1. Знакомство
       Iniţiere în limbajul
                     с языком
                            PASCAL/C++	
                              ПАСКАЛЬ/C++	              	   	   9
	 1.2. Метаязык
       Metalimbajul
                БНФ	BNF	                                	   	   13
	 1.3. Синтаксические
       Diagrame sintactice	
                       диаграммы	                       	   	   17
	 1.4. Алфавит
       Alfabetul языка	
                 limbajului	                            	   	   19
	 1.5. Словарь
       Vocabularul
               языка	
                   limbajului	                          	   	   19
	 1.5.1. Специальные
         Simboluri speciale
                       символы
                            şi cuvinte-cheie	
                                  и ключевые слова	     	   	   19
	 1.5.2. Идентификаторы	
         Identificatori	                                	   	   23
	 1.5.3. Числа	
         Numere	                                        	   	   25
	 1.5.4. Строки
         Şiruri deсимволов	
                   caractere	                           	   	   28
	 1.5.5. Метки	
         Etichete	                                      	   	   31
	 1.5.6. Директивы	
         Directive	                                     	   	   32
	 1.6. Разделители	
       Separatori	                                      	   	   33
	 Тест
  Test de
        для
          autoevaluare
            самопроверки
                       nr. 1	
                            № 1	                        	   	   35

2.	 TIPURI
Глава  2. Простые
           DE DATEтипы
                    SIMPLE			
                       данных			
	 2.1. Концепция
       Conceptul deданных	
                    dată	                               	   	   39
	 2.2. Тип
       Tipulданных
             de dateinteger/int	
                    integer/int	                        	   	   43
	 2.3. Тип
       Tipulданных  real/float	
             de datereal/float	                         	   	   49
	 2.4. Тип
       Tipulданных  boolean/bool			51
             de dateboolean/bool			51
	 2.5. Тип
       Tipulданных
             de datechar			54
                    char			54
	2.6.
	 2.6. Перечисляемые
       Tipuri de date enumerare	
                        типы данных	                    	   	   57
	 2.7. Интервальные
       Tipuri de date subdomeniu
                       типы данных
                                 (PASCAL)			61
                                    (ПАСКАЛЬ)			61
	 2.7.* Тип
        Tipulданных void (C++)	
              void (C++)	                               	   	   65
	 2.8. Порядковые
       Generalităţi despre
                    типы данных	
                           tipurile ordinale de date	   	   	   65
	 2.9. Объявление
       Definirea tipurilor
                    типовdeданных	
                             date	                      	   	   70
	 2.10. Объявление
        Declaraţii de переменных	
                      variabile	                        	   	   78
	 2.11. Описание
        Definiţii deконстант	
                     constante	                         	   	   81
	 Тест
  Test de
        для
          autoevaluare
            самопроверки
                       nr. 2	
                            № 2	                        	   	   87
Глава 3. Операторы
	 3.1. Концепция действия	                             	   	   92
	 3.2. Выражения	                                      	   	   94
	 3.3. Вычисление выражений	                           	   	   102
	 3.4. Тип выражений	                                  	   	   105
	 3.5. Преобразование типов в языке C++	               	   	   111
	 3.6. Оператор присваивания	                          	   	   112
	 3.7. Оператор вызова процедуры в языке ПАСКАЛЬ	      	   	   116
	 3.8. Вывод алфавитно-цифровой информации на экран	   	   	   117
	 3.9. Ввод данных с клавиатуры	                       	   	   124
	 3.10. Пустой оператор	                               	   	   128
	 3.11. Оператор if	                                   	   	   129
	 3.12. Оператор множественного выбора	                	   	   133
	 3.13. Оператор for	                                  	   	   138
	 3.14. Составной оператор	                            	   	   144
	 3.15. Оператор while			148
	 3.16. Оператор repeat			154
	 3.17. Оператор goto			159
	 3.18. Структура программы ПАСКАЛЬ / C++	             	   	   165
	 Тест для самопроверки № 3	                           	   	   168

Глава 4. Модули по выбору
	 4.1. Веб-дизайн	                                     	   	   172
	 4.2. Компьютерная графика	                           	   	   179
	 4.3. Цифровая фотография	                            	   	   183

	 Ответы на задания из тестов для самопроверки	        	   	   186

	 Приложения	                                          	   	
	 Приложение 1. Словарь языка ПАСКАЛЬ			201
	 Приложение 2. Синтаксис языка ПАСКАЛЬ			202
	 Приложение 3. Компиляция и отладка ПАСКАЛЬ программ			205
	 Приложение 4. Словарь языка C++			207
	 Приложение 5. Компиляция и отладка программ C++			208





# Повторение
## АЛГОРИТМЫ, ПРОГРАММЫ И ИСПОЛНИТЕЛИ

Известно, что алгоритм представляет собой конечную совокупность правил и предписаний, выполнение которых обеспечивает решение поставленной задачи. Процесс разработки алгоритмов называется алгоритмизацией.
   
В информатике понятие алгоритма неразрывно связано с понятием исполнителя. Исполнитель представляет собой объект, который может выполнять (исполнять) определенные команды. Множество таких команд образует систему команд исполнителя.

В гимназических классах мы изучили исполнителей Кенгуренок и Муравей, разработанных в учебных целях для школ нашей страны, различных исполнителей в графических интерактивных средах программирования типа Logo, Scratch, Robo и др. Напомним, что исполнитель Кенгуренок может исполнять команды ШАГ, ПОВОРОТ, ПРЫЖОК, а исполнитель Муравей – команды ВВЕРХ, ВНИЗ, ВПРАВО, ВЛЕВО.

Существуют два режима управления исполнителями: ручной и автоматический.

Режим ручного управления предполагает, что ввод каждой команды приводит к ее немедленному выполнению исполнителем. Режим автоматического управления предполагает выполнение последовательности команд без вмешательства пользователя. Перед использованием автоматического режима алгоритм необходимо сначала написать и ввести его в память центра управления исполнителем.
   
Последовательность команд, предназначенная для автоматического управления исполнителем, называется программой. Очевидно, что программа представляет собой алгоритм, записанный на языке исполнителя. Процесс разработки программ называется программированием.

В гимназических классах мы разработали большое число программ для управления исполнителями Кенгуренок и Муравей: рисование квадратов, орнаментов и спиралей,
размещение символов в заданном порядке и др. Созданные нами программы были написаны на языке программирования и содержали простые команды ШАГ, ПОВОРОТ, ПРЫЖОК, ВВЕРХ, ВНИЗ, ВПРАВО, ВЛЕВО, вызовы процедур (подпрограмм) и составные команды ПОВТОРИ, ПОКА, ЕСЛИ.

Будучи разработанными в учебных целях, исполнители Кенгуренок и Муравей не могут обеспечить более сложную обработку информации. Очевидно, что для решения практических задач, возникающих в реальной жизни, нужны более мощные исполнители, а именно современные компьютеры.

Другими словами, компьютер является исполнителем, который выполняет в автоматическом режиме загруженные в его внутреннюю память программы. Напомним, что любая программа, загруженная во внутреннюю память компьютера, представляет собой последовательность двоичных слов, которая указывает компьютеру состав и порядок требуемых операций.

В качестве примера ниже приведен фрагмент программы, написанной на машинном языке:
```
10010101    10000011   00110100    01000100           
01010010    01011101   00010010    10010101           
11010010    01001100   00101001    01110100                    
00010101    01010100   11111010    10100011
```
          
Исторические ориентиры:
* 1955 – FORTAN (FORmula TRANslation)
* 1960 – ALGOL (ALGOritmic Language)
* 1960 – COBOL (COmmon Business Oriented  Language)
* 1971 – PASCAL (Blaise PASCAL)
* 1972 – C
* 1980 – C++
* 1995 - Java
   
Так как разработка программ в двоичных кодах является трудоемкой и неэффективной работой, алгоритмы, предназначенные для решения задач с помощью компьютера, целесообразно писать на специальных языках, называемых  языками высокого уровня. В процессе развития информатики были разработаны многие языки программирования высокого уровня. Их число в настоящее время достигает порядка восьми тысяч. Все же лишь небольшое их число широко используется, а в учебных целях самыми распространенными являются языки LOGO, BASIC, PASCAL, C, C++, Java. Эти языки содержат средства для написания и вызова подпрограмм, операторы для программирования линейных, разветвляющихся и циклических алгоритмов.

Для примера представляем программу, написанную на языке ПАСКАЛЬ/C++, которая вычисляет корни уравнения первой степени:

```C++
#include <iostream>
using namespace std;

int main() {
    float a = 2, b = 4;  // hardcoded values
    float x;

    if (a != 0) {
        x = -b / a;
        cout << "Уравнение имеет один корень" << endl;
        cout << x << endl;
    }
    if ((a == 0) && (b == 0)) {
        cout << "Уравнение имеет бесконечное множество корней" << endl;
    }
    if ((a == 0) && (b != 0)) {
        cout << "Уравнение не имеет смысла" << endl;
    }
    return 0;
}
```

Сравнив фрагмент программы, написанный на машинном языке, с программой Exemplu, можно убедиться, что применение языка высокого уровня, в данном примере – языка ПАСКАЛЬ/C++, значительно упрощает процесс разработки программ.
   
Обычно при использовании языков высокого уровня решение задачи с помощью компьютера включает следующие этапы:
1) описание алгоритма в общих чертах с помощью языка общения между людьми, например русского, румынского или английского;
2) если необходимо, более точное описание требуемых операций с помощью блок-схем;
3) написание алгоритма на одном из языков высокого уровня, например на ПАСКАЛЕ или на C++;
4) перевод программы с языка высокого уровня на машинный язык, то есть в последовательность двоичных слов;
5) обнаружение и исправление возможных ошибок и запуск программы на выполнение.

Перевод программ с языка высокого уровня на машинный язык называется компиляцией и осуществляется в автоматическом режиме с помощью специальных программ, называемых компиляторами. Для редактирования и отладки программ были разработаны специальные прикладные программы, называемые средами разработки программ.

Вопросы и упражнения
1. Вспомните по крайней мере три алгоритма, которые вы изучали на уроках математики и информатики
2. Какую информацию должно содержать полное описание определенного исполнителя?
3. Каковы основные средства, предназначенные для представления алгоритмов?
4. Чем отличается программный режим управления от ручного?
5. В чем состоит отличие алгоритма от программы? Обоснуйте свой ответ.
6.  Назовите основные этапы решения задач с помощью компьютеров.
7. Чем отличаются языки высокого уровня от машинных языков?
8. ИЗУЧИТЕ САМОСТОЯТЕЛЬНО ИЛИ ВМЕСТЕ С ОДНОКЛАССНИКАМИ! Поищите в Интернете и узнайте:
         •     мнения выдающихся людей из мира бизнеса, из сектора информационных технологий и коммуникаций об изучении программирования в школах;
         •     какие языки программирования изучают в школах во всем мире;
         •     процентное соотношение различных языков программирования, изучаемых в школах, в странах с традициями в этой области;
         •     процентное соотношение различных языков программирования, используемых в индустрии программного обеспечения (software);
         •     популярность языков программирования по индексу TIOBE. Аббревиатура TIOBE состоит из первых букв знаменитой комедии Оскара Уайльда The Importance Of Being Earnest («Как важно быть серьезным»).
9. ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ (индивидуально или в команде). Выберите два наиболее распространенных языка программирования: один используется в школах в учебных целях, а другой – в индустрии программного обеспечения. Сравните эти языки по следующим критериям: удобочитаемость, простота, информативность, интуитивность.



# Глава 1
## СЛОВАРЬ И СИНТАКСИС ЯЗЫКА ПАСКАЛЬ/C++
### 1.1. Знакомство с языком ПАСКАЛЬ/C++

Рассмотрим программу P1, написанную на C++:
```
// Программа P1
#include <iostream>
using namespace std;

// Сумма целых чисел x, y, z
int main() {
    int x, y, z, s;
    cout << "Введите целые числа x, y, z:" << endl;
    cin >> x >> y >> z;
    s = x + y + z;
    cout << "Сумма введенных чисел: ";
    cout << s << endl;
    return 0;
}

```

Числа 1, 2, 3, …, 14 в левой части страницы не являются частью представленной программы. Они служат только для цифрового обозначения объяснения значения каждой строки.

**Строка 1.** Однострочный комментарий начинается с символа «//». Комментарий никак не влияет на выполнение программы и предназначен исключительно для ползователя.
**Строка 2.** Директива #include. Эта директива вставляет в​​ текст программы P1 текст, содержащийся в файле iostream. Этот файл содержит описания подпрограмм, выполняющих ввод и вывод данных. Вообще говоря, программы на C++ могут использовать не только стандартные функции, но и функции, написанные другими программистами. Эти функции могут быть включены в разрабатываемую программу с помощью указания в директивах #include имен файлов, которые их содержат. Обычно в процессе разработки и отладки программ в среде разработки тексты, включенные в программу этими директивами, не отображаются.
**Строка 3.** Ключевые слова using namespace в этой строке указывают, что разрабатываемая программа должна использовать пространство имен std. Это пространство представляет собой описание идентификаторов, используемых в библиотеках, содержащих стандартные функции языка C++.
**Строка 4.** Пояснительный текст, комментарий.
**Строка 5.** Описание основной функции main. Эта функция должна появляться в любой программе на C++. Она является точкой, с которой программа запускается на выполнение, независимо оттого, где она находится в исходном коде.
**Строка 6.** Фигурная скобка { указывает на начало тела основной функции main.
**Строка 7.** Слово int (целое число) указывает тип соответствующих переменных. Следовательно, x, y, z и s могут иметь только целые числа в качестве значений.
**Строка 8.** Вывод на экран текста, заключенного в кавычках. Сами кавычки не являются частью текста, который будет отображаться. Слово cout (console output – вывод на консоль) – это имя потока данных (торрента), передаваемого программой стандартному устройству вывода. Символ << – оператор передачи информации. Подпрограмма, реализующая вывод данных, описана в файле iostream в стандартной библиотеке C ++, а имя cout является частью пространства имен std. Любой оператор C++ заканчивается символом ; (точка с запятой).

Слово endl (end line - конец строки) представляет собой манипулятор, который после отображения сообщения реализует переход на новую строку.
**Строка 9.** Считывание значений переменных x, y, z со стандартного устройства ввода, обычно – с клавиатуры. Слово cin (console input – консоль ввода) это имя потока данных (торрента), передаваемого в программу стандартным устройством ввода, а символ >> – оператор передачи информации. В процессе выполнения программы считываемые числа должны быть набраны в одной строке и разделены одним или несколькими пробелами. После ввода последнего числа нужно нажать клавишу <ENTER>.
**Строка 10.** Оператор присваивания. Переменная s получает значение x+y+z.
**Строка 11.** Отображение на стандартном устройстве вывода сообщения
```Сумма введенных чисел:```
**Строка 12.** Отображение значения переменной s на стандартном устройстве вывода.
**Строка 13.** Оператор return 0; (возврат 0;) имеет эффект завершения выполнения основной функции. Оператор return используется для передачи операционной системе кода, характеризующего способ, которым завершилось выполнение программы, 0 означает, что выполнение программы завершилось без ошибок. Это наиболее распространенный способ завершить программу на C++.
**Строка 14.** Фигурная скобка } обозначает конец исполняемой части функции main.

Таким образом, программа на языке C++ состоит из следующих компонентов:
* директивы (опционально);
* глобальные объявления (опционально), описывающие типы пользователей, переменные, константы и т. д., используемые в программе;
*  пользовательские функции (опционально);
* основная функция main (обязательно).

Специальные приложения, называемые средами разработки программ, напримеры такие как Code :: Blocks и Dev-Cpp, были разработаны для редактирования, компиляции и запуска программ C++.

Среды разработки программ предоставляют пользователям следующие возможности:
* ввод и редактирование программ;
* хранение программ в отдельных файлах;
* открытие, редактирование и сохранение файлов, содержащих разрабатываемые программы;
* обнаружение синтаксических ошибок;
* компиляция и запуск разрабатываемых программ;
* отладка программ.

Способы использования сред разработки программ на языках PASCAL и C++ опи-
саны в приложениях.

### Вопросы и упражнения
1. Введите и запустите на выполнение программу Р1.
2. Из каких основных частей состоит программа на языке ПАСКАЛЬ/ C++?
3. Введите и запустите на выполнение следующую программу:

```
// Программа P2
#include <iostream>
#include <limits>
using namespace std;

// Вывод предопределенной константы INT_MAX
int main() {
    cout << "INT_MAX = " << INT_MAX << endl;
    return 0;
}
```
4. Укажите заголовок, раздел объявлений и раздел операторов программы, представленной в качестве примера в этом параграфе. Объясните назначение каждой строки данной программы.
5. ПРИМЕНИТЕ! Измените программу P1 (приведенную в качестве примера в данном параграфе) таким образом, чтобы она выводила на экран текст:
```
                По тонкому лучу скользни
                Из непомерной дали,
                Чтоб помыслы мои и дни
                Тобою засверкали.
           („Luceafărul”, Mihai Eminescu, Перевод Ю.Кожевникова)
```
6. ПРИМЕНИТЕ! Измените программу P1 (приведенную в качестве примера в данном параграфе) таким образом, чтобы она вычислила сумму чисел x, y, введенных с клавиатуры.
7.	 ОБРАТИТЕ ВНИМАНИЕ! Сохраните на своем компьютере программу, разработанную в задании 6. Обратите внимание, какое расширение имеет исходный файл.
8. ИЗУЧИТЕ САМОСТОЯТЕЛЬНО ИЛИ ВМЕСТЕ С ОДНОКЛАССНИКАМИ! Поищите в Интернете и узнайте:
* какие языки программирования существуют и как они развивались.

Заполните таблицу:
| Поколение | Язык программирования |
|-----------|------------------------|
|           |                        |
|           |                        |
|           |                        |
|           |                        |

* от каких часто используемых языков программирования произошли новые языки?
* определите пять наиболее часто используемых языков программирования;
* откуда произошло название языка программирования, который вы изучаете?


### 1.2. Метаязык БНФ
Любой язык программирования определяется через синтаксис и семантику. Известно, что синтаксис – это совокупность правил, которые задают структуру предложений, а семантика – это совокупность правил, определяющих смысл и значение соответствующих предложений. В случае языков программирования эквивалентом предложения является программа.

Ясно, что синтаксис любого языка программирования может быть описан с помощью одного из языков общения между людьми, например русского, румынского, английского, французского и т.д. Однако такого рода описание будет объемным и может оказаться двусмысленным. Поэтому для лаконичного и точного описания синтаксиса языков программирования были разработаны специальные языки, называемые метаязыками. Самым распространенным метаязыком является метаязык БНФ – формы Бэкуса-Наура.

Метаязык БНФ использует следующие символы:
**терминальные символы** – символы, из которых состоит программа на языке ПАСКАЛЬ/C++;
**нетерминальные символы** – символы, которые обозначают грамматические единицы (конструкции) языка.

Нетерминальные символы записываются между знаками “<” и “>”.
Например, цифры 0, 1, 2 …, 9, буквы A, B, C, …, Z являются терминальными символами, а <Цифра>, <Буква> являютсянетерминальными символами.

Описание синтаксиса языка программирования состоит из совокупности металингвистических формул.

Под металингвистической формулой будем понимать конструкцию, состоящую из двух частей: левой и правой, разделенных символами: “::=”, что означает «является по определению». В левой части формулы находится нетерминальный символ.

В правой части металингвистической формулы с помощью символа “|”, означающего «или», описываются все возможные варианты определения нетерминального символа.

Например, формула
<Цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
определяет грамматическую единицу <Цифра> как один из терминальных символов: 0, 1, …, 9.

Таким же образом интерпретируется металингвистическая формула:
<Буква> ::=   a | b | c | d | e | f | g | h | i | j | k | l |m |
              n | o | p | q | r | s | t | u | v | w | x | y | z

В правой части металингвистической формулы может быть указана последовательность из двух и более символов. Такая запись соответствует операции конкатенации (присоединения).

В частности, формула
<Ид> ::= <Буква> <Цифра>
определяет грамматическую конструкцию <Ид> как букву, за которой следует цифра.

Пример:
1. a9
2. a1
3. c3
4. x4
5. d0
6. e8

В случае, если некоторая часть определения нетерминального символа может отсутствовать или повторяться произвольное число раз, она заключается в фигурные скобки {, }.

Например, формула
<Целое без знака> ::= <Цифра> {<Цифра>}
определяет нетерминальный символ <Целое без знака> как непустую последовательность цифр. Последовательности 0, 0000, 001, 1900, 35910 соответствуют данному определению, а последовательность 3а5910 – не соответствует.

Формула
<Идентификатор> ::= <Буква> {<Буква> | <Цифра>}
указывает, что идентификатор всегда начинается с буквы, после которой может следовать конечная последовательность из букв и цифр. Например, a, a1, a1b, a23x, a14bxz, ab5 соответствуют данной формуле, а 2а – не соответствует.

В случае, когда некоторая часть определения нетерминального символа может отсутствовать или присутствовать ровно один раз, она заключаются в квадратные скобки: [, ].
   
Например, формула
<Масштабный множитель> ::= [+ | –] <Целое без знака>
определяет масштабный множитель как целое число без знака, которому может предшествовать + или –. Например: 1, +1, -1, 20, +20, -20, +003 соответствуют данной формуле, а 3-5 – не соответствуют.

Обратим внимание на то, что символы [, ], {, } принадлежат метаязыку и их не следует путать с соответствующими символами, используемыми в программах на языке ПАСКАЛЬ.


## Вопросы и упражнения
1.	 Дайте объяснение терминам синтаксис и семантика.
2.	 Для чего предназначен метаязык?
3.	 Как задается синтаксис любого языка программирования с помощью метаязыка БНФ?
4.	 ПРИМЕНИТЕ! Синтаксис некоторого простого языка программирования описан с помощью следующих металингвистических формул:
     <Цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
     <Число> ::= <Цифра> {<Цифра>}
     <Знак> ::= + | –
     <Арифметическое выражение> ::= <Число> {<Знак><Число>}

Какие из приведенных ниже последовательностей соответствуют определению лексической единицы <Число>?
a. 0  
b. 1  
c. 11100  
d. 00011  
e. 20013  
f. 0+0  
g. 11100+1  
h. 11100–1  
i. 931  
j. 614  
k. 0000  
l. 0001  
m. –152  
n. +351  
o. 412  

Какие из нижеприведенных последовательностей соответствуют определению лексической единицы <Арифметическое выражение>?
a. 0+1  
b. 1+0–3  
c. 0+0+4  
d. 1+1–9  
e. 6+6+21  
f. –13  
g. 21+–16  
h. –21–16  
i. 68–13  
j. 42+650  
k. 21+00000  
l. 39+00001  
m. 00001–00001  
n. 379–486  
o. 31+12–51+861  

5. 	Синтаксис некоторого языка общения компьютер – пользователь задается следующим образом:
<Диск> ::= A: | B: | C: | D: | E:
<Список параметров > ::= <Диск> {, <Диск>}
<Название команды> ::= Считывание | Копирование | Форматирование
<Оператор> ::= <Название команды><Список параметров>


Какие из нижеприведенных последовательностей соответствуют определению лексической единицы <Оператор>?
a. Считывание  
b. Считывание A:  
c. Копирование F:  
d. Копирование A:, Конкатенация: D:, E:  
e. Форматирование  
f. Копирование A: B:  
g. Считывание D  
h. Форматирование D:, F:  
i. Копирование E:, A:,  
j. Копирование F:, A:  


![My Image](https://drive.google.com/uc?export=view&id=1dCN9JlGTmuUw_0mi0fC3R9LIEPn3X2V3)




Рис. 1.1. Представление формул БНФ с помощью синтаксических диаграмм

### 1.3. Синтаксические диаграммы
Синтаксические диаграммы более наглядно описывают синтаксис языков программирования. Диаграммы составляются в соответствии с формулами БНФ.

Каждому терминальному символу на синтаксических диаграммах должен соответствовать круг или овал, в который вписывается соответствующий символ. Нетерминальные символы заключаются в прямоугольник. Овалы и прямоугольники объединяются согласно синтаксическим диаграммам, приведенным на рис.1.1.

На рис. 1.2 показаны синтаксические диаграммы для грамматических единиц <Целое без знака>, <Идентификатор> <Целое без знака>и <Масштабный множитель>, определенных в предыду-
щем параграфе.    Отметим, <Целое        что каждому пути диаграммы соответствует синтаксически без знака> правильная последовательность терминальных символов.

![My Image](https://drive.google.com/uc?export=view&id=1Tw1X6q-msHvMSamqmV9UnuVX5UJJchHM)






Рис. 1.2. Синтаксические диаграммы <Целое без знака>, <Идентификатор> и <Масштабный множитель>

### Вопросы и упражнения
1.	Для чего предназначены синтаксические диаграммы?
2.	Как представляются терминальные и нетерминальные символы в синтаксических диаграммах?
3.	Как представляются формулы БНФ в виде синтаксических диаграмм?
4.	Представьте в виде синтаксических диаграмм:
<Цифра> :: = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<Число> :: = <Цифра> {<Цифра>}
<Знак> ::= +|–
<Expresie aritmetică> ::= <Число>{<Знак><Число>}
5. 	Reprezentaţi cu ajutorul diagramelor sintactice:
<Диск> ::= A: | B: | C: | D: | E:
<Список параметров > ::= <Диск> {, <Диск>}
<Название команды> ::= Считывание | Копирование | Форматирование
<Оператор> ::= <Название команды><Список параметров>
6. На рис. 1.3 представлены синтаксические диаграммы, которые определяют грамматическую единицу <Дробное число>. Определите, какие из нижеприведенных примеров соответствуют данным диаграммам:
a. 0.1  
b. +0.1  
c. –0.0  
d. 9.000  
e. –538.  
f. .538  
g. 721.386  
h. –421  
i. 247.532  
j. +109.000  
7. 	Напишите   формулы БНФ, соответствующие синтаксическим диаграммам рис. 1.3.

![My Image](https://drive.google.com/uc?export=view&id=1V83oq0yW2fMRrO-Tp8CdttGcztcERdLB)


Рис. 1.3. Синтаксические диаграммы <Цифра>, <Последовательность цифр>, <Дробное число>


##     1.4. Алфавит языка
Алфавит языка ПАСКАЛЬ/ C++ состоит из следующих символов кода ASCII (American Standard Code for Information Interchange):
*	 десятичные цифры;
*	 прописные и строчные буквы латинского алфавита;
*	 знаки препинания;
*	 арифметические и логические операторы;
*	 управляющие символы (пробел, конец строки или возврат каретки и т. д.).

В некоторых конструкциях языка могут использоваться и буквы национальных алфавитов, например, буквы ă, â, î, ş, ţ румынского алфавита, буквы русского алфавита и др.

Язык C++, предназначенный для профессиональных программистов, использует некоторые символы, которые не встречаются в стандартном языке PASCAL, например: _ (underscore, подчеркивание, нижняя строка), ~ (тильда), ^ (каретка), \ (backslash, обратная косая черта) и др.



## 1.5. Словарь языка
Самые простые элементы языка программирования, составленные из символов и имеющие лингвистическое значение, называются лексемами или лексическими единицами. Они и составляют словарь языка.

Существуют следующие лексические единицы:
*	 специальные символы и ключевые слова;		      
*    строки символов;
*	 идентификаторы;					
*    метки;
*	 числа;						
*    директивы.



### 1.5.1. Специальные символы и ключевые слова
Специальные символы состоят из одного или двух символов:
```
+      плюс  
–      минус  
*      звездочка  
/      наклонная черта  
==     равно  
,      запятая  
:      двоеточие  
.      точка  
@      коммерческое at  
{      левая фигурная скобка  
}      правая фигурная скобка  
#      номер  
%      процент  
\n     новая строка  
\"     кавычки  
'      апостроф  
<      меньше  
>      больше  
[      левая квадратная скобка  
]      правая квадратная скобка  
(      левая круглая скобка  
)      правая круглая скобка  
;      точка с запятой  
^      циркумфлекс  
$      доллар  
<=     меньше либо равно  
>=     больше либо равно  
=      присваивание  
!=     не равно  
\b     Backspace (возврат на одну позицию)  
```

Отметим, что специальные символы как в языке ПАСКАЛЬ, так и в C++, состоящие из двух знаков, например <= или :=, не допускают “вклинивания” промежуточных пробелов.
   
Ключевые слова состоят из двух или более букв. В нижеследующей таблице приведены примеры ключевых слов:

``` c++
auto       автоматически  
break      прыжок  
case       выбор  
char       caractere  
const      константа  
continue   продолжать  
default    по умолчанию  
delete     удалить  
do         делать  
double     двойной  
else       иначе  
enum       перечисление  
extern     внешний  
float      плавающий  
for        для  
goto       перейти к  
if         если  
inline     в линию  
int        целый  
long       длинный  
near       возле  
new        новый  
private    частный  
return     возврат  
short      короткий  
signed     со знаком  
sizeof     размер  
static     статический  
struct     структура  
switch     переключатель  
typedef    определение типа  
union      объединение  
unsigned   беззнаковый  
void       пустой  
volatile   изменчивый  
while      пока  
```

Как в языке ПАСКАЛЬ, так и в C++ ключевые слова являются зарезервированными и не могут использоваться с целью, отличной от той, которая предназначена им по определению языка.

Лексические единицы, рассматриваемые в данном параграфе, могут быть определены следующими формулами БНФ:

```
<Специальный символ> ::= + | – | * | / | = | < | > | ] | [ | , | ( | )
			| : | ; | ” | . | & | { | } | $ | # | <= | >= |
			<> | != | % | <Ключевое слово>
<Ключевое слово>::= auto | asm | bool | break |case | catch |
            char | const | continue | class | default |
            delete | do | double | elsa | enum | extern |
            float | for | friend | goto | if | inline |
            int | long | namespace | new | operator |
            private | public | protected | plate |
            register | return | short | signed | sizeof |
            static | struct | switch | typedef | union |
            unsigned | using | void | volatile | virtual|
            while
```

Символы {, }, [ и ], используемые в формулах БНФ, являются одновременно и элементами языка ПАСКАЛЬ. Чтобы избежать двусмысленности, данные символы как элементы словаря могут быть представлены через эквивалентные символы (*, *) и соответственно (., .).

Важно!
*	 Символы {, }, [ и ], используемые в нотации BNF, являются одновременно элементами словаря C++.
*	 В языке C++ все зарезервированные слова пишутся только строчными буквами.
*	 В зависимости от используемого компилятора этот может содержать другие специфические ключевые слова.


### Вопросы и упражнения
1.	 Запомните ключевые слова языка ПАСКАЛЬ/C++.
2.	 В чем разница между символами и специальными символами?
3.	 Постройте синтаксические диаграммы для лексических единиц: <Специальный символ>, <Эквивалентный символ>, <Ключевое слово>.
4.	 ИЗУЧИТЕ САМОСТОЯТЕЛЬНО ИЛИ ВМЕСТЕ С ОДНОКЛАССНИКАМИ! Найдите в Интернете ответы на следующие вопросы :
*	 Сколько специальных символов содержит изучаемый язык программирования?
*	 Сколько ключевых слов содержит изучаемый язык программирования?
*	 Выберите любой другой язык программирования и определите раз-личия между количеством специальных символов и ключевых слов. Как вы думаете, каким образом их количество влияет на эффективность процессов разработки и выполнения программ?



### 1.5.2. Идентификаторы
Идентификаторы – это лексические единицы, которые выступают в качестве имен переменных, констант, функций, программ и т. д.
   
Любой идентификатор начинается с буквы, за которой может следовать любая комбинация из букв и цифр. Длина идентификаторов не ограничена, но только первые 63 символа являются значимыми.

Напомним формулы БНФ, определяющие лексическую единицу <Идентификатор>:
<Цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<Буква> ::=	 a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
<Идентификатор> ::= <Буква> { <Буква> | <Цифра> }

Примеры Идентификаторов:
1. x  
2. y  
3. z  
4. x1  
5. y10  
6. z01b  
7. lista  
8. listaelevilor  
9. listatelefoanelor  
10. registru  
11. adresa  
12. adresadomiciliu  
13. casa10  
14. anul2020  

Использование прописных и строчных букв позволяет записывать идентификаторы в форме, удобной для чтения, например:
1. ListaElevilor  
2. ListaTelefoanelor  
3. AdresaDomiciliu  
4. BugetulAnului2020  

Отметим, что в основных конструкциях языка ПАСКАЛЬ и C++ не используются
буквы, присущие русскому алфавиту, и буквы ă, â, î, ş, ţ румынского алфавита.
Они заменяются на соответствующие буквы латинского алфавита:

Примеры:
1. Suprafata  
2. Numar  
3. NumarElevi  
4. Patrat  
5. SirDeCaractere  
6. NumarIncercari  

```
ПРИМЕЧАНИЯ
В грамматических конструкциях языка ПАСКАЛЬ, за исключением строк символов,прописные и строчные буквы считаются эквивалентными. Следовательно, в языке ПАСКАЛЬ идентификаторы ANM, AnM, Anm, aNM и Anm идентичны.
Язык C++ чувствителен к регистру, то есть он различает строчные и прописные буквы. Поэтому в C++ идентификаторы ANM, AnM, Anm, aNM и AnM различны.
В языке C++ и в некоторых реализациях языка ПАСКАЛЬ идентификаторы могут содержать и даже начинаться с символа «_» (underscore, подчеркивание, по́дчерк).
```


### Вопросы и упражнения
1.	 Нарисуйте синтаксические диаграммы для грамматических единиц <Цифра>, <Буква> и <Идентификатор>.
2.	 ПРОАНАЛИЗИРУЙТЕ! Какие из нижеприведенных примеров соответствуют определению лексической единицы <Идентификатор>:
a. x1  
b. X1  
c. 1x  
d. 1X  
e. xy  
f. Suprafata  
g. SUPRAFATA  
h. rădăcina  
i. radacina  
j. R1  
k. A1x  
l. ListaA  
m. Lista1  
n. B-1  
o. abc  
p. Dreptunghi  
q. iI  
r. I1j  
s. Luni  
t. Luna  
u. 20.07.2020  

Для последовательностей символов, соответствующих определению идентификатора, укажите соответствующий путь в синтаксической диаграмме <Идентификатор>.
3. ПРОАНАЛИЗИРУЙТЕ! Найдите пары эквивалентных идентификаторов (в языке ПАСКАЛЬ)::
a. x101  
b. ya15  
c. radacinaX1  
d. radacinaX2  
e. triunghi  
f. cerc  
g. sirdecaractere  
h. registruclasa10  
i. COTIDIAN  
j. ZILE  
k. CERCURI  
l. SirDeCaractere  
m. Triunghiuri  
n. RegistruClasa10  
o. zilE  
p. X101  
q. RegistruClasa10  
r. radaciniX1X2  
s. RADACINAX1  
t. yA101  


4.	 Для чего предназначены идентификаторы?
5.	 ПРИМЕНИТЕ! Предложите идентификаторы для хранения данных из нижеследующей таблицы.

| Данные                     | Идентификаторы           |
|-----------------------------|-------------------------|
| Рост человека               |                         |
| Возраст человека в годах    |                         |
| Длина радиуса круга         |                         |
| Периметр прямоугольника     |                         |


6.	 Для нахождения корней х1, х2 квадратного уравнения ах2 + bх + с = 0 сначала находится дискриминант d. Предложите несколько вариантов представления коэффициентов а, b, с, дискриминанта d и решений х1, х2 посредством идентификаторов.


# 1.5.3. Числа
Числа могут быть целыми или вещественными. Обычно используется десятичная система счисления. На рис. 1.4 показаны синтаксические диаграммы для лексических единиц <Целое число> и <Вещественное число>.

Примеры целых чисел:
```cpp
23
–23
0023
+023
318
00318
+0318
–318
1996
+1996
–1996
0001996
–0023
–0318
+001996
-000199
```
В случае вещественных чисел дробная часть отделяется от целой точкой.Перед десятичной точкой должна стоять, по крайней мере, одна десятичная цифра.

Примеры вещественных чисел:
```cpp
3.1415
+3.04
0.0001
283.19
–3.04
–0.0001
–256.19
28.17
+0.0001
6.28
+3.12421
4563906.734
```
При записи вещественных чисел можно использовать масштабный множитель. Масштабный множитель представляет собой целое число, перед которым ставится буква е (или Е), и означает, что число, за которым он следует, умножается на 10 в соответствующей степени.


## image
Рис. 1.4. Синтаксические диаграммы <Целое число> и <Вещественное число>

Примеры:
| №  | Обычная форма записи       | Запись на языке ПАСКАЛЬ/C++ |
|----|----------------------------|------------------------------|
| 1  | 8,12 · 10⁻⁵                | 8.12e–5                      |
| 2  | 749,512 · 10⁸              | 749.512e+8                   |
| 3  | –0,0823 · 10⁻¹²            | –0.0823e–12                  |
| 4  | 3250,4 · 10⁶               | 3250.4e06                    |
| 5  | 3,421 · 10¹⁶               | 3.421e16                     |

Очевидно, что 8.12е-5, 812е-7, 0.812е-4, 81.2е-6 представляют одно и тоже значение 8,12 ·10 .

ПРИМЕЧАНИЕ
В языке C++ при записи действительных чисел целая либо дробная часть может отсутствовать, однако не одновременно. Например, «.021» и «318.» – это правильно записанные числа.


### Вопросы и упражнения
1. ПРОАНАЛИЗИРУЙТЕ! Какие из нижеприведенных примеров соответствуют определению лексической единицы <Целое число>?

a) –418
b) 0–418
c) 621+
d) 2469
e) –6210
f) 0+2469
g) 32,14
h) +00621
i) 24693.
j) –621
k) 32,014
l) –719
m) +62.1
n) –00418
o) –00621

Найдите целые числа с одним и тем же значением.

2. С помощью синтаксических диаграмм рис. 1.4 напишите формулы БНФ для определения лексической единицы <Целое число>.

3. ПРОАНАЛИЗИРУЙТЕ И ПРИМЕНИТЕ! Какие из нижеприведенных примеров соответствуют определению лексической единицы <Вещественное число>?
a)	 3.14
b)	 2.514e+5
c)	 591328E+3
d)	 .000382
e)	 0.1961E+4
f)	 +314629.
g)	 0.000314E4
h)	 281.3
i)	 591328
j)	 2514e+2
k)	 –464.597e+3
l)	 +519.328e–4
m)	 591328e–3
n)	 28130e–2
o)	 0,618284e00
p)	 1961.
q)	 28130E–2
r)	 591.328
s)	 –658.14e–6
t)	 2514e+2
u)	 618.248e–3

Найдите вещественные числа, которые имеют одно и то же значение. Запишите данные числа в обычном виде.


4. С помощью синтаксических диаграмм рис. 1.4 напишите формулы БНФ для определения лексической единицы <Вещественное число>.

5. ПРОАНАЛИЗИРУЙТЕ! Укажите на синтаксических диаграммах рис. 1.4 пути, которые соответствуют следующим числам:

a)	 –418
b)	 1961.0
c)	 2514E+2
d)	 281.3
e)	 2.514e+5
f)	 –1951.12
g)	 32.014
h)	 591.328
i)	 +19.511e+2
j)	 +0001
k)	 –614.85e–3
l)	 2013e–4



## 1.5.4. Строки символов

Строки символов – это последовательность печатных символов, заключенная в кавычки. Односимвольная строка может быть разграничена апострофом. Подчеркнем, что в случае строк символов прописные и строчные буквы отображаются как различные символы.

## image

Рис. 1.5*. Синтаксическая диаграмма <Строка символов>, язык C++

Примеры:
1)	”Переменная x”
2)	”Примерный расчет”	
3)	”Апостроф \’ ”
4)	’B’

В языке C++ буквы ă, â, î, ș, ț румынского алфавита также могут использоваться в строках. Для этого необходимо будет использовать специальные библиотеки, обеспечивающие ввод, отображение и печать соответствующих букв.
   
Лексическая единица <Строка символов> определяется с помощью следующих
формул BNF:
  
<Строка символов> ::= ”<Элемент строки> {<Элемент строки>} ”
<Элемент строки> ::= ” ”| <Любой печатный символ>
Синтаксическая диаграмма этой лексической единицы представлена на рисунке 1.5*.

### Вопросы и упражнения
1. ПРОАНАЛИЗИРУЙТЕ! Укажите на синтаксических диаграммах рис. 1.5 (Язык ПАСКАЛЬ) и соответственно рис. 1.5* (Язык C++) пути, которые соответствуют следующим строкам:

```C++
a)   ”переменная z”
b)   ”\'”
c)   ” Символы ’x’, ’y’ ”
d)   ”ЛЕКСИЧЕСКИЕ ЕДИНИЦЫ”
```

2. ПРОАНАЛИЗИРУЙТЕ! Какие из нижеприведенных примеров соответствуют определению лексической единицы <Строка символов>:

 C++
```cpp
a)   ”Целое число”
b)   ”Конец программы”
c)   ”АПОСТРОФ”
d)   ”’x’”
e)   ”функция”
f)   ”Год 1997”
g)   ”Квадратный корень”
h)   ”Год \’97”
i)   ”Список телефонов”
j)   ’’’
```

3. ПРОАНАЛИЗИРУЙТЕ! Исследуйте нижеприведенный пример, запустите программу на выполнение, обратите внимание на полученные результаты.

C++
```cpp
#include <iostream>
using namespace std;
int main()
{
  cout<<″Здравствуйте!″<<endl;
  cout<<″Сегодня прекрасный день!″;
  return 0;
}
```
4.	ПРИМЕНИТЕ! Измените программу из задания 3 таким образом, чтобы на экран выводились следующие строки символов:
```cpp
Это апостроф ’
Мне нравится программировать!
```


## 1.5.5. Метки
Чтобы перейти к определенному оператору, его необходимо каким-то образом пометить. Делается это с помощью меток.

В C ++ метка состоит из идентификатора, за которым следует символ: (двоеточие). Метки имеют собственное пространство имен (один и тот же идентификатор может
использоваться для метки и переменной, без пересечения). Метки имеют в качестве области видимости все тело функции, в которой они появляются, и распознаются только оператором перехода goto. В любом другом контексте помеченный оператор выполняется независимо от наличия метки.
```
Suma1:      Calcul:       Afisare:     Citire:      Produs:
```
Формула БНФ, которая определяет данную лексическую единицу, имеет вид:
```cpp
<Метка> ::= <Идентификатор><:>
```  
Пример:
#include <iostream>
using namespace std;
```cpp
int main() {
    int a;
    cout << "a = ";
    cin >> a;

    if (a > 0) goto pozitiv;
    if (a < 0) goto negativ;
    if (a == 0) goto zero;

pozitiv:
    cout << "положительное число";
    goto Final;

negativ:
    cout << "отрицательное число";
    goto Final;

zero:
    cout << "число, равное нулю";

Final:
    cout << "\nПрограмма закончена";
    return 0;
}
```

## 1.5.6. Директивы


Директивы – это зарезервированные слова, которые имеют специальное назначение. Лексическая единица <Директива> определяется точно так же, как идентификатор:
```
<Директива> ::= <Буква> {<Буква> | <Цифра>}
```
Обработка исходного текста программы перед этапом компиляции называется предварительной обработкой, а программа, осуществляющая такую обработку, называется препроцессором. Обычно препроцессор является частью компилятора.

В языке C++ информация о том, как должен быть обработан текст программы перед ее компиляцией, передается с помощью директив предварительной обработки. Они распознаются препроцессором по наличию символа # (диез).

Включение в текст программы копий других исходных файлов осуществляется с помощью директивы #include, имеющей две формы:

```
#include <имя_файла>
```
или
```
#include “имя_файла”
```   
Обе формы в качестве эффекта имеют включение файла, указанного в директиве, в файл, который содержит эту директиву. Различие между двумя формами состоит в месте, где выполняется поиск исходного файла. В первом случае файл ищется в стандартных каталогах (заданных параметрами или переменными среды, в зависимости от компилятора). Во втором случае файл ищется сначала в текущем каталоге, а затем, если он не найден, в стандартных каталогах. Вторая форма также позволяет указать полный путь к подключаемому файлу, что исключает поиск в стандартных каталогах.

Примеры:
```
#include <stdio> 
```
– указывает препроцессору включить файл stdio из стандартного каталога.
```
#include ”Matrice”
``` 
– указывает препроцессору включить файл Matrice, который ищется сначала в текущем каталоге, а затем, если он не найден, в стандартных каталогах.
```
#include ”C:\ProgrameleMele\Vectori.cpp” 
```
– указывает препроцессору включить файл Vectori.cpp из каталога C:\Programe. Если файл не найден, он не будет где-либо искаться и генерируется сообщение об ошибке.

В целом язык C++ содержит более десяти директив предварительной обработки. Эти директивы изучаются в углубленных курсах информатики.

## 1.6. Разделители
Любая программа на языке ПАСКАЛЬ или C++ состоит из лексических единиц и разделителей. В качестве разделителей используются: пробел, конец строки (возврат
каретки) и комментарий.

Примеры:
C++
```cpp
1)   x/y
2)   !x
3)   a || b
     {
     cout<<x<<endl;
4)   cout<<y<<endl;
}
```
При отсутствии разделителей, при последовательном написании идентификаторов, ключевых слов, чисел без знака и директив, начало новой лексической единицы может быть интерпретировано как продолжение предыдущей.
   
В частности, в языке ПАСКАЛЬ, в первом примере запись “x div y” сообщает компьютеру “раздели переменную x на переменную y”. При отсутствии же разделительных пробелов запись “xdivy” будет воспринята компьютером как идентификатор.

Отметим, что как в языке ПАСКАЛЬ, так и в C++ используются специальные символы, состоящие из двух знаков: <=, >=, и т. д., ключевые слова, идентификаторы, числа и т. д. являются лексическими единицами программы. Очевидно, что вставка пробелов или символов возврата каретки внутри составных лексических единиц недопустима.

Примеры:

C++
Правильно	       Неправильно	
```cpp
1)	 CitireDisc	     Citire Disc

2)	 typedef	        type def

3)	 ==		          = =

4)	 !=		          ! =

5)	 345		          3 45

6)	 while		      whi le

7)	 endl		         end l
```
Комментарии – это тексты, которые могут быть введены в исходную программу, но не рассматриваются компилятором и поэтому не оказывают никакого воздействия на выполнение программы. Комментарии полезны для лучшего понимания программы теми, кто ее читает.

В языке C++ комментарии можно использовать в программах в виде последовательности символов, заключенной внутри пар символов /* и */ . Такой комментарий можно писать в нескольких строках.

Если нужно написать короткий комментарий, помещающийся в одной строке, тогда перед ним записываются символы //.

Примеры:
1)	 // Ввод исходных данных
2)	 /* Введенные с клавиатуры числа должны быть меньше 1000 **/

Отметим, что рациональное использование комментариев, пробелов и символов возврата каретки делает программы удобными для чтения.


# Тест для самопроверки № 1
1. 	Синтаксис языка программирования исполнителя Робот описан с помощью следующих металингвистических формул:
```bnf
<Цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<Число> ::= <Цифра> {<Цифра>}
<Команда> ::= вверх | вниз | вправо | влево
<Оператор> ::= <Команда>(<Число>)
<Программа> ::= начало {< Оператор >;} конец
```
Укажите синтаксически правильные программы:
```
a) начало вверх(1); вправо(4); вниз(0); влево(00); конец
b) начало вверх(1); вправо(73); вниз(0); влево(00+23); конец
c) начало вниз(30); вправо(45); вверх(980); конец
d) начало влево(21); вниз(50); вправо(45); вверх(980); конец
e) начало влево(3); вниз(13); влево(21) конец; конец
f) начало вниз(73); вправо(5); вверх(71) влево(13); конец
g) начало вверх(1); вправо(-4); вниз(0); влево(10950); конец
```

2. Нарисуйте синтаксические диаграммы, соответствующие металингвистическим формулам <Команда>, <Оператор> и <Программа> из задания 1.

3. На нижеследующем рисунке представлены синтаксические диаграммы, определяющие грамматическую единицу <Восьмеричное число>.

Определите, какие из нижеприведенных последовательностей символов записаны в соответствии с данными диаграммами:
a) +0
b) 18
c) -17250
d) +6362,1
e) 717424410571
f) -34637
g) 2347-523
h) -0000007
i) 527345372
j) 614.45
k) +123146482351
l) 614,45
m) –152
n) +35,1
o) -412
  
## image

4. Запишите металингвистические формулы, соответствующие синтакси-
ческим диаграммам из задания 3.

5. В языках ПАСКАЛЬ и C++ идентификатор начинается с буквы, за которой может следовать любая комбинация из букв и цифр. Напишите металингвистические формулы, определяющие лексическую единицу <Идентификатор>.

6. Придумайте и запишите по крайней мере десять идентификаторов, отражающих специфику физических, математических, химических задач, а также задач по обработке текстов и изображений.

7. Запишите в соответствии с правилами языка ПАСКАЛЬ (или C++) следующие, представленные в обычном виде числа:
     a) 3,14
b) 265
c) 23,4635
d) +0,000001
e) 6,1532 ⋅ 10⁻⁵
f) –984,52
g) –523
h) +28
i) +28000000
j) 614,45 ⋅ 10⁻¹²
k) –3628,297·10¹²
l) –38,00001
m) 35728,345452 ·10⁻⁸
n) 24815
o) –296,0020001.

8. Запишите в обычном виде следующие числа, представленные в соответствии с правилами языка ПАСКАЛЬ/C++:
     a) 6124.485
b) +18.315
c) -218.034e-3
d) 193526
e) 1000.01e+23
f) -0.03428e-08
g) 232847.5213
h) -0000012e+2
i) 18.45
j) 623.495e-6
k) 2005
l) +23.08e-5
m) –17502
n) +1
o) -46341.2e-06

9. Известно, что словарь языков ПАСКАЛЬ и C++ включает следующие лексические единицы: специальные символы и ключевые слова, идентификаторы, числа, строки символов, метки, директивы. Укажите лексические единицы, присутствующие в нижеприведенной программе:

C++
```cpp
#include <iostream>
using namespace std;
int main ()
{
float a, b, x;
cin>>a>>b;
if (a!=0)
  {
  x=-b/a;
  cout<<”Уравнение имеет один корень”<<endl;
  cout<<x;
  }
if ((a==0) && (b==0))
  {
    cout<<”Уравнение имеет бесконечное множество корней”<<endl;}
if ((a==0) && (b!=0))
  {
    cout<<”Уравнение не имеет смысла”<<endl;
  }
return 0;
}
```

Пример (C++): #include – директива; < и > – специальные символы; iostream – имя файла; using namespace std – оператор; ; – специальный символ; int – ключевое слово и т.д.

(C++) Укажите директивы, декларативную часть и основную функцию програм-
мы, представленной в задании 9.

11. Нижеследующая программа содержит ошибки. Выявите ошибки, исправьте
их и запустите программу на выполнение.

C++
```cpp
*/ Зима-Василе Александри, перевод В. Луговского //
#include <stream>
int main
{
cout << ″Пали с неба тучи снега″,
cout >> ″ зимний ветер полон злобы, ″;
cout << ″ endl;″
cout << ’Громоздятся над полями странствующие сугробы. ’ <<
endl;
return 0;
)
```

# ПРОСТЫЕ ТИПЫ ДАННЫХ

## 2.1. Концепция данных
Информация, подлежащая обработке, представлена в компьютере в виде данных. Данные состоят из цифр, букв, знаков, чисел, строк и др.

В машинном коде компьютера данные представляются как последовательности двоичных цифр. Например, на языке процессора натуральное число 1039 представляется в двоичной системе счисления как:
```
10000001111
```
   
Для того чтобы избавить пользователя от деталей внутреннего представления данных, в языках программирования используются различные типы данных.
   
Под типом данных понимается множество значений и множество операций, которые можно к ним применить.

Изучая языки программирования, вы узнаете и будете применять основные предопределенные типы данных (стандартные), а также научитесь создавать свои собственные типы.
   
Ниже приведены некоторые предопределенные (стандартные) типы данных:
```C++
char
int
float
bool
```
Тип данных integer/int. Для эффективного использования памяти и учета потребностей большого числа приложений существует несколько типов целых и вещественных чисел (расширений), которые различаются выделенной памятью и, следовательно, диапазоном значений.

Например, в версиях языков программирования, в которых компилятор поддерживает только двухбайтовые целые числа, т.е. 16 бит (например, Borland C ++, Turbo Pascal 7.0), тип данных integer/int будет включать множество целых чисел:
```cpp
{-32768, -32767, ..., -2, -1, 0, 1, 2, ..., 32767}.
```
Отметим, что есть компиляторы, которые выделяют для представления целых чисел 4 байта, то есть 32 бита (например, DELPHI, OBJFPC, Linux). Аналогично для вещественных типов данных в разных компиляторах выделенное пространство может быть разным, соответственно их диапазоны значений будут разными.

С целыми числами можно осуществлять следующие операции:
| Операция               | C++  |
|-------------------------|------|
| Сложение                | +    |
| Вычитание               | -    |
| Умножение               | *    |
| Остаток от деления      | %    |
| Целочисленное деление   | /    |

Тип данных real/float включает подмножество множества вещественных чисел, с которыми выполняются операции +, -, *, / (деление) и др.
   
Как и в случае с целыми числами, объем памяти, выделенной для вещественного значения, зависит от используемого компилятора. В языке программирования C++ объем памяти, занятой значением определенного типа в байтах, можно найти с помощью оператора sizeof.
   
Не все операции с данными одного типа допустимы для данных другого типа.

Например, операции с целыми числами div и mod языка ПАСКАЛЬ и % языка C++ недопустимы для типа real/float.
   
В программах данные представляются в виде величин: переменных и констант. Термин «величина» позаимствован из математики и физики, где величины используются для описания природных явлений. В качестве примера приведем некоторые величины, изучаемые на соответствующих уроках, это: масса m, длина l, площадь S, объем V, ускорение свободного падения g ≈ 9,8 m/s , иррациональное число π≈3,14 и др.

Переменная – это величина, значение которой может быть изменено в процессе выполнения программы. Любая переменная имеет имя, значение и тип. Имя переменной(например, m, l, S, V, delta) используется для ее обозначения в программе. В ходе выполнения программы каждая переменная, в текущий момент времени, имеет либо конкретное значение (например, 105 или -36), либо ее значение не определено.

Множество значений, которые может принимать переменная, и операции, допустимые для выполнения над ней, определяются посредством сопоставления имени переменной с необходимым типом данных.
   
Общая форма объявления переменной:
```cpp
<Тип данных> <Идентификаторы>;
```
В этих объявлениях <Тип данных> может быть любым стандартным или определяемым пользователем типом данных, а <Идентификаторы> – список, содержащий как минимум один идентификатор. В случае нескольких идентификаторов они разделяются запятыми.

Пример:
``` C++
int x, y;
float z;
```

В процессе выполнения программы переменные x и y могут принимать любые целочисленные значения, а переменная z – любые вещественные значения. Множества значений типов данных в вышеприведенных объявлениях будут изучаться в следующих параграфах.
   
Константа – это величина, значение которой не может быть изменено в процессе выполнения программы. Тип константы объявляется неявно (по умолчанию) через форму ее записи. Например, 10 – это константа типа integer/int, а 10.0 – константа типа real/float.
   
Для большей наглядности константы могут иметь символические имена.
Общая форма объявления константы:
```cpp   
const <Тип данных> <Идентификатор>=<Значение>
```
Примеры:
```C++
const int g = 9;
const float pi = 3.14;
```   

Очевидно, что значения констант g и pi не могут быть изменены в ходе выполнения программы.

Концепция данных, реализованная в языке ПАСКАЛЬ/C++, предполагает следующее:
1) каждая величина (переменная или константа), используемая в программе, должна быть ассоциирована с определенным типом данных;
2) тип переменной определяет множество значений, которые она может принимать, и операции, которые можно применять к данным значениям;
3) существуют предопределенные типы данных, которые считаются известными в любой программе, например, в языке ПАСКАЛЬ: integer и real, а в C++: int, float;
4) на основании известных типов данных программист может создавать новые типы,отражающие природу информации, подлежащей обработке.

## Вопросы и упражнения
1. Как представляются данные в машинном коде компьютера? Укажите преимущества и недостатки такого представления.
2. Как представляются данные в программах на языке ПАСКАЛЬ? Укажите разницу между переменной и константой.
3.	Объясните значение термина тип данных. Приведите примеры.
4.	Как указывается тип переменных?
5.	ОПРЕДЕЛИТЕ! Установите тип переменных r, s, t, x, y и z из следующего описания:
```C++
int r,y;
float s,z;
bool t,x;
```
6.	 ПРИМЕНИТЕ! Объявите переменные a, b и c как переменные целого типа, а p и q как переменные вещественного типа.

7.	 ОПРЕДЕЛИТЕ! Установите тип следующих констант:
```
a) –301
b) –301.0
c) +6100
d) –61.00e+2
e) 3.14
f) –0.0001
g) 314.0
h) 0314
i) -0.000672
```
8.	 ПРОАНАЛИЗИРУЙТЕ И ПРИМЕНИТЕ! Проанализируйте предложенную ниже программу. Определите используемые величины и их тип.
```cpp
#include <iostream>
using namespace std;

int main()
{
    float z;
    int a, b;
    a = 2;
    b = 17;
    z = (a + b) * 2;
    cout << "z=" << z << endl;
    return 0;
}
```
Запустите программу на выполнение. Объясните полученные результаты.

Измените программу таким образом, чтобы она вычисляла площадь прямоугольника со сторонами a и b.

9. ИЗУЧИТЕ!
a)	Поищите в Интернете и узнайте, какие стандартные типы данных имеет язык программирования, который вы изучаете. Уточните множество значений каждого стандартного типа данных.
b)	Поищите в Интернете и узнайте, какой тип данных в языке программирования, который вы изучаете, назван в честь известного ученого? Почему именно этот тип данных получил такое название?
c)	Запустите на выполнение нижеследующую программу. Определите, сколько байтов компилятор выделяет для значений каждого типа данных.
```cpp
 #include <iostream>
using namespace std;

int main()
{
    int a;
    float b;
    bool c;
    char d;

    cout << sizeof(a) << endl;
    cout << sizeof(int) << endl;
    cout << sizeof(float) << endl;
    cout << sizeof(char) << endl;
    cout << sizeof(bool) << endl;

    return 0;
}
```

## 2.2. Тип данных integer/int

В языке C++ множество значений базового типа данных int состоит из целых чисел,которые могут быть представлены на хост-компьютере. При этом отметим, что в языке C++ существуют так называемые квалификаторы или модификаторы, которые могут применяться к основным типам: short, long, signed, unsigned. Применение этих квалификаторов изменяет область значений соответствующего типа путем изменения количества байтов, необходимых для хранения этих величин и типа величин (со знаком или без знака).

Данные типа signed (со знаком) могут быть положительными или отрицательными, а данные типа unsigned (без знака) всегда положительными. По умолчанию все типы данных являются со знаком. Квалификатор long расширяет набор значений, а short – сокращает. В результате объем памяти, необходимый для хранения этих значений, будет увеличиваться или уменьшаться.

Чтобы указать целые числа разных типов, можно использовать суффиксы модификаторов:

| Суффикс | Тип модификатора |
|---------|-----------------|
| u или U | unsigned        |
| l или L | long            |
| ll или LL | long long      |

Примеры:
```cpp
48              //   int
48u             //   unsigned int
48l             //   long
48ul            //   unsigned long
48lu            //   unsigned long
```
Максимальное значение типа данных int зависит от компилятора и операционной системы хост-компьютера. В случае компиляторов под MS-DOS, которые выделяют не более 2 байтов (16 бит), тип данных int имеет диапазон значений [-32768, 32767], а для компиляторов под UNIX (Linux) выделяются 4 байта (32 бита), поэтому int имеет диапазон значений [–2147483648, 2147483647].

Максимальное значение типа данных int является величиной предопределенной константы INT_MAX, а минимальное значение – величиной предопределенной константы INT_MIN. Эти символьные константы, а также другие, которые имеют в качестве значений нижний и верхний пределы диапазона значений для различных типов данных, определены в библиотеке (header - заголовок) <limits>.

Следующая программа отображает значение константы INT_MAX на экране.
```cpp
// Программа P2
// Отображение константы INT_MAX
#include <iostream>
#include <limits>
using namespace std;
int main()
{
   cout<<″INT_MAX=″<<INT_MAX<<endl;
   return 0;
}
```
Операции, которые можно осуществлять над целыми числами: +, -, *, %, / и др.

Операция % (modulo) имеет смысл, только если оба операнда – целые числа, а ее результат – это остаток от целочисленного деления. Приведем несколько примеров:
```cpp
11 % 3 = 2
30 % 10 = 0
276 % 10 = 6
```
Операция /, примененная к целым числам, будет выполнять целочисленное деление, а результат операции / будет частным от целочисленного деления. Вот некоторые примеры:
```cpp
4 / 2 = 2
18 / 4 = 4
0 / 4 = 0
```
Результаты этих операций можно вывести на экран с помощью следующей программы:

```cpp
// Программа P3
// Операции с данными типа int
#include <iostream>
using namespace std;
int main() {
   int x, y, z;
   cout<<″Введите целые числа x, y:″;
   cin>>x>>y;
   cout<<″x=″<<x<<endl;
   cout<<″y=″<<y<<endl;
   z=x+y; cout<<″x+y=″<<z<<endl;
   z=x-y; cout<<″x-y=″<<z<<endl;
   z=x*y; cout<<″x*y=″<<z<<endl;
   z=x%y; cout<<″x%y=″<<z<<endl;
   z=x/y; cout<<″x/y=″<<z<<endl;
   return 0;
}
```
Очевидно, что результаты операций +, –, * с целочисленными значениями должны принадлежать множеству значений типа данных int. Если программист не обращает должного внимания на это правило, и значение, содержащееся в переменной, превышает пределы, налагаемые типом используемых данных, происходит так называемое переполнение (overflow), которое может вызвать, казалось бы, необъяснимые ошибки.

Приоритеты операций +, –, *, /, % будут изучены позже.

Отметим, что целые числа могут задаваться в системах счисления по основанию 10, 8 и 16:
* По основанию 10, например: 176, -540. Могут содержать цифры: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
* По основанию 8, например: 015, 062. Могут содержать цифры: 0, 1, 2, 3, 4, 5, 6, 7 и всегда начинаются с 0.
* По основанию 16, например: 0x15, 0x6f, 0xff. Могут содержать цифры: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F и всегда начинаются с 0x.

## Вопросы и упражнения
1.	Укажите множество значений целочисленного типа данных. Какие операции можно применять к таким значениям?
2. Когда появляются ошибки переполнения? Как обнаруживаются такие ошибки?
3. ПРОАНАЛИЗИРУЙТЕ! Запустите на выполнение вышеприведенные программы. Объясните полученные на экране результаты.

Задания a) и b) можно раздать ученикам для индивидуального выполнения либо для работы в парах.

a.
```cpp
// Программа Ex3a
#include <iostream>
using namespace std;

int main()
{
    int x, y, z;
    float m;
    cout<<"Введите целые числа x, y:";
    cin>>x>>y;
    cout<<"x="<<x<<endl;
    cout<<"y="<<y<<endl;
    z=x+y; cout<<"x+y="<<z<<endl;
    z=x-y; cout<<"x-y="<<z<<endl;
    z=x*y; cout<<"x*y="<<z<<endl;
    z=x%y; cout<<"x%y="<<z<<endl;
    z=x/y; cout<<"x/y="<<z<<endl;
    return 0;
}
```

b.
```cpp
// Программа Ex3b
#include <iostream>
using namespace std;

int main()
{
    int x, y, z;
    float m;
    cout<<"Введите целые числа x, y:";
    cin>>x>>y;
    cout<<"Введите вещественное число m"; 
    cin>>m;
    z=m/y; cout<<"m/y="<<z<<endl;
    z=m%y; cout<<"m%y="<<z<<endl;
    return 0;
}
```

4. ИЗУЧИТЕ! Работу можно организовать в группах, каждая из которых получит одно из нижеследующих заданий.

1) Напишите программу, которая выводит на экран значения констант:
```cpp
C++:	    INT_MAX, SHRT_MAX, UINT_MAX, LONG_MAX
```
Заполните таблицу:
| Константа | Значение константы |
|-----------|------------------|
| MaxInt    | ...               |
| ...    | ...               |
| ...    | ...               |


2) Изучив специальную литературу в Интернете, а также используя Sizeof, определите объем памяти, выделяемый для значений целочисленных типов и их расширений:
```cpp
C++:	    int, unsigned int, long int, unsigned long int, short int, unsigned short int.
```
Заполните таблицу:
| Имя типа | Объем выделяемой памяти в битах | Область значений |
|----------|-------------------------------|-----------------|
| Byte     |...                               |       ...          |
| ...      | ...                              |    ...             |


5.	 ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ! Даны программы:
```cpp
// Программа P6
#include <iostream>
#include <limits>
using namespace std;

int main()
{
    int x;
    x = -2 * INT_MAX;
    cout << x;
    return 0;
}

// Программа P7
#include <iostream>
#include <limits>
using namespace std;

int main()
{
    int x, y;
    x = -INT_MAX;
    y = x - 10;
    cout << y;
    return 0;
}
```

Запустите программы на выполнение. Проанализируйте ошибки переполнения.

Когда появляются сообщения об ошибках переполнения: в процессе компиляции или во время выполнения программы?

Приведите примеры значений переменных x и y, для которых ошибки переполнения не появляются.

## 2.3. Тип данных real/float
Множество значений изучаемого типа данных состоит из элементов вещественных чисел, которые могут быть представлены на хост-компьютере языка программирования.

В нижеследующих таблицах представлены наиболее часто применяемые типы вещественных данных и их расширений:

| Имя типа       | Байты | Область значений                          | Точность                 |
|----------------|-------|-------------------------------------------|--------------------------|
| float          | 4     | –3,4·10³⁸ … 3,4·10³⁸                     | 6-7 десятичных цифр      |
| double         | 8     | –1,7·10³⁰⁸ … +1,7·10³⁰⁸                   | 15-16 десятичных цифр    |
| long double    | 10    | –3,4·10⁴⁹³² … 3,4·10⁴⁹³²                   | 18-19 десятичных цифр    |

Напомним, что объем памяти, занимаемой значением определенного типа (т.е. наскольких байтах хранится значение), можно узнать с помощью оператора sizeof.

ПРИМЕЧАНИЕ
Как и в случае с целыми типами данных, объем памяти, выделяемой для хранения вещественных данных, зависит от компилятора и операционной системы хост-компьютера. Очевидно, что области значений этих типов данных также будут разными.

В следующей программе переменным х, у и z присваиваются соответственно значения 1.1, –6.14·10e+8 и 90.3·10e-29 , которые затем выводятся на экран.

```cpp
// Программа P8
#include <iostream>
using namespace std;

int main()
{
    float x, y, z;
    x = 1.1;
    y = -6.14e8;
    z = 90.3e-29;
    cout << "x=" << x << endl;
    cout << "y=" << y << endl;
    cout << "z=" << z;
    return 0;
}
```
Напомним, что при записи вещественных чисел десятичная запятая заменяется точкой, а степень числа 10 представляется масштабным множителем.

Операции, которые можно применять к значениям вещественного типа: +, –, *,/ (деление) и др.

Операции над вещественными числами в общем случае являются приближенными из-за погрешностей округления. Естественно, результаты данных операций также должны принадлежать множеству значений вещественных типов данных. В противном случае возникают ошибки переполнения.

Свойства операций +, –, * и / могут быть изучены с помощью следующей программы:
```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    double x, y, z;
    cout << "Введите вещественные числа x и y:";
    cin >> x >> y;
    cout << "x=" << x << endl;
    cout << "y=" << y << endl;
    z = x + y; cout << "x+y=" << z << endl;
    z = x - y; cout << "x-y=" << z << endl;
    z = x * y; cout << "x*y=" << z << endl;
    z = x / y; cout << "x/y=" << z;
    return 0;
}
```

В таблице 2.1 представлены данные, которые выводятся на экран этими программами для некоторых значений переменных х и у. Отметим, что результаты операций х+у и х–у в первых двух строках таблицы 2.1 являются точными. Для значений х = 1,0 , у = 1,0·10e-11 (третья строка таблицы) результат сложения – приближенный, а вычитания – точный. Оба результата из строки 4 являются приближенными. Для значений х = у = 1,7·10 (строка 5), (версия Turbo PASCAL 7.0) при выполнении операции сложения имеет место переполнение. Для значений х = 3,1·10e-39 , у = 3,0·10e-39 (строка 6) результат сложения – точный, а вычитания – приближенный.

Tаблица 2.1
Результаты работы программы Р9
| №  | x             | y               | x+y                        | x–y                       |
|----|---------------|-----------------|----------------------------|---------------------------|
| 1  | 1,0           | 1,0             | 2.0000000000E+00           | 0.0000000000E+00          |
| 2  | 1,0           | 1,0·10⁻¹¹      | 1.0000000000E+00           | 9.9999999999E–01          |
| 3  | 1,0           | 1,0·10⁻¹²      | 1.0000000000E+00           | 9.9999999999E–01          |
| 4  | 1,0           | 1,0·10³⁸       | 1.0000000000E+00           | 1.0000000000E+00          |
| 5  | 1,7·10³⁸      | 1,7·10³⁸       | C++: 3.4000000000e+39      | 0.0000000000E+00          |
| 6  | 3,1·10⁻³⁹     | 3,0·10⁻³⁹      | 6.1000000000E-39           | 0.0000000000E+00          |

Ошибки вычисления, характерные для типа данных real/ float и их расширений, могут нарушить ход выполнения программы. Оценка ошибок и, если необходимо, их устранение является задачей программиста.

Приоритеты операций +, -, *, / будут изучены в Главе 3.

## Вопросы и упражнения
1.	Как записываются вещественные числа на языке ПАСКАЛЬ/C++?
2.	Определите множество значений типа данных real в версии языка ПАСКАЛЬ и соответственно данных типа double в версии языка C++, в которой вы работаете. Какова точность соответствующих чисел?
3.	Какие операции можно применять к данным типа real в языке ПАСКАЛЬ и соответственно данных типа double в языке C++? Являются ли эти операции точными?
4.	ПРИМЕНИТЕ И ОБРАТИТЕ ВНИМАНИЕ! Напишите и запустите на выполнение программу для нахождения суммы и разности для следующих значений переменных х, у:
```
a) x = 2,0; y = –3,0
b) x = 14,3·10²; y = 15,3·10⁻³
c) x = 3,0; y = 2,0·10¹²
d) x = 3,0; y = 2,0·10⁻¹²
e) x = 2,9·10⁻³⁹; y = 6,4·10⁻³
f) x = 7,51·10²¹; y = –8,64·10¹⁷
g) x = 1,0; y = 2,9·10⁻³⁹
h) x = 1,7·10³⁸; y = 2,9·10⁻³⁹
```
  	 Проверьте результаты соответствующих операций. Объясните сообщения,
    выдаваемые на экран.
5.	Каковы причины ошибок вычисления при работе с данными типа real / float?


## 2.4. Тип данных boolean/bool
Значениями типа данных boolean/bool (логический) являются истинностные значения false (ложь) и true (истина). В нижеприведенной программе переменной х последовательно присваиваются значения false и true, выводимые впоследствии на экран.
```cpp
#include <iostream>
using namespace std;

// Данные типа boolean
int main()
{
    bool x;
    x = false;
    cout << x << endl;
    x = true;
    cout << x;
    return 0;
}
```
Логические операции, которые можно применять к данным логического типа:
| Операция                                       | C++  |
|------------------------------------------------|------|
| Отрицание (логическая инверсия, логическая операция НЕ) | !    |
| Конъюнкция (логическое произведение, логическая операция И) | &&   |
| Дизъюнкция (логическая сумма, логическая операция ИЛИ) | \|\|   |

Таблицы истинности данных операций представлены на рис. 2.1.

### Логическое отрицание (NOT)

| x     | not x (!x) |
|-------|------------|
| false | true       |
| true  | false      |

### Логическое И (AND)

| x     | y     | x and y (x&&y) |
|-------|-------|----------------|
| false | false | false          |
| false | true  | false          |
| true  | false | false          |
| true  | true  | true           |

### Логическое ИЛИ (OR)

| x     | y     | x or y (x||y) |
|-------|-------|---------------|
| false | false | false         |
| false | true  | true          |
| true  | false | true          |
| true  | true  | true          |

Рис. 2.1. Таблицы истинности логических операций отрицание, конъюнкция и дизъюнкция

Свойства логических операций отрицание, конъюнкция и дизъюнкция могут быть изучены с помощью следующих программ.:

```cpp
#include <iostream>
using namespace std;

/* Операции с данными типа boolean */
int main()
{
    bool x, y, z;

    x = false; y = false;
    cout << "x=" << x << " y=" << y << endl;
    z = !x;
    cout << "!x=" << z << endl;
    z = x && y;
    cout << "x && y=" << z << endl;
    z = x || y;
    cout << "x || y=" << z << endl;
    cout << endl;

    x = false; y = true;
    cout << "x=" << x << " y=" << y << endl;
    z = !x;
    cout << "!x=" << z << endl;
    z = x && y;
    cout << "x && y=" << z << endl;
    z = x || y;
    cout << "x || y=" << z << endl;
    cout << endl;

    x = true; y = false;
    cout << "x=" << x << " y=" << y << endl;
    z = !x;
    cout << "!x=" << z << endl;
    z = x && y;
    cout << "x && y=" << z << endl;
    z = x || y;
    cout << "x || y=" << z << endl;
    cout << endl;

    x = true; y = true;
    cout << "x=" << x << " y=" << y << endl;
    z = !x;
    cout << "!x=" << z << endl;
    z = x && y;
    cout << "x && y=" << z << endl;
    z = x || y;
    cout << "x || y=" << z << endl;
    cout << endl;

    return 0;
}
```

ПРИМЕЧАНИЯ

В языке C++ логические, символьные, целочисленные, вещественные и перечисляемые типы являются арифметическими типами, поскольку их значения можно интерпретировать как целые числа. Таким образом, в программе на C++ текущие значения логических переменных могут быть прочитаны с клавиатуры с помощью стандартных процедур чтения только как целочисленные значения, т.е. 0 вместо false и 1 вместо true. Кроме того, если логическое значение присваивается целочисленной переменной, true становится 1, а false становится 0. Если целочисленное значение присваивается логической переменной, 0 становится false, а любое ненулевое значение становится true. Приоритеты операций отрицание, конъюнкция и дизъюнкция будут изучены в Главе 3.

## Вопросы и упражнения
1.	Назовите множество значений данных логического типа и операции, применимые к ним.
2.	Выучите таблицы истинности логических операций.
3.	ПРИМЕНИТЕ! Напишите:
a) программу, которая выводит на экран таблицу истинности логической операции отрицание;
b) программу, которая вычисляет значения логической функции z = x & y для всех возможных значений аргументов x, y;
c) программу, которая выводит на экран значения логической функции z = x ∨ y.
4.	ОБРАТИТЕ ВНИМАНИЕ! Запустите на выполнение программы, представленные в качестве примеров в этом параграфе, и посмотрите, как отображаются на экране значения логического типа данных. Какое значение ассоциируется со значением true и какое – со значением falsе


## 2.5. Тип данных char
Множеством значений данного типа является конечное упорядоченное множество символов. Значения рассматриваемого типа обозначаются символом, заключенным в одиночные кавычки (апострофы), например: ’A’, ’B’, ’C’ и т.д.

ПРИМЕЧАНИЯ

Напомним, что для того чтобы вывести на экран сам символ апострофа, используйте:
В C++: символ \ (backslash), за которым следует апостроф, представляя его так: ’\’’.

В следующей программе переменной х типа char последовательно присваиваются
значения ’A’, ’+’ и символ ’ (апостроф), выводимые на экран.
```cpp
#include <iostream>
using namespace std;

// Данные типа char
int main()
{
    char x;

    x = 'A';
    cout << x << endl;
    x = '+';
    cout << x << endl;
    x = '\'';
    cout << x << endl;

    return 0;
}

```

Текущие значения переменной типа char могут считываться с клавиатуры с помощью стандартных процедур чтения. Для пояснения представляем программы, которые считывают с клавиатуры и выводят на экран значения типа char.
```cpp
#include <iostream>
using namespace std;

/* Чтение и вывод на экран символов */
int main()
{
    char x;

    cin >> x; cout << x << endl;
    cin >> x; cout << x << endl;
    cin >> x; cout << x << endl;

    return 0;
}

```
Соответствующие символы вводятся с клавиатуры и выводятся на экран без апострофов, которые необходимы лишь для включения символьных значений в текст программы.

Как правило, символы языка программирования упорядочены согласно таблице кодов ASCII (см. параграф 1.4).

Ниже представляем вывод порядкового номера символа из множества значений типа char.

```C++
1)   int(’A’)=65
2)   int(’B’)=66
3)   int(’C’)=67
```
Следующие программы выводят на экран порядковые номера любых четырех символов, считываемых с клавиатуры.
```cpp
#include <iostream>
using namespace std;

// Изучение функции ord
int main()
{
    char x;
    int i;

    cin >> x; i = int(x); cout << i << endl;
    cin >> x; i = int(x); cout << i << endl;
    cin >> x; i = int(x); cout << i << endl;
    cin >> x; i = int(x); cout << i << endl;

    return 0;
}
```

В языке ПАСКАЛЬ стандартная функция chr возвращает символ, который соответствует указанному порядковому номеру, а в C++ для этой цели используется преобразование типа char.
     Примеры
```C++
1)   char(65)=’A’
2)   char(66)=’B’
3)   char(67)=’C’
```
Следующие программы выводят на экран символы, которые соответствуют порядковым номерам, считанным с клавиатуры.
```cpp
#include <iostream>
using namespace std;

// Изучение функции chr
int main()
{
    int i;
    char x;

    cin >> i; x = char(i); cout << x << endl;
    cin >> i; x = char(i); cout << x << endl;
    cin >> i; x = char(i); cout << x << endl;
    cin >> i; x = char(i); cout << x << endl;

    return 0;
}
```

Напоминаем, что расширенное множество ASCII включает 256 пронумерованных символов: 0, 1, 2, …, 255.

Тип данных char используется для создания более сложных структур данных, в частности строк символов.

## Вопросы и упражнения
1.	Укажите множество значений типа данных char?
2.	Как упорядочено множество значений типа char?
3.	ПРИМЕНИТЕ! Определите порядковые номера следующих символов:
- десятичных цифр;
- прописных букв латинского алфавита;
- знаков препинания;
- знаков арифметических и логических операций;
- управляющих символов;
- букв русского алфавита (если они установлены на вашем компьютере).
4.	ПРИМЕНИТЕ! Определите символы, которые соответствуют следующим порядковым номерам:
```
   		  77	109	79	111	42	 56	 91	123
```
5.	ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Напишите программу, которая выводит на экран множество всех символов компьютера, на котором вы работаете.


## 2.6. Перечисляемые типы данных
Типы данных, изученные в параграфах 2.2, 2.3, 2.4 и 2.4, являются предопределенными типами данных, известными любой программе на языке ПАСКАЛЬ или C++. Кроме предопределенных типов данных существуют типы, создаваемые самим программистом, в частности перечисляемые типы.
Перечисляемый тип данных содержит упорядоченное множество значений, определяемых посредством идентификаторов.

В языке ПАСКАЛЬ перечисляемый тип данных и множество его значений определяются с помощью ключевого слова type (тип), а в языке C++ – с помощью ключевого слова enum.
Примеры:
```cpp
enum Culoare { Galben, Verde, Albastru, Violet };
enum Studii { Elementare = 1, Medii, Superioare };
enum Raspuns { Nu, Da };
```
Первый идентификатор из списка элементов является наименьшим значением, и его порядковый номер равен нулю. Второй идентификатор имеет порядковый номер один, третий – два и т.д. В языке C++ порядковый номер идентификатора в списке перечисления может быть изменен, указав его начальное значение. Это использовалось для определения перечисляемого типа Studii. Таким образом, порядковый номер идентификатора Elementare будет 1, порядковый номер идентификатора Medii будет 2, а порядковый номер идентификатора Superioare будет 3.

Проанализируйте следующие примеры, чтобы увидеть, как можно определить порядковый номер значения объявленного типа перечисления.

Примеры:
```cpp
1)   cout<<Galben;          // 0
2)   cout<<Verde;           // 1
3)   cout<<Albastru;        // 2
4)   cout<<Violet;          // 3
5)   cout<<Elementare;      // 1
6)   cout<<Medii;           // 2
```

ПРИМЕЧАНИЕ
В языке C++ перечисляемый тип является целочисленным, а идентификаторы перечисляемого типа могут использоваться как целочисленные переменные.

Следующая программа выводит на экран порядковые номера значений типов данных Studii и Raspuns.

```cpp
#include <iostream>
using namespace std;

/* Тип данных Studii и Raspuns */
int main()
{
    enum Studii {Elementare=1, Medii, Superioare};
    enum Raspuns {Nu, Da};
    int i;

    i = Elementare; cout << i << endl;
    i = Medii;      cout << i << endl;
    i = Superioare; cout << i << endl;
    i = Nu;         cout << i << endl;
    i = Da;         cout << i << endl;

    return 0;
}
```

Переменные перечисляемого типа могут принимать только значения перечисляемых элементов из типа данных, к которому они относятся.

В следующей программе переменная х принимает значение Albastru, а переменная y принимает значение Nu. Порядковые номера этих значений выводятся на экран.

```cpp
#include <iostream>
using namespace std;

// Переменные перечисляемого типа
int main()
{
    enum Culoare {Galben, Verde, Albastru, Violet};
    enum Raspuns {Nu, Da};

    Culoare x;  // переменная типа Culoare
    Raspuns y;  // переменная типа Raspuns
    int i;      // порядковый номер

    x = Albastru;
    i = x; cout << i << endl;

    y = Nu;
    i = y; cout << i << endl;

    return 0;
}
```
В случаях, когда в одной программе описываются несколько типов данных, соот- ветствующие списки элементов не должны содержать одинаковые идентификаторы.
Например, объявления
```cpp
enum Studii {Elementare, Medii, Superioare};
enum Grade  {Inferioare, Superioare};
```
являются неправильными, так как идентификатор Superioare появляется в обоих списках.
Текущие значения переменных перечисляемых типов не могут считываться с клавиатуры и выводиться на экран с помощью стандартных процедур чтения и записи. Однако использование таких типов данных позволяет создавать простые и эффективные программы, удобные для чтения.

# here

## Вопросы и упражнения
  	 Как определяется перечисляемый тип данных? Укажите множество значений
     перечисляемого типа данных.
  	 Существен ли порядок идентификаторов в списке элементов перечисляемого
     типа данных?
  	 ПРИМЕНИТЕ! Напишите программу, которая выводит на экран порядко-
     вые номера значений следующих типов данных:

                                                                            59
                   ПАСКАЛЬ                                C++
 1)       type Continente = (Europa,       1)   enum Continente {Europa,
          Asia, Africa, AmericaDeNord,          Asia, Africa, AmericaDeNord,
          AmericaDeSud, Australia,              AmericaDeSud, Australia,
          Antarctida);                          Antarctida};
 2)       type Sex = (Masculin,            2)   enum Sex {Masculin,
          Feminin);                             Feminin};
 3)       type PuncteCardinale =           3)   enum PuncteCardinale {Nord,
          (Nord, Sud, Est, Vest);               Sud, Est, Vest};
 4)       type Etaje = (Unu, Doi,          4)   enum Etaje {Unu, Doi, Trei,
          Trei, Patru, Cinci);                  Patru, Cinci};

      	ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ! Запустите на выполнение
        нижеследующую программу. Что эта программа отображает на экране?
        Подумайте, почему отображаются именно такие результаты. Назовите
        тип каждой переменной, объявленной в программе.
                     ПАСКАЛЬ                                C++
         Program P18;                           // Программа P18
         type Litere = (A, B, C, D, E, F, G);   #include <iostream>
         var x : Litere; y : char; i :          using namespace std;
         integer;                               int main()
         begin                                  {
           x:=A; i:=ord(x); writeln(i);         enum Litere {A, B, C, D, E,
           y:=’A’; i:=ord(y); writeln(i);       F, G};
         end.                                     Litere x;
                                                  char y;
                                                  int i;
                                                  x=A; i=x; cout<<i<<endl;
                                                  y='A'; i=int(y); cout<<i;
                                                return 0;
                                                }

     	Даны объявления:
                     ПАСКАЛЬ                                C++
         type Culoare = (Galben, Verde,         enum Culoare {Galben, Verde,
                     Albastru, Violet);              Albastru, Violet};
              Fundal = (Alb, Negru, Gri);       enum Fundal {Alb, Negru, Gri};
         var x, y : Culoare;                    Culoare x, y;
             z : Fundal;                        Fundal z;

     	    Какие из следующих операторов являются правильными?
                   ПАСКАЛЬ                                C++
 1)       x:=Verde                         1)   x=Verde
 2)       y:=Negru                         2)   y=Negru
 3)       z:=Alb                           3)   z=Alb
 4)       x:=Gri                           4)   x=Gri

60
 5)   y:=Gri                             5)   y=Gri
 6)   z:=Violet                          6)   z=Violet
 7)   x:=Albastru                        7)   x=Albastru
 8)   y:=Azuriu                          8)   y=Azuriu

  	ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. В программе Р17 перед ключевым
    словом end (соответственно перед return в программе C++) вставьте одну
    из следующих строк:
               ПАСКАЛЬ                                     C++
 1)   readln(x);                         1)   cin>>x;
 2)   writeln(x);                        2)   cout<<x;
  	   Объясните сообщения, выводимые на экран в процессе компиляции полу-
      ченной программы.



  2.7. Интервальные типы данных (ПАСКАЛЬ)
   ПРИМЕЧАНИЕ
   Интервальный тип данных определен в языке ПАСКАЛЬ, но не имеет аналога в
   C++. Соответственно этот параграф будут изучать только ученики, обучающиеся
   программированию на языке ПАСКАЛЬ.

   Интервальный тип данных включает подмножество значений уже известного типа
данных, называемого базовым. Базовым типом может быть integer, boolean, char
или любой перечисляемый тип.
   Имя интервального типа данных, его наименьшее и наибольшее значения (в смысле
порядкового номера) указываются в разделе описаний программы после ключевого
слова type.
  Пример:
  1) 	type 	Indice = 1..10;
  		        Litera = ’A’..’Z’;
  		        Cifra = ’0’..’9’;
   Множество значений типа Indice является подмножеством значений предопре-
деленного типа integer. Множества значений типов Litera и Cifra являются
подмножествами предопределенного типа char.
  2) 	type 	Zi = (L, Ma, Mi, J, V, S, D);
  		        ZiDeLucru = L..V;
  		        ZiDeOdihna = S..D;	
   Множества значений типов ZiDeLucru и ZiDeOdihna являются подмножествами
перечисляемого типа Zi, определенного пользователем.
  3)	 type 	T1 = (A, B, C, D, E, F, G, H);
  		        T2 = A..F;
  		        T3 = C..H;

                                                                             61
   Множества значений типов Т2 и Т3 являются подмножествами перечисляемого типа
Т1. Из данных примеров следует, что базовыми типами интервальных типов данных
являются:
   		             Интервальный тип	            Базовый тип
     	1)	
        Indice	                                integer
     	2)	
        Litera	char
     	3)	
        Cifra	                                 char
     	4)	
        ZiDeLucru	Zi
     	5)	
        ZiDeOdihna	Zi
     	6)	
        T2	T1	
     	7)	
        T3	T1	

   Переменные интервального типа объявляются с помощью ключевого слова var.
Переменная интервального типа обладает всеми свойствами переменных базового типа,
но ее значения должны находиться в соответствующем диапазоне. В противном случае
возникает ошибка и программа останавливается.
     Пример:

      Program P19;
        { Значения переменных интервального типа }
      type	 Indice = 1..10;
      	     Zi = (L, Ma, Mi, J, V, S, D);
      	     ZiDeLucru = L..V;
      	     ZiDeOdihna = S..D;
      var	 i : Indice;      { возможные значения: 1, 2, ..., 10 }
      	     z : Zi;         { возможные значения: L, Ma, ..., D }
      	     zl : ZiDeLucru; { возможные значения: L, Ma, ..., V }
      	     zo : ZiDeOdihna; { возможные значения: S, D }
      begin
        i:=5; i:=11; 	        { Ошибка, i>10 }
        z:=L; zl:=J; zl:=S; 	 { Ошибка, zl>V }
        zo:=S; zo:=V; 	       { Ошибка, zo<S }
        writeln(’Конец’);
      end.

     Программа Р20 показывает, как тип Pozitiv наследует свойства типа integer.

      Program P20;
       { Тип Pozitiv наследует свойства типа integer }
      type Pozitiv = 1..32767;
      var x, y, z : Pozitiv;
      begin

62
     writeln(’Введите положительные числа x, y:’);
     readln(x,y);
     writeln(’x=’, x);
     writeln(’y=’, y);
     z:=x+y; writeln(’x+y=’, z);
     z:=x-y; writeln(’x-y=’, z);
     z:=x*y; writeln(’x*y=’, z);
     z:=x mod y; writeln(’x mod y=’, z);
     z:=x div y; writeln(’x div y=’, z);
    end.
   Отметим, что операции +, -, *, mod и div базового типа integer применимы к ин-
тервальному типу Pozitiv. Но в отличие от переменных типа integer переменные
типа Pozitiv не могут принимать отрицательные значения.
   Использование интервальных типов данных улучшает наглядность программ и
упрощает их проверку.
   Следует подчеркнуть, что в языке ПАСКАЛЬ нельзя определять интервальные
типы на базе типа real, так как его значения не имеют порядковых номеров.


  Вопросы и упражнения
  	Как определяется интервальный тип данных? Из чего состоит множество
    значений интервального типа данных?
  	Назовите базовый тип каждого интервального типа:
  		type     T1   =   (A, B, C, D, E, F, G, H);
  			        T2   =   –60..60;
  			        T3   =   5..9;
  			        T4   =   ’5’..’9’;
  			        T5   =   A..E;
  			        T6   =   ’A’..’E’;
  	Какие значения может принимать каждая переменная из следующих
    описаний:
  		type     T1 = (A, B, C, D, E, F, G, H);
  			        T2 = 1..9;
  			        T3 = 6..15;
  			        T4 = –100..100;
  			        T5 = ’A’..’Z’;
  			        T6 = ’0’..’9’;
  			        T7 = C..F;
  		var	     i : integer;
  			        j : T2;
  			        m : T4;
  			        p : T5;
  			        q : char;
  			        r : T6;
  			        s : T1;
  			        t : T7;

                                                                              63
     	    Назовите базовый тип каждого интервального типа. Укажите множество
          операций, унаследованных от базового типа.
     	Какие из следующих определений являются правильными? Аргументируйте
       свой ответ.
     	 a)	 type Lungime = 1.0e–2..1.0;
     			         Latime = 1.0e–2..0.5;	
     	 b)	 type Indice = 1..10;
     			        Abatere = +5..–5;
     			        Deviere = –10..+10;	
     	    c)	 type T1 = (A, B, C, D, E, F, G, H);
         			       T2 = C..H;
         			       T3 = F..B;	
     	 d)	 type	 Luni = (	Ianuarie, Februarie, Martie, Aprilie, Mai,
     				                 Iunie, Iulie, August, Septembrie, Octombrie, 	
       			                Noiembrie, Decembrie);
      			        LuniDeIarna = (Decembrie..Februarie);
      			        LuniDePrimavara = (Martie..Mai);
      			        LuniDeVara=(Iunie..August);
      			        LuniDeToamna=(Septembrie..Noiembrie);
     	Дана следующая программа:
        Program P21;
         	type	 Indice=1..10;
         	var	 i, j, k, m : Indice;
        begin
         	writeln(’Введите индексы i, j:’);
         	readln(i, j);
         	k:=i+j; writeln(’k=’, k);
         	m:=i-j; writeln(’m=’, m);
        end.

     	    При каких значениях переменных i, j появятся ошибки выполнения?
     	    a)	 i=3, j=2;	                  e)	 i=2, j=2;

     	    b)	 i=7, j=4;	                  f)	 i=3, j=11;

     	    c)	 i=4, j=7;	                  g)	 i=8, j=4;

     	    d)	 i=6, j=3;	                  h)	 i=5, j=3.
     	ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Рассмотрим программу Р20. По-
       сле запуска на выполнение пользователь вводит х=1, у=2. Очевидно, что
       х-у=–1. Так как значение -1 не принадлежит типу данных Pozitiv, то при
       выполнении оператора
         z:=x–y
     	 возникнет ошибка.

64
   	   Укажите операторы, при выполнении которых появятся ошибки, если:
   	   a)	 x=1000, y=1000;	               e)	 x=1, y=2;	

   	   b)	 x=1000, y=1001;	               f)	 x=1000, y=100;

   	   c)	 x=1001, y=1000;	               g)	 x=0, y=1;

   	   d)	 x=30000, y=30000;	             h)	 x=1, y=0.



   2.7.* Тип void (C++)
   ПРИМЕЧАНИЕ
   Тип данных void не определен в языке ПАСКАЛЬ.
   Соответственно этот параграф будут изучать только ученики, обучающиеся языку
   программирования C++.

   Тип void – это специальный тип, множество допустимых значений которого пусто.
   Этот тип используется, когда необходимо указать отсутствие какого-либо значения.
Например, его можно использовать для указания типа функции, которая не возвращает
результата (результат типа void) или функции, которая не имеет формальных аргу-
ментов (список формальных аргументов пуст – void). Другие варианты использования
типа void относятся, в частности, к переменным типа pointer (указателя) и будут
уточнены в соответствующий момент.
   Пример:
       void mesaj()
       {
         cout << ″Я являюсь функцией!″;
       }



   2.8. Общие сведения о порядковых типах данных
   Типы данных integer, boolean, char, перечисляемые и интервальные типы в языке
ПАСКАЛЬ, соответственно int, bool, char и enum в C++, являются порядковыми
типами данных. Каждое значение порядкового типа данных имеет порядковый номер,
определяемый следующим образом:
   1) порядковым номером некоего числа типа integer в языке ПАСКАЛЬ, соответ-
ственно int в C++, является само это число;
   2) порядковыми номерами значений истинности false и true типа данных
boolean являются соответственно 0 и 1;
   3) порядковый номер некоторого символа (тип char) определяется его позицией в
таблице кодов, обычно АSCII;
   4) порядковый номер некоторого значения перечисляемого типа в языке ПАСКАЛЬ
определяется его позицией в списке перечисляемых элементов. Отметим, что элементы
списка, по умолчанию, нумеруются, начиная с нуля: 0, 1, 2, … и т.д.

                                                                                65
   5) порядковые номера значений интервального типа в языке ПАСКАЛЬ совпадают
с их порядковыми номерами в базовом типе.
   Порядковый номер любого значения порядкового типа можно определить и вывести
на экран.
   Нижеследующая программа выводит на экран порядковые номера значений: -32,
true, ’A’, A и B.
          ПАСКАЛЬ                                     C++
Program P22;                             // Программа P22
 { Порядковые номера значе-              #include <iostream>
ний порядковых типов }                   /* Порядковые номера значе-
type T1 = (A, B, C, D, E,                ний порядковых типов */
            F, G, H);                    using namespace std;
begin                                    int main()
  writeln(ord(-32));  { -32 }            {
  writeln(ord(true)); {   1 }            enum T1 {A, B, C, D, E, F,
  writeln(ord(’A’));  { 65 }                       G, H};
  writeln(ord(A));    {   0 }            cout<<int(-32)<<endl;  // -32
  writeln(ord(B));    {   1 }            cout<<int(true)<<endl; // 1
end.                                     cout<<int(’A’)<<endl;  // 65
                                         cout<<A<<endl;          // 0
                                         cout<<B<<endl;          // 1
                                         return 0;
                                         }

     ПРИМЕЧАНИЕ
     Оператор int в вышеприведенной программе C++ применяется для преобразо-
     вания типа данных переменной из одного в другой. Такой оператор называется
     оператором преобразования типов.

     К значениям любого порядкового типа можно применять операции отношения:
                Операции отношения          ПАСКАЛЬ             C++
        Меньше                                    <              <
        Меньше или равно                         <=              <=
        Равно                                     =              ==
        Больше или равно                         >=              >=
        Больше                                    >              >
        Не равно                                 <>              !=
   Результатом операции отношения является значение типа boolean, то есть может
получить одно из значений true или false. При выполнении таких операций срав-
ниваются не сами значения, а их порядковые номера.

66
   Примеры:
   ПАСКАЛЬ
   Пусть
    type Culoare = (Galben, Verde, Albastru, Violet);
  Результатом операции Verde < Violet является true, так как ord(Verde)=
1, ord(Violet)=3, а 1 меньше, чем 3.
  Результатом операции Galben > Violet является false, так как ord(Galben)=0,
ord(Violet)=3, а 0 не больше, чем 3.
    C++
    Пусть
    enum Culoare {Galben, Verde, Albastru, Violet};
  Результат операции Verde<Violet равен true, так как порядковый номер значения
Verde равен 1, а порядковый номер значения Violet равен 3 и 1 меньше 3.
  Результат операции Galben>Violet равен false, так как порядковый номер значе-
ния Galben равен 0, порядковый номер значения Violet равен 3, а 0 не больше, чем 3.
   Следующие программы выводят на экран результаты операций отношения для зна-
чений Verde и Violet типа данных Culoare.
           ПАСКАЛЬ                                     C++
Program P23;                             // Программа P23
  { Операции отношения над               /*   Операции отношения над
значениями порядкового типа }            значениями порядкового типа */
type Culoare = (Galben,                  #include <iostream>
      Verde, Albastru, Violet);          using namespace std;
begin                                    int main()
  writeln(Verde<Violet);                 {
  {true}                                 enum Culoare {Galben, Verde,
  writeln(Verde<=Violet);                     Albastru, Violet};
  {true}                                 cout<<(Verde<Violet)<<endl;
  writeln(Verde=Violet);                 //true
  {false}                                cout<<(Verde<=Violet)<<endl
  writeln(Verde>=Violet);                //true
  {false}                                cout<<(Verde==Violet)<<endl;
  writeln(Verde>Violet);                 //false
  {false}                                cout<<(Verde>=Violet)<<endl;
  writeln(Verde<>Violet);                //false
  {true}                                 cout<<(Verde>Violet)<<endl;
end.                                     //false
                                         cout<<(Verde!=Violet)<<endl;
                                         //true
                                         return 0;
                                         }
   Для значений порядковых типов данных можно определить предшествующее и
последующее значения.
   Значению с порядковым номером i предшествует значение с порядковым номером
i–1. За значением с порядковым номером i следует значение с порядковым номером i+1.


                                                                                67
     ПРИМЕЧАНИЕ
     В языке ПАСКАЛЬ для определения предшествующих и последующих значений
     применяются предопределенные функции pred и succ;
     В языке C++ предопределенных функций для нахождения предшествующих и после-
     дующих значений не существует. Следовательно, с этой целью будут использоваться
     эквивалентные операции, применяя операторы преобразования. В языке C++, в
     арифметических выражениях, любое значение перечисляемого типа рассматрива-
     ется как целое число, преобразование в int осуществляется по умолчанию, однако
     преобразование целого числа в перечисляемый тип должно быть запрошено явно.

     Например, для значений порядкового типа данных Culoare получаем:
             ПАСКАЛЬ                                       C++
 1)    pred(Verde) = Galben                  1)   Verde-1 == Galben
 2)    succ(Verde) = Albastru                2)   Verde+1 == Albastru
 3)    pred(Albastru) = Verde                3)   Albastru-1 == Verde
 4)    succ(Albastru) = Violet               4)   Albastru+1 == Violet
   Очевидно, что наименьшее значение не имеет предшествующего, а наибольшее –
последующего.
   Следующие программы выводят на экран значения, предшествующие и следующие
за ’B’, 0 и ’0’.
                                    ПАСКАЛЬ
Program P24;
 { Предшествующие и последующие значения }
begin
  writeln(pred(’B’));   { ’A’ }
  writeln(succ(’B’));   { ’C’ }
  writeln(pred(0));     { -1 }
  writeln(succ(0));     {   1 }
  writeln(pred(’0’));   { ’/’ }
  writeln(succ(’0’));   { ’1’ }
end.
                                        C++
// Программа P24
/* Предшествующие и последующие значения */
  #include <iostream>
using namespace std;
int main()
{
cout<<char(’B’-1)<<endl;   // ’A’
cout<<char(’B’+1)<<endl;   // ’C’
cout<<0-1<<endl;           // -1
cout<<0+1<<endl;           // 1
cout<<char (’0’-1)<<endl;  // ’/’
cout<<char(’0’+1)<<endl;   // ’1’
return 0;
}

68
   Отметим, что значения, предшествующие (или следующие) за порядковыми зна-
чениями 0 (тип integer/int) и ’0’ (тип char) не совпадают, так как типы этих
значений различны.

   ПРИМЕЧАНИЕ
   Тип данных real/float не является порядковым типом. Следовательно, для значе-
   ний вещественных типов невозможно определить порядковый номер, предшеству-
   ющее и последующее значения. Несоблюдение этого правила приводит к ошибкам.


  Вопросы и упражнения
  	Назовите порядковые типы данных. Какими общими свойствами они обладают?
  	Как определяются порядковые номера значений любого порядкового типа
    данных?
  	ПРОАНАЛИЗИРУЙТЕ! Что выведут на экран следующие программы?
             ПАСКАЛЬ                                      C++
Program P25;                              // Программа P25
type Zi = (L, Ma, Mi, J, V, S, D);        #include <iostream>
var z1, z2 : Zi;                          using namespace std;
begin                                     int main()
  z1:=Ma;                                 {
  writeln(ord(z1));                       enum Zi {L, Ma, Mi, J, V, S, D}
  z2:=pred(z1);                           z1,z2;
  writeln(ord(z2));                       z1=Ma;
  z2:=succ(z1);                           cout<<z1<<endl;
  writeln(ord(z2));                       cout<<z1-1<<endl;
  z1:=Mi; z2:=V;                          cout<<z1+1<<endl;
  writeln(z1<z2);                         z1=Mi; z2=V;
  writeln(z1>z2);                         cout<<(z1<z2)<<endl;
  writeln(z1<>z2);                        cout<<(z1>z2)<<endl;
end.                                      cout<<(z1!=z2)<<endl;
                                          return 0;
                                          }
  	ОБРАТИТЕ ВНИМАНИЕ! Удалите из нижеследующих программ строку,
    содержащую ошибку:
           ПАСКАЛЬ                          C++
Program P26;                              // Программа P26
 { Ошибка }                               #include <iostream>
var i : integer;                          #include <limits>
begin                                     using namespace std;
  i:=MaxInt;                              // Ошибка
  writeln(pred(i));                       int main()
  writeln(succ(i));                       {
end.                                      int i;
                                          i=INT_MAX;
                                          cout<<i-1<<endl;
                                          cout<<i+1<<endl;
                                          return 0;
                                          }

                                                                              69
   Что будет выведено на экран после запуска модифицированной программы
на выполнение?
   	Прокомментируйте следующую программу на языке ПАСКАЛЬ:
          Program P27;
           { Ошибка }
          var i : integer; x : real;
          begin
           i:=1; x:=1.0;
           writeln(ord(i));
           writeln(ord(x));
           writeln(pred(i));
           writeln(pred(x));
           writeln(succ(i));
           writeln(succ(x));
          end.

     	   Удалите строки, содержащие ошибки. Что будет выведено на экран после
         запуска модифицированной программы?




     2.9. Объявление типов данных
   Языки программирования предоставляют пользователю предопределенные типы
данных: целочисленные, вещественные, логические значения, символы и др. В случае
необходимости пользователь может создавать собственные типы данных, например
перечисляемые.



  Имя типа данных и множество его значений в языке ПАСКАЛЬ объявляются с по-
мощью следующих грамматических единиц:
     <Типы > ::= type <Описание типа>; { <Описание типа>;}
     <Описание типа> ::= <Идентификатор> = <Тип>
     <Тип> ::= <Идентификатор> | <Перечисляемый тип> | <Интервальный тип> |
	              <Ссылочный тип> |
             	<Тип-массив> | <Тип-запись> | <Тип-множество> | <Файловый тип>
     <Перечисляемый тип> ::= (<Идентификатор> {, <Идентификатор>})
     <Интервальный тип> ::= <Константа>..<Константа>
     Соответствующие синтаксические диаграммы приведены на рис. 2.2.
     Примеры:
     1)	 type T1 = (A, B, C, D, E, F, G, H);
     		       T2 = B..F;
     		       T3 = C..H;

70
2)	 type	Pozitiv = 1..MaxInt;
		       Natural = 0..MaxInt;
		       Negativ = -MaxInt..-1;	
3)	 type	Abatere = -10...+10;
		       Litera = ’A’..’Z’;
		       Cifra = ’0’..’9’;	


  <Типы>
                          Описание типа




<Описание типа>

            Идентификатор                           Тип



  <Тип>
                           Идентификатор

                           Перечисляемый тип


                           Интервальный тип


                              Тип-масив

                              Тип-запись

                           Tип-множество

                            Файловый тип

                           Ссылочный тип

      Рис. 2.2. Синтаксические диаграммы для описания типов данных

  <Tip enumerare>                                                    71
                                  Идентификатор
   Классификация типов данных языка ПАСКАЛЬ представлена на рис. 2.3. Ранее из-
ученные типы данных указаны на темном фоне.


                                 Типы данных




            Простые типы        Составные типы       Ссылочный тип



            Порядковые
               типы



                                                  массив



                                                  запись



                                                 множество



                перечисляемый                      файл



                интервальный


               Рис. 2.3. Классификация типов данных, язык ПАСКАЛЬ

   В некоторых конструкциях языка необходимо, чтобы переменные и константы при-
надлежали к идентичным или совместимым типам.
   Два типа являются идентичными, если они описываются одним и тем же именем
типа.
   Например, пусть
     	type 	
           T4 = integer;
     		    T5 = integer;
  Здесь типы integer, T4, T5 являются идентичными.
  Два типа могут быть идентичными и тогда, когда они описываются различными
именами типа при условии, что эти имена эквивалентны по свойству транзитивности.

72
  Например, пусть
  	type 	T6 = real;
  		     T7 = T6;
  		     T8 = T7;
   Здесь типы real, T6, T7 и T8 являются идентичными.
   Два типа называются совместимыми тогда, когда верно хотя бы одно из следующих
утверждений:
   1) рассматриваемые типы идентичны;
   2) один тип является интервальным типом второго;
   3) оба типа являются интервальными, с одним и тем же базовым типом.
   Например, при следующем объявлении:
   	 type	 Zi = (L, Ma, Mi, J, V, S, D);
   		      ZiDeLucru = (L, Ma, Mi, J, V);
   		      ZiDeOdihna = (S, D);
   		      Culoare = (Galben, Verde, Albastru, Violet);
типы Zi, ZiDeLucru, ZiDeOdihna являются совместимыми. Типы Zi и Culoare не
совместимы. Отсюда следует, что допустимы следующие операции отношения:
  	 L < D	                   Mi <> D	                 Verde <> Violet
  и т.д., а операции типа
  	 L < Violet	              Verde = V	              S <> Albastru
  запрещены.
  Кроме типов данных, определяемых пользователем явно с помощью ключевого слова
type, в программе могут быть описаны анонимные типы (типы без имени).
  Анонимный тип определяется неявно при описании переменных.
  Пример:
   	 var 	i : 1..20;
   		     s : (Alfa, Beta, Gama, Delta);
   		     t : Alfa..Gama;
   Отметим, что интервальный тип 1..20, перечисляемый тип (Alfa, Beta, Gama,
Delta) и интервальный тип Alfa..Gama не имеют собственных имен.
   Как правило, анонимные типы используются в программах с небольшим количе-
ством переменных.


   Язык C ++, разработанный для профессиональных целей, предлагает программистам
больше возможностей использовать и создавать новые типы данных.
   Таким образом, с помощью ключевого слова typedef с существующими типами
могут быть ассоциированы новые имена (псевдонимы):
  typedef <Имя типа> <Имя нового типа>;
  Примеры:
  1)	 typedef int intreg;
  		 intreg x1, i, t1, t2;

                                                                             73
     2)	 typedef float real;
     		 real a, b, c, x, delta, x1, x2;
   Согласно вышеприведенным примерам, идентификатор Integer становится вторым
именем типа данных int, а идентификатор Real – вторым именем типа данных float.
   Следовательно, хотя переменные x1, i, t1 и t2 объявлены как имеющие тип
Integer, на самом деле они будут иметь тип int. Аналогичным образом, хотя пере-
менные a, b, c, x, delta, x1 и x2 объявлены как имеющие тип Real, на самом
деле они будут иметь тип float.
   В повседневной практике псевдонимы используются для облегчения чтения больших
программ. Перечисляемые типы данных определяются с помощью ключевого слова
enum:
     enum <Имя типа> {<Идентификатор> {, <Идентификатор>};
  В грамматической конструкции, приведенной выше, грамматическая единица {<Иден-
тификатор> {, <Идентификатор>} представляет набор значений типа данных <Имя
типа>.
   Примеры:
   1)	 enum ZideLucru {Luni, Marti, Miercuri, Joi, Vineri};
   		 ZideLucru Z;
   2)	 enum GenDeMuzica {Blues, Etno, Folk, Disco, HipHop,
                              Rock, Pop, Jazz};
   		 GenDeMuzica G;
   В вышеприведенных примерах определены два типа данных перечисления:
ZideLucru и GenDeMuzica. Очевидно, что переменная Z может принимать значения
Luni, ..., Vineri, а переменная G - Blues, ..., Jazz.
   Отметим, что в языке C++ существует несколько способов классификации типов
данных: простые и структурированные, предопределенные (принадлежащие языку) и
определяемые пользователем, фундаментальные и производные.
   Наиболее часто используемый способ классификации типов данных приведен на
рисунке 2.3*.

                                   Типы данных


       Предопределенные
       (фундаментальные)        Производные           Определенные пользователем

                    целые                  массив                 структура

                 символьные                pointer               объединение

                  логические               ссылка              перечисляемые

                вещественные

                     void

                   Рис. 2.3.* Классификация типов данных, язык C++

74
   Следующие предопределенные типы являются фундаментальными: тип void, логи-
ческий тип bool, арифметические целочисленные типы char и int, а также арифмети-
ческие вещественные типы с плавающей запятой float и double. Все остальные типы
(массивы, функции, указатели, ссылки, структуры, объединения) являются производны-
ми типами, основанными на фундаментальных типах. Производные и определенные
пользователем типы будут изучаться позже.
   В некоторых конструкциях переменные и константы должны быть одинакового или
совместимого типа.
   Два типа идентичны, если они определены одним и тем же именем типа.
   Например, пусть
  	 typedef int T4;
  	 typedef int T5;
  или
  	 typedef int T4, T5;
   Здесь типы int, T4 и T5 идентичны.
   Два типа являются идентичными и в случае, если они определены разными именами,
однако эти имена эквивалентны через транзитивность.
   Например, пусть
  	 typedef double T6;
  	 typedef T6 T7;
  	 typedef T7 T8;
   Здесь double, T6, T7 и T8 идентичные типы.
   Вообще язык C++ предлагает программисту большую свободу в использовании ти-
пов данных, что объясняет его популярность в индустрии программных продуктов. Эта
свобода в основном отражается в манипуляциях с типами (что недопустимо в Паскале).
Вместе с тем язык ПАСКАЛЬ больше подходит для использования в учебных целях, а
намеренное ограничение степени свободы при манипулировании типами данных спо-
собствует соблюдению принципа «от простого к сложному».
   Наиболее очевидна эта «свобода» в случае типа char. Этот тип на самом деле
является целочисленным типом, представленным на одном байте (аналогично типу
byte в ПАСКАЛЕ). Таким образом, следующая последовательность кода является
вполне допустимой, а подобный «фейерверк» в программировании является обычным
явлением:
  	 int i;
  	 char c;
  	c=’A’;
  	i=c;
  	 cout<<″Код ASCII символа ″<<c<<″ равен ″<<i<<endl;
  	i=’A’+1;
  	 cout<<″и следующий символ имеет код ″<<i;
в результате выполнения этой последовательности операторов нна экране отобазится:
  	 Код ASCII символа A равен 65
  	 и следующий символ имеет код 66

                                                                               75
   Компиляторы C++ проверяют совместимость типов в следующих случаях:
   – при присваивании
   – при передаче параметров
   – при расчете значений выражений.
   Последствия проверки зависят от языковой спецификации и, возможно, от особен-
ностей операционной системы хост-компьютера.
   Помимо определяемых пользователем типов данных, явно использующих ключевое
слово typedef и enum, в программе на C++ также могут быть определены анонимные
(безымянные) типы данных.
   Анонимный тип данных определяется неявно при объявлении переменной.
     Примеры:
  1)	enum ZiDeOdihna {Sambata, Duminica}; // tip explicit 	
	    ZiDeOdihna Zi;
     2)	enum {Sambata, Duminica} Zi; // tip anonim
   В первом примере перечисляемый тип ZileDeOdihna был определен явно. Позже
этот тип использован для объявления переменной Zi. Во втором примере тип
                                                                      ​​ пере-
менной Zi не имеет имени и является анонимным, будучи объявлен по умолчанию.
   Обычно анонимные типы данных используются в программах с небольшим коли-
чеством переменных.



     Вопросы и упражнения
     	 ПРОАНАЛИЗИРУЙТЕ! Даны следующие программы:
                ПАСКАЛЬ                                  C++
Program    P28;                        // Программа P28
type T1    = -100..100;                #include <iostream>
     T2    = ’A’..’H’;                 using namespace std;
     T3    = (A, B, C, D, E, F, G, H); int main();
     T4    = A..E;                     {
     T5    = integer;                  enum T3 {A, B, C, D, E, F, G, H};
     T6    = real;                     typedef T3 T4;
     T7    = char;                     typedef int T5;
     T8    = boolean;                  typedef double T6;
var i :    T1;                         typedef char T7;
    j :    T5;                         typedef bool T8;
    k :    T2;                         T5 j;
    m :    T3;                         T3 m;
    n :    T4;                         T4 n;
    p :    real;                       double p;
    q :    T6;                         T6 q;
    r :    char;                       char r;
    s :    T7;                         T7 s;
    t :    boolean;                    bool t;

76
     z : T8;                         T8 z;
     y : real;                       double y;
begin                                // расчеты с использованием
  { расчеты с использованием }       // объявленных переменных
  { объявленных переменных }         cout<<″Конец″;
  writeln(’Конец’);                  return 0;
end.                                 }
 	  Укажите типы данных, используемые в программе на языке ПАСКАЛЬ/
    C++. Какие значения может принимать каждая переменная, описанная в  
    данной программе? Какие из указанных типов совместимы?
 	 (ПАСКАЛЬ) Укажите на синтаксических диаграммах рис.2.2 пути, соответ-
    ствующие описаниям типов данных из программы Р28.
 	 ПРОАНАЛИЗИРУЙТЕ! Укажите анонимные типы данных, используемые
    в следующих программах:
               ПАСКАЛЬ                               C++
Program P29;                        // Программа P29
type T1 = integer;                  #include <iostream>
      T2 = -150..150;               using namespace std;
      T3 = 1..5;                    int main()
var i : T1;                         {
     j : T2;                        typedef int T1;
     k : T3;                        enum {Rosu, Galben,Verde}
     m : 1..5;                      Semafor;
                                    enum {Iunie, Iulie, August} v;
                                    enum Numere {Unu, Doi,Trei,
     n : (Unu, Doi, Trei, Patru,
Cinci);                             Patru, Cinci};
begin                               T1 i;
  { вычисления, в которых           Numere n;
используются }                      /* вычисления, в которых
  { объявленные переменные }        используются объявленные
  writeln(’Конец’)                  переменные*
end.                                cout<<″Конец″;
                                    return 0;
                                    }
 	 Какие значения может принимать каждая переменная, описанная в данной
   программе на языке ПАСКАЛЬ/C++?
 	Даны следующие объявления:
                 ПАСКАЛЬ                              C++
     type T1   = boolean;               typedef   bool T1;
          T2   = T1;                    typedef   T1 T2;
          T3   = T2;                    typedef   T2 T3;
          T4   = T3;                    typedef   T3 T4;
     var x :   T4;                      T4 x;
 	 Какие значения может принимать переменная х? Назовите операции соответ-
   ствующего типа данных.
 	В каких случаях два типа данных являются идентичными? Приведите
   примеры.

                                                                       77
     	В каких случаях   два типа данных являются совместимыми? Приведите
       примеры.
     	Даны объявления:
                   ПАСКАЛЬ                                         C++
         type T1 = integer;                       typedef    int D1;
              T2 = T1;                            typedef    D1 D2;
              T3 = -5..+5;                        typedef    double D3;
              T4 = T3;                            typedef    D3 D4;
              T5 = -10..+10;                      enum D6     {A, B, C, D, E, F,
              T6 = (A, B, C, D, E, F,             G, H};
         G, H);                                   typedef    D6 D5;
              T7 = A..D;
              T8 = E..H;
              T9 = ’A’..’D’;
              T10 = ’E’ ..’H’;
     	    Найдите идентичные и совместимые типы данных.



     2.10. Объявление переменных
   Известно, что каждая встречающаяся в программе переменная должна быть ассо-
циирована с определенным типом данных. Для этого используются следующие грам-
матические конструкции:
   ПАСКАЛЬ
   <Переменные> ::= var <Объявление переменных>; {<Объявление переменных>;}
   <Объявление переменных> ::= <Идентификатор> {, <Идентификатор>} : <Тип>
     C++
   <Переменные> ::= <Объявление переменных>; {<Объявление переменных>;}
   <Объявление переменных> ::= <Тип> <Идентификатор> {,<Идентификатор>};
   Синтаксические диаграммы рассматриваемых грамматических единиц приведены
на рис. 2.4.

                 <Переменные>
                                     Объявление переменных




               <Объявление переменных>

                                Идентификатор                Тип




Рис. 2.4. Синтаксические диаграммы <Переменные> и <Объявление переменных>, ПАСКАЛЬ

78
              <Переменные>

                                  Объявление переменных




             <Объявление переменных>

                                Тип                  Идентификатор




 Рис. 2.4*. Синтаксические диаграммы <Переменные> и <Объявление переменных>, C++

   В объявлении переменных могут использоваться предопределенные типы данных
(целочисленные, вещественные, символьные, логические и др.) и типы, определяемые
пользователем (перечисляемые, массивы и т.д.).
   Примеры:

             ПАСКАЛЬ                                         C++
 1)   var i, j : integer;                  1)   int i,j;
          x : real;                             double x;
          p : boolean;                          bool p;
          r, s : char;                          char r,s;
 2)   type T1 = (A, B, C, D, E,            2)   enum T1 {A, B, C, D, E,
      F, G, H);                                 F, G, H};
           T2 = C..F;                           double x, y, z;
           T3 = 1..10;                          char r, s;
           T4 = ’A’..’Z’;                       int i, j;
      var x, y, z : real;                       T1 p;
          r, s : char;
          i, j : integer;
          k : T3;
          p : T1;
          q : T2;
          v : T4;
 3)   type Zi = (L, Ma, Mi, J,             3)   enum Zi {L, Ma, Mi, J, V,
      V, S, D);                                 S, D};
      var x, y : real;                          double x, y;
          z : Zi;                               Zi z;
          zl : L..V;                            enum {A,B,C} z1;
          m, n : 1..10;                         enum {True, False} m, n;
   Отметим, что в последнем примере тип переменных z1, m и n описывается непосред-
ственно в разделе объявления переменных. Следовательно, эти переменные принадлежат
анонимным типам данных.

                                                                               79
     Вопросы и упражнения
     	ПРОАНАЛИЗИРУЙТЕ! Определите тип переменных, используемых в
       следующей программе:
                   ПАСКАЛЬ                                C++
         Program P30;                        // Программа P30
         type T1 = integer;                  #include <iostream>
               Studii = (Elementare,         using namespace std;
         Medii, Superioare);                 int main()
               T2 = real;                    {
               Culoare = (Galben, Verde,     typedef int T1;
                        Albastru, Violet);   enum Studii {Elementare,
         var x : real;                       Medii, Superioare};
              y : T1;                        typedef double T2;
              i : integer;                   enum Culoare {Galben, Verde,
              j : T2;                        Albastru, Violet};
              p : boolean;                   float x;
              c : Culoare;                   T1 y;
              s : Studii;                    int i;
              q : Galben..Albastru;          T2 j;
              r : 1..9;                      bool p;
         begin                               Culoare c,q;
           { вычисления, в которых ис-       Studii s;
         пользуются объявленные перемен-     int r;
         ные}                                //* вычисления, в которых
           writeln(’Конец’);                 используются объявленные пе-
         end.                                ременные*/
                                             cout<<″Конец″;
                                             return 0;
                                             }
     	 Какие значения может принимать каждая переменная? Назовите операции
       соответствующего типа данных.
     	Укажите на синтаксических диаграммах рис. 2.4 пути, которые соответ-
       ствуют объявлению переменных в программе из задания 1.
     	ПРИМЕНИТЕ! Запустите следующие программы на выполнение и объясните
       сообщения, выведенные на экран в процессе компиляции программ. Измените
       программу таким образом, чтобы она выдавала на экран результат: 3
                   ПАСКАЛЬ                                C++
         Program P31;                        // Программа P31
         var i, j : integer;                 #include <iostream>
         begin                               using namespace std;
           i:=1; j:=2; k:=i+j;               int main()
           writeln(’k=’, k);                 {
         end.                                int i, j;
                                             i=1; j=2; k=i+j;
                                             cout<<″k=″<<k<<endl;
                                             return 0;
                                             }
     	Как объявляются переменные, принадлежащие анонимным типам данных?

80
  2.11. Описание констант
   Известно, что значения любого типа данных могут быть выражены через перемен-
ные или константы. Для того чтобы сделать программы более удобными для чтения и
модификации, языки программирования ПАСКАЛЬ и C++ позволяют представлять
константы в виде символических имен. Идентификатор, представляющий константе,
называется именем константы или просто константой. Везде, где в программе встреча-
ется такое имя, оно заменяется на соответствующее значение.
  Константы описываются с помощью следующих грамматических конструкций:
  ПАСКАЛЬ
  <Константы> ::= const <Описание константы>; { <Описание константы>;}
  <Описание константы> ::= <Идентификатор> = <Константа>
  <Константа> ::= [+ | -] <Число без знака> | [+ | -] <Имя константы> | <Строка
                символов>
   C++
  <Константы> ::= const <Описание константы>;
  <Описание константы> ::= <Тип> <Идентификатор> = <Константа> {
  <Константа> ::= [+ | -] <Число без знака> | [+ | -] <Имя константы> | <Строка
               символов>
  Синтаксические диаграммы данных грамматических единиц приведены на рис. 2.5.

              <Константы>

                                  Описание константы




              <Описание константы>

                        Идентификатор                    Константа


              <Константа>



                                                  Число без знака


                                                  Имя константы


                                                  Строка символов


       Рис. 2.5. Синтаксические диаграммы <Константы>, <Описание константы>
                               и <Константа>, ПАСКАЛЬ

                                                                               81
            <Константы>

                                  Описание константы



            <Описание константы>

                    Тип       Идентификатор               Константа



                <Константа>


                                                    Число без знака


                                                   Имя константы


                                                   Строка символов



Рис. 2.5*. Синтаксические диаграммы <Константы>, <Описание константы> и <Константа>, C++
     Примеры:

                ПАСКАЛЬ                                         C++
 1)    const a = 10;                          1)   const int a = 10;
             b = 9.81;                                   float b = 9.81;
             c = ’*’;                                    char c = '*';
             t = ’TEXT’;                                 string t = "TEXT";
 2)    const NumarCaractere = 60;             2)   const
             LungimePagina = 40;                     int NumarCaractere = 60;
                                                     int LungimePagina = 40;
 3)    const n = 10;                          3)   const int n = 10;
             m = 20;                                     int m = 20;
             Pmax = 2.15e+8;                               double Pmax = 2.15e+8;
             Pmin = -Pmax;                               double Pmin = -Pmax;
             S = ’STOP’;                                 string S ="STOP";
     В вышеприведенных примерах типами констант являются:
     a, NumarCaractere, LungimePagina, n, m – целочисленные;
     b, Pmax, Pmin – вещественные;
     c – char;
     t, S – строки символов.

82
  В нижеследующих программах описываются константы Nmax, Nmin, Pi, Separator,
Indicator и Mesaj. Значения этих констант выводятся на экран.

              ПАСКАЛЬ                                    C++
Program P32;                                // Программа P32
 { Описание констант }                      #include <iostream>
const Nmax = 40; {Константа                 using namespace std;
типа integer}                               int main()
   Nmin = -Nmax; {Константа                 {
типа integer}                               const int Nmax = 40;
   Pi = 3.14; {Константа типа               const int Nmin = -Nmax;
real}                                       const double Pi = 3.14;
   Separator = ’\’;                         const char Separator = ’/’;
   {Константа типа char}                    const bool Indicator = true;
   Indicator = TRUE;                        const string Mesaj = ″
   {Константа типа boolean}                      Проверьте принтер″;
   Mesaj =                                  cout<<Nmax<<endl;
   ’Проверьте принтер’;                     cout<<Nmin<<endl;
         {Строка символов }                 cout<<Pi<<endl;
begin                                       cout<<Separator<<endl;
  writeln(Nmax);                            cout<<Indicator<<endl;
  writeln(Nmin);                            cout<<Mesaj<<endl;
  writeln(Pi);                              /*вычисления,в которых исполь-
  writeln(Separator);                       зуются данные константы */
  writeln(Indicator);                       return 0;
  writeln(Mesaj);                           }
{ вычисления, в которых ис-
пользуются данные константы}
end.
   Обычно данные, которые не изменяются в процессе выполнения программы, на-
пример, количество строк таблицы, число π, ускорение свободного падения g и т.д.,
описываются в виде констант. Это позволяет изменять постоянные значения, не изменяя
всей программы в целом.
   В нижеследующих программах длина L и площадь S круга вычисляются по формулам:

                                  L=2πr; S = πr2 ,
где r является радиусом окружности. Число π представлено в виде константы Рi = 3.14.

          ПАСКАЛЬ                                       C++
Program P33;                                // Программа P33
 { Длина и площадь круга }                  // Длина и площадь круга
const Pi = 3.14;                            #include <iostream>
var L, S , r : real;                        using namespace std;

                                                                                 83
begin                                       int main()
  writeln(’Введите радиус r=’);             {
  readln(r);                                const double Pi = 3.14;
  L:=2*Pi*r;                                float L, S , r;
  writeln(’Длина L=’, L);                   cout<<″Введите радиус r=″;
  S:=Pi*r*r;                                cin>>r;
  writeln(’Площадь S=’, S);                 L=2*Pi*r;
end.                                        cout<<″Длина L=″<<L<<endl;
                                            S=Pi*r*r;
                                            cout<<″Площадь S=″<<S;
                                            return 0;
                                            }
   Если пользователю необходимы более точные результаты, изменяется только строка
программы, в которой указано значение константы:

      		         П А С К А Л Ь 			                       C++
      const Pi = 3.141592654;	          const double Pi = 3.141592654;
   Оставшаяся часть программы остается неизменной.
   В отличие от переменных, значения констант не могут изменяться посредством
операции присваивания или считывания. Несоблюдение данного правила приводит к
ошибкам, которые обнаруживаются при компиляции программы.


     Вопросы и упражнения
     	Определите типы данных следующих констант:
            ПАСКАЛЬ                                      C++
 1)    const a   =   29.1;             1)    const   double a = 29.1;
             b   =   TRUE;                   const   bool b = TRUE;
             c   =   18;                     const   int c = 18;
 2)    const d   =   -16.82e-14;       2)    const   double d = -16.82e-14;
             f   =   -d;                     const   double f = -d;
             i   =   15;                     const   int i = 15;
             j   =   ’15’;                   const   string j = "15";
             n   =   ’-d’;                   const   string n = "-d";
 3)    const t   =   ’F’;              3)    const   char t = ’F’;
             q   =   ’1’;                    const   char q = ’1’;
             c   =   ’18’;                   const   string c = ″18″;
 4)    const x   =   65;               4)    const   int x = 65;
             q   =   FALSE;                  const   bool q = FALSE;
             y   =   -x;                     const   int y = -x;
             m   =   ’PAUZA’;                const   string m = ″PAUZA″;

84
  	ПРИМЕНИТЕ! Напишите программу, которая выводит на экран значения
     констант из задания 1.
  	Покажите на синтаксических диаграммах рис. 2.5 пути, которые соответ-
     ствуют описаниям констант из программы Р32.
  	 ПРОАНАЛИЗИРУЙТЕ! Приведенные ниже программы содержат ошибки.
     Выявите ошибки, объясните причину их возникновения, доработайте про-
     грамму, чтобы она действовала без ошибок.
              ПАСКАЛЬ                              C++
      Program P34;                   // Программа P34
       { Erori }                     #include <iostream>
      const Nmax = 40;               using namespace std;
         Nmin = -Nmax;               // Erori
         Pi = 3.14;                  int main()
         Separator = ’\’;            {
         Indicator = TRUE;           const int Nmax = 40;
      begin                          const int Nmin = -Nmax;
        readln(Nmax);                const double Pi = 3.14;
        writeln(Nmax);               const char Separator = ’/’;
        writeln(Nmin);               const bool Indicator = true;
        Nmax:=10;                    cin>>Nmax;
        writeln(Nmax);               cout<<Nmax<<endl;
        writeln(Pi);                 cout<<Nmin<<endl;
        writeln(Separator);          Nmax=10;
        writeln(Indicator);          cout<<Nmax<<endl;
      end.                           cout<<Pi<<endl;
                                     cout<<Separator<<endl;
                                     cout<<Indicator<<endl;
                                     return 0;
                                     }
  Объясните сообщения, выводимые на экран в процессе компиляции модифи-
цированных программ.
  	Даны программы:
              ПАСКАЛЬ                              C++
      Program P35;                   // Программа P35
      const t = ’1’;                 #include <iostream>
            s = -t;                  using namespace std;
      begin                          int main()
        writeln(s);                  {
      end.                           const char t = ’1’;
                                     const char s = -t;
                                     cout<<s;
                                     return 0;
                                     }
  	    Какие сообщения будут выведены на экран в процессе компиляции?

                                                                        85
     	ПРОАНАЛИЗИРУЙТЕ! Что появится на экране после запуска на выпол-
       нение следующих программ?
                 ПАСКАЛЬ                              C++
         Program P36;                   // Программа P36
         const i = 1;                   #include <iostream>
               j = i;                   using namespace std;
               k = j;                   int main()
         var x, y, z : integer;         {
         begin                          const char i = 1;
           x:=i+1; writeln(x);          const int j = i;
           y:=j+2; writeln(y);          const int k = j;
           z:=k+3; writeln(z);          int x, y, z;
         end.                           x=i+1; cout<<x<<endl;
                                        y=j+2; cout<<y<<endl;
                                        z=k+3; cout<<z;
                                        return 0;
                                        }
     	Даны программы:
                 ПАСКАЛЬ                              C++
         Program P37;                   // Программа P37
         const a = 1;                   #include <iostream>
               b = 2;                   using namespace std;
               c = 3;                   int main()
               d = 4;                   {
         var i, j, k : integer;         const char a = 1;
         begin                          const int b = 2;
           i:=a+1; writeln(i);          const int c = 3;
           j:=b+1; writeln(j);          const int d = 4;
           k:=c+1; writeln(k);          int i, j, k;
           d:=a+1; writeln(d);          i=a+1; cout<<i<<endl;
         end.                           j=b+1; cout<<j<<endl;
                                        k=c+1; cout<<k<<endl;
                                        d=a+1; cout<<d;
                                        return 0;
                                        }
     	    Объясните сообщения, выводимые на экран.
     	Исключите из следующих программ строку, в которой содержится ошибка.
                 ПАСКАЛЬ                              C++
         Program P38;                   // Программа P38
         const a = 1;                   #include <iostream>
         var i, j : integer;            using namespace std;
         begin

86
      writeln(’Введите i=’);         int main()
     readln(i); j:=i+a;              {
     writeln(j);                     const int a = 1;
      writeln(’Введите a=’);         int i, j;
     readln(a);                      cout<<″Введите i=″;
     j:=i+a;                         cin>>i; j=i+a;
     writeln(j);                     cout<<j;
   end.                              cout<<″Введите a=″;
                                     cin>>a;
                                     j=i+a;
                                     cout<<j;
                                     return 0;
                                     }
  Что появится на экране после запуска модифицированных  программ на вы-
полнение?


  Тест для самопроверки № 2
  1. Объясните значение термина тип данных. Назовите по крайней мере два типа
данных и приведите по нескольку примеров данных соответствующих типов.
  2. Каким образом представляются данные в программе на языке ПАСКАЛЬ?
Объясните значения терминов величина, переменная и константа. Какова разница
между переменной и константой?
  3. Укажите типы данных, объявленных в следующей программе:
               ПАСКАЛЬ                                   C++
   Program TA2;                            // Программа ТА2
    { Простые типы данных }                #include <iostream>
   var i, j : integer;                     using namespace std;
        a, b, c : real;                    // Простые типы данных
        s : char;                          int main()
        p : boolean;                       {
   begin                                   int i, j;
     i:=5; j:=i+9;                         double a, b, c;
     writeln(i); writeln(j);               char s;
     a:=1.0; b:=1.0e-01; c:=-2.001;        bool p;
     writeln(a);                           i=5; j=i+9;
     writeln(b);                           cout<<i<<endl;
     writeln(c);                           cout<<j<<endl;
     s:=’A’; writeln(s);                   a=1.0; b=1.0e-01; c=-2.001;
     p:=true; writeln(p);                  cout<<a<<endl;
   end.                                    cout<<b<<endl;
                                           cout<<c<<endl;
                                           s=’A’; cout<<s<<endl;
                                           p=true; cout<<p;
                                           return 0;
                                           }
   Пример: i – переменная целого типа; a – переменная вещественного типа; 5 –
целочисленная константа и т.д.

                                                                          87
   4. Как определяются целочисленные типы данных в языке программирования,
который вы изучаете и каково множество их значений? Какие операции можно
выполнять с этими значениями?
     5. Даны следующие программы:
                ПАСКАЛЬ                                  C++
     Program TA3;                          // Программа TA3
      { Ошибки переполнения }              #include <iostream>
     var x, y, z : integer;                using namespace std;
     begin                                 int main()
       writeln(’Введите целые числа        {
     x, y:’);                              int x, y, z;
       readln(x, y);                       cout<<″Введите целые числа
       z:=x*y; writeln(’x*y=’, z);         x, y:″;
     end.                                  cin>>x>>y;
                                           z=x*y; cout<<″x*y=″<<z;
                                           return 0;
                                           }

  Приведите примеры значений переменных x и y, при которых появляются
ошибки переполнения.

  6. Каково множество значений вещественных типов данных? Какие операции
допустимы с этими значениями? Являются ли результаты этих операций точными?

     7. Даны следующие программы:

                ПАСКАЛЬ                                  C++
     Program TA4;                          // Программа TA4
      { Ошибки переполнения }              #include <iostream>
     var x, y, z : real;                   using namespace std;
     begin                                 int main()
       writeln(’Введите вещественные       {
     числа x, y:’);                        double x, y, z;
       readln(x, y);                       cout<<″Введите вещественные
       z:=x*y; writeln(’x*y=’, z);         числа x, y:″;
     end.                                  cin>>x>>y;
                                           z=x*y; cout<<″x*y=″<<z;
                                           return 0;
                                           }

   Приведите примеры значений переменных x и y, при которых появляются ошибки
переполнения.

   8. Каково множество значений типа данных boolean/bool? Какие операции до-
пустимы с этими значениями?

88
  9. Напишите таблицы истинности для логических операций.
  PASCAL:	    not, and и or;
  C++:		      !, && și ||.
   10. Проанализируйте следующие программы. Какие сообщения будут выведены
на экран в результате выполнения программ на компьютере?
               ПАСКАЛЬ                                   C++
   Program TA5;                            // Программа ТА5
   var p, q, r : boolean;                  #include <iostream>
   begin                                   using namespace std;
     writeln(’Введите логические           int main()
   значения p, q:’);                       {
     readln(p, q);                         bool p, q, r;
     r:=p and q;                           cout<<″Введите логические
     writeln(q);                           значения p, q:″;
   end.                                    cin>>p>>q;
                                           r=p && q;
                                           cout<<q;
                                           return 0;
                                           }
  11. Каково множество значений типа данных char? Как упорядочено это мно-
жество? Какие операции можно выполнять со значениями типа char?
  12. Напишите программу, которая выводит на экран порядковые номера десятич-
ных цифр.
   13. Каково множество значений перечисляемого типа данных? Как упорядочено
это множество? Какие операции можно выполнять с этими значениями?
  14. Напишите программу, которая выводит на экран порядковые номера значе-
ний следующих перечисляемых типов:
  PASCAL
  1)	   type FunctiaOcupata = (Muncitor=10, SefDeEchipa, Maistru,
  	     SefDeSantier, Director);

  2)	   type StareaCivila = (Casatorit, Necasatorit);

  C++
  1)	   enum FunctiaOcupata {Muncitor=10, SefDeEchipa, Maistru,
  	     SefDeSantier, Director};

  2)	   enum StareaCivila {Casatorit, Necasatorit};

   15. (ПАСКАЛЬ) Каким образом определяется тип данных интервал? Каково
множество значений типа данных интервал? Какие операции допустимы с этими
значениями?

                                                                          89
     16. Какие значения может принимать каждая из объявленных ниже переменных?
                   ПАСКАЛЬ                                C++
     type T1   =   ’A’..’Z’;                typedef   char T1;
          T2   =   1..9;                    typedef   int T2;
          T3   =   ’0’..’9’;                typedef   char T3;
          T4   =   (Alfa, Beta, Gama,       enum T4   {Alfa, Beta, Gama,
     Delta);                                Delta};
     var p :   T1;                          T1 p;
         q :   T2;                          T2 q;
         r :   T3;                          T3 r;
         s :   char;                        char s;
         t :   integer;                     int t;
         u :   T4;                          T4 u;
     (ПАСКАЛЬ) Назовите базовый тип каждого из интервальных типов данных.
     17. Назовите порядковые типы данных. Каковы их общие свойства?
     18. Что выводят на экран следующие программы?
                   ПАСКАЛЬ                                C++
     Program TA6;                           // Программа TA6
     type Culoare = (Galben, Verde,         #include <iostream>
     Albastru, Violet);                     using namespace std;
     begin                                  int main()
       writeln(pred(’Z’));                  {
       writeln(succ(’D’));                  enum Culoare {Galben, Verde,
       writeln(pred(-5));                   Albastru, Violet};
       writeln(succ(9));                    cout<<char(’Z’-1)<<endl;
       writeln(ord(Verde));                 cout<<char(’D’+1)<<endl;
       writeln(Ord(Violet));                cout<<-5-1<<endl;
     end.                                   cout<<9+1<<endl;
                                            cout<<Verde<<endl;
                                            cout<<Violet;
                                            return 0;
                                            }

     19. Что выводят на экран следующие программы?
                   ПАСКАЛЬ                                C++
     Program TA7;                           // Программа TA7
     type Nivel = (A, B, C, D, E, F,        #include <iostream>
     G);                                    using namespace std;
     var n, m : Nivel;                      int main()
     begin                                  {
       n:=B; writeln(ord(n));               enum Nivel {A, B, C, D, E,
       m:=pred(n); writeln(ord(m));         F, G};
       m:=succ(n); writeln(ord(m));

90
     n:=C; m:=E;                           Nivel n, m;
     writeln(n<m);                         n=B; cout<<n<<endl;
     writeln(n>m);                         cout<<n-1<<endl;
     writeln(n<>m);                        cout<<n+1<<endl;
   end.                                    n=C; m=E;
                                           cout<<(n<m)<<endl;
                                           cout<<(n>m)<<endl;
                                           cout<<(n!=m);
                                           return 0;
                                           }
   20. Объясните следующие термины: идентичные типы, совместимые типы,
анонимные типы.
  21. Заданы объявления:
               ПАСКАЛЬ                                   C++
   type T1 = integer;                      typedef int T1;
        T2 = T1;                           typedef T1 T2;
        T3 = -5..+5;                       typedef int T3;
        T4 = T3;                           typedef T3 T4;
        T5 = -10..+10;                     typedef int T5;
        T6 = (A, B, C, D, E, F, G, H);     enum T6 {A, B, C, D, E, F,
        T7 = A..D;                         G, H};
        T8 = E..H;                         typedef T6 T7;
        T9 = ’A’..’D’;                     typedef T6 T8;
        T10 = ’E’ ..’H’;                   typedef char T9;
   var x : 1..100;                         typedef char T10;
      y : (Alfa, Beta, Gama, Delta);       int x;
                                           enum {Alfa, Beta, Gama,
                                           Delta} y;
  Укажите идентичные типы, совместимые типы и анонимные типы данных.
  22. Определите тип каждой из следующих констант:
               ПАСКАЛЬ                                   C++
   const Alfa = 5;                         const int Alfa = 5;
         Beta = 12.485;                    const float Beta = 12.485;
         Indicator = true;                 const bool Indicator = true;
         Mesaj = ’Ошибка                   const string Mesaj =
   переполнения’;                          ″Ошибка переполнения″;
         Semn = ’+’;                       const char Semn = ’+’;
         Inscris = ’12.485’;               const string Inscris =
                                           ″12.485″;

   23. В некотором алгоритме используются целые переменные i, j, вещественные
переменные x, y, константы 3,14 и 9,8. Напишите на языке программирования,
который вы изучаете, объявления для описания соответствующих переменных и
констант.

                                                                          91
Глава 3

                                                        ОПЕРАТОРЫ

     3.1. Концепция действия
   Согласно концепции действия, реализованной в изучаемом языке, компьютер яв-
ляется исполнителем, рабочая среда которого состоит из множества всех переменных
и констант, объявленных в программе. В ходе выполнения программы исполнитель
осуществляет над величинами из рабочей среды определенные действия, например,
сложение или вычитание, считывание с клавиатуры или вывод на экран и т.п. Очевидно,
что в результате этих действий значения переменных могут изменяться, в то время как
значения констант – нет.
   Действия, необходимые для обработки данных, и порядок их выполнения задаются
с помощью операторов. Существуют две категории операторов:
   1) простые операторы;
   2) структурированные операторы.
   Простые операторы не содержат других операторов. Простыми операторами яв-
ляются:
   – оператор присваивания;
   – оператор вызова (процедуры);
   – оператор перехода;
   – пустой оператор.
   Структурированные операторы составлены из других операторов. Структуриро-
ванными операторами являются:
   – составной оператор;
   – операторы условного перехода (ветвления) (в языке ПАСКАЛЬ: if, case; в языке
C++: if, switch)
   – операторы повторения (цикла) (в языке ПАСКАЛЬ: for, while, repeat; в языке
C++: for, while, do while)
   – оператор with (только в языке ПАСКАЛЬ).
   Операторы условного перехода применяются для программирования алгоритмов с
разветвлениями, а операторы повторения – для программирования циклических алго-
ритмов. Напомним, что циклические алгоритмы используются для описания многократ-
но повторяющихся действий, а алгоритмы с разветвлениями – для выбора необходимых
действий в зависимости от условий из рабочей среды исполнителя.
   Каждому оператору может предшествовать метка. Ссылка на метку указывается в
операторе перехода goto. Напомним, что метка – это целое число без знака (см. пара-
граф 1.10).
   Синтаксическая диаграмма <Оператор> показана на рис. 3.1. Напоминаем, что метка
отделяется от оператора с помощью символа «:» (двоеточие).

92
 <Оператор>
                       Метка


                       Присваивание

                     Вызов процедуры

                      Оператор goto

                     Пустой оператор

                   Составной оператор

                       Оператор if

                      Оператор case

                      Оператор for

                     Оператор while

                    Оператор repeat

                      Оператор with



<Оператор>
                       Метка


                      Присваивание

                  Составной оператор

                      Оператор if

                    Оператор switch

                     Оператор for

                    Оператор while

                  Оператор do while

                    Оператор break

    Рис. 3.1. Синтаксическая диаграмма <Оператор>

                                                    93
   В программах на языке ПАСКАЛЬ / C++ количество операторов в строке не огра-
ничено, один оператор может занимать одну или более строк, а в одной строке может
быть несколько операторов. В качестве разделителя операторов используют символ «;»
(точка с запятой).



     3.2. Выражения
   Формулы для вычисления значений представляются на языке ПАСКАЛЬ/ C++ в
виде выражений. Выражения состоят из операндов (констант, переменных, ссылок на
функции) и операций. Операции классифицируются следующим образом:
     ПАСКАЛЬ
   <Мультипликативная операция> ::= * | / | div | mod | and
   <Аддитивная операция> ::= + | – | or
   <Операция отношения> ::= < | <= | = | >= | > | <> | in
     C++
   <Мультипликативная операция> ::= * | / | % | &&
   <Аддитивная операция> ::= + | – | ||
   <Операция отношения> ::= < | <= | == | >= | > | !=
   Выражения состоят из факторов (множителей), термов (слагаемых) и простых вы-
ражений.
   Фактор состоит из отдельных переменных, констант без знака, обозначений функ-
ций и др.
     <Фактор> ::= <Переменная> | <Константа без знака> | <Вызов функции> |
     	           <Отрицание> <Фактор> |(<Выражение>) | <Конструктор множества>
     Примеры:
                ПАСКАЛЬ                                   C++
 1)    15                                 1)   15
 2)    x                                  2)   x
 3)    sin(x)                             3)   sin(x)
 4)    not p                              4)   !p
     Терм имеет вид:
     <Терм> ::= <Фактор> {<Мультипликативная операция> <Фактор>}
     Примеры:
                ПАСКАЛЬ                                   C++
 1)    15                                 1)   15
 2)    x                                  2)   x
 3)    x*y*z                              3)   x*y*z
 4)    p and q                            4)   p && q

94
  Под простым выражением понимается:
  <Простое выражение> ::= [+|–]<Терм>{<Аддитивная операция> <Терм>}
  Примеры:

              ПАСКАЛЬ                                         C++
 1)    +15                                  1)      +15
 2)    p or q                               2)      p || q
 3)    sin(x)/3+cos(x)                      3)      sin(x)/3+cos(x)
  В свою очередь выражение имеет вид:
  <Выражение> ::= <Простое выражение> {<Операция отношения>
  													 <Простое выражение>}
  Примеры:

              ПАСКАЛЬ                                         C++
 1)    –15                                  1)      –15
 2)    15*x+sin(x)/3<>11                    2)      15*x+sin(x)/3 != 11
 3)    x+6>z–3.0                            3)      x+6>z–3.0
   Пусть переменные a и b имеют целочисленный тип, c и d – логический (boolean),
а x и y – вещественный. Значения этих переменных: a = 2, b = 8, c = true, d =
false, x = -2,5 и y = 1,4.

                            Операции в языке ПАСКАЛЬ
 Операции                   Описание                               Примеры
Унарные операции
  + (знак)   Обозначает положительное число               +2, +0.25, +1999
  − (знак)   Обозначает отрицательное число               -2, -0.25, -1999
      not    Отрицание (логический оператор)              not(c)  результат false
Бинарные операции
                                                          a+b    результат 10
       +     Сложение
                                                          a+x    результат −0,5
                                                          a−b    результат −6
       −     Вычитание
                                                          a−x    результат 4,5
                                                          a*b    результат 16
       *     Умножение
                                                          a*y    результат 2,8
                                                          a/b    результат 0,25
       /     Деление
                                                          b/a    результат 4,0
                                                          a div   b  результат 0
      div    Частное без остатка двух целых чисел
                                                          b div   a  результат 4
             Остаток от деления нацело двух целых         a mod   b  результат 8
      mod
             чисел                                        b mod   a  результат 0

                                                                                    95
        <
                Проверяет, меньше ли первый операнд      a<b  результат true
                второго.                                 b<a  результат false
                Проверяет, меньше ли первый операнд вто- a<=b  результат true
       <=
                рого или равен ему.                      b<=a  результат false
                Проверяет, больше ли первый операнд, чем a>b  результат false
        >
                второй.                                  b>a  результат true

       >=
                Проверяет, больше ли первый операнд      a>=b  результат false
                второго или равен ему.                   b>=a  результат true

        =
                Проверяет, равен ли первый операнд вто-     a=b  результат false
                рому.                                       a=x  результат false

       <>
                Проверяет, отличается ли первый операнд     a<>b  результат true
                от второго.                                 b<>y  результат true
                                                            c and d  результат false
                Логическое произведение. Если оба опе-
      and                                                   c and c  результат true
                ранда истинны, результат тоже истинен.
                                                            d and d  результат false
                                                            c or d  результат true
                Логическая сумма. Если хотя бы один опе-
       or                                                   c or c  результат true
                ранд истинен, результат будет истинным.
                                                            d or d  результат false


                                     Операции в C++
 Операции                      Описание                              Примеры
Унарные операции
     + (знак)   Обозначает положительное число              +2, +0,25, +1999
     − (знак)   Обозначает отрицательное число              –2, –0,25, –1999
        !       Логическое отрицание                        !(c)  результат false
       ++       Инкремент.
                Есть два способа увеличить переменную x:
                •	 Постинкремент: x++. Приращение про-      ++a+b  результат 11.
                    изводится после вычисления выражения,   Значение a увеличилось до
                    в котором появляется ++.                вычисления выражения.
                •	 Предварительный инкремент: ++x. При-     (a++)+b  результат 10.
                    ращение выполняется до вычисления       Значение a увеличилось по-
                    выражения, в котором появляется ++.     сле вычисления выражения.
       −−       Декремент.
                Операция уменьшения переменной x может
                быть:
                •	 Постдекремент: x--. Уменьшение вы-       --a+b  результат 9.
                   полняется после вычисления выраже-       Значение a уменьшилось до
                   ния, в котором появляется --.            вычисления выражения.
                •	 Предварительный декремент: --x. Умень-   (a--)+b  результат 10.
                   шение выполняется до вычисления выра-    Значение a уменьшилось по-
                   жения, в котором появляется --.          сле вычисления выражения.

96
Бинарные операции

           Сложение                                   a+b  результат 10
    +
                                                      a+x  результат −0,5
                                                      a−b  результат −6
    −      Вычитание
                                                      a−x  результат 4,5
                                                      a*b  результат 16
    *      Умножение
                                                      a*y  результат 2,8
           Деление. Если хотя бы один операнд ве-
                                                      a/x  результат −0,8
           щественный, то возвращаемый результат
           будет результатом деления «с запятой».     y/x  результат −0,56
    /      Частное от деления. Если оба операнда
           являются целыми числами, то возвращае-     a/b  результат 0
           мый результат будет целым числом от их     b/a  результат 4
           деления.
           Modulo. Остаток от деления нацело двух     a % b  результат 8
    %
           целых чисел.                               b % a  результат 0
           Проверяет, меньше ли первый операнд        a<b  результат true
    <
           второго.                                   b<a  результат false
           Проверяет, меньше ли первый операнд вто- a<=b  результат true
   <=
           рого или равен ему.                      b<=a  результат false
           Проверяет, больше ли первый операнд, чем a>b  результат false
    >
           второй.                                  b>a  результат true
           Проверяет, больше ли первый операнд        a>=b  результат false
   >=
           второго или равен ему.                     b>=a  результат true
           Проверяет, равен ли первый операнд вто-    a==b  результат false
   ==
           рому.                                      a==x  результат false
           Проверяет, отличается ли первый операнд    a!=b  результат true
   !=
           от второго.                                b!=y  результат true
                                                      c && d  результат false
           Логическое произведение. Если оба опе-
   &&                                                 c && c  результат true
           ранда истинны, результат будет истинным.
                                                      d && d  результат false
                                                      c || d  результат true
           Логическая сумма. Если хотя бы один опе-
   ||                                                 c || c  результат true
           ранд истинен, результат будет истинным.
                                                      d || d  результат false
Тернарные операции
           Операция ? имеет форму:                    a % 2 == 0? ″par″
           <exp1> ? <exp2>:<exp3>                     : ″impar″  результат
           где <exp1> логическое выражение. Когда     ″par″
           <exp1> истина (true), результат опера-     x < 0 ? x*2 : x-2
    ?      ции ? равен <exp2>, а когда ложь(false),    результат x *2=−5
           результат операции ? равен <exp3>.
           <exp1> и <exp1> должны иметь резуль-
           таты одинакового типа либо совместимых     a < b ? b : a  результат 8
           типов.                                     a < b ? a : b  результат 2


                                                                               97
    Тип результата вычисления выражения определяется типом операндов и соответствую-
щими операциями. Эти правила будут изучены в следующих параграфах.
    Синтаксические диаграммы рассмотренных грамматических единиц приведены на рис.
3.2 и 3.3.
              <Мультипликативная операция>




              <Аддитивная операция>




              <Операция отношения>




            Рис. 3.2. Синтаксические диаграммы операций, язык ПАСКАЛЬ


              <Мультипликативная операция>


                                   /       %       &&



              <Аддитивная операция>


                                          ||



              <Операция отношения>


                                                               !=



               Рис. 3.2*. Синтаксические диаграммы операций, язык C++

98
  <Фактор>
                          Переменная

                      Константа без знака

                         Вызов функции

                                Фактор

                          Выражение

                         Конструктор
                          множества


   <Терм>
                            Фактор


                      Мультипликативная
                           операция




 <Простое выражение>




                                       Терм

                                  Аддитивная
                                   операция



   <Выражение>
                      Простое выражение



                      Операция отношения

Рис. 3.3*. Синтаксические диаграммы для определения выражений

                                                                99
   Из синтаксических диаграмм для определения выражений видно, что они опреде-
лены рекурсивно:
   • выражение состоит из операнда или операции, примененной к операндам;
   • операнд состоит из литерала (англ. literal - фиксированное значение), идентифика-
тора переменной или записанного в круглых скобках выражения.
   Например, выражение a*(b+1) состоит из операции умножения *, примененной
к операндам a и (b+1), первый операнд – это идентификатор, второй – это выражение
b+1. В свою очередь, это выражение состоит из операции сложения +, применяемой к
идентификатору и литералу.
   Выражение, взятое в скобки, превращается в фактор. Факторы могут образовывать
новые термы, простые выражения, выражения и т.д.
   Примеры:
         Математическая                Запись                       Запись
             запись              на языке ПАСКАЛЬ                на языке C++

 1)                                (a+b)/(c+d)                  (a+b)/(c+d)

 2)                           (–b+sin(b–c))/(2*a)           (–b+sin(b–c))/(2*a)

 3)                                  –1/(x*y)                     –1/(x*y)

 4)                               (p<q)and(r>s)                (p<q)&&(r>s)
 5)                                not (x or y)                  !(x || y)

 6)                             1/(a+b)>1/(c+d)              1/(a+b)>1/(c+d)

   Вызов функции может появляться везде, где допустимо присутствие константы или
переменной (рис. 3.3). Языки программирования содержат ряд стандартных функций,
известных любой программе. Эти функции представлены в таблице 3.1.


                                                                         Таблица 3.1
                  Предопределенные функции языков ПАСКАЛЬ и C++

                                               Запись                Запись
      Математическая запись
                                         на языке ПАСКАЛЬ         на языке C++

Абсолютное значение |x|              abs(x)                   abs(x) или fabs(x)

Синус sin x                          sin(x)                   sin(x)
Косинус cos x                        cos(x)                   cos(x)
Арктангенс arctg x                   arctan(x)                atan(x)
              2
Квадрат x x                          sqr(x)                   pow(x,2)
              n
Степень x x                          –                        pow(x,n)

100
Степень 2 2x                          –                           exp2(x)
Квадратный корень                     sqrt(x)                     sqrt(x)
Экспоненциальная функция e ex         exp(x)                      exp(x)
Натуральный логарифм ln x             ln(x)                       log(x)
Логарифм по основанию 10 числа
                               –                                  log10(x)
x log10x
Округление вещественного числа x round(x)                         round(x)
Целая часть вещественного числа x     trunc(x)                    trunc(x)
Округление x к ближайшему целому,
                                      –                           ceil(x)
большему, чем x
Усечение x до ближайшего целого
                                      –                           floor(x)
числа, меньшего, чем оно
Четность числа i (false для четного
                                      odd(i)                      –
i и true в противном случае))
Порядковый номер элемента v           ord(v)                      –
Предшествующий элемент                pred(v)                     –
Следующий элемент                     succ(v)                     –
Символ с порядковым номером i         chr(i)                      –
Признак конца файла                   eof(f)                      EOF
Признак конца строки                  eoln(f)                     –


  ПРИМЕЧАНИЕ
  Для работы математических функций в программу C++ должна быть включена
  библиотека cmath.



  Вопросы и упражнения
  	ПРИМЕНИТЕ! Перепишите следующие выражения согласно правилам
    изучаемого языка:
  	   a)	a2+b2;	                                h)	 2πr;	
            2               2
  	   b)	a + 2ab + b ;	                         i)	 πr2;
                   2
  	   c)	 (a + b) ;	                            j)	x1x2 ∨ x3x4;

  	   d)	              ;	                       k)	         ;	

  	   e)	                       ;	              l)	 x< 3;	

  	   f)	 cos α + cos β;	                       m)	 z< 6 &q> 3,14;
  	   g)	 cos (α + β);	                         n)	x > 0 & y > 8 & R < 15.

                                                                             101
  	 ОБРАТИТЕ ВНИМАНИЕ! Укажите на синтаксических диаграммах рис.
     3.3 пути, которые соответствуют следующим выражениям:
  	   a)	 x	                               e)	 (+3.14)
  	   b)	 3.14	                            f)	 x>2.85
  	 c)	 sin(x)	 g)	 ПАСКАЛЬ:	sqr(b)–4*a*c>0
  				 C++:	pow(b,2)-4*a*c>0
  	 d)	 ПАСКАЛЬ:   not q	 h)	 ПАСКАЛЬ:	(a>b)and(c>d)
  		 C++:        !q		         C++:	(a>b)&&(c>d)
  	ПРИМЕНИТЕ! Переведите выражения в обычные:
  	 a)	 ПАСКАЛЬ: sqr(a)+sqr(b)	            e)	 cos(ALFA–BETA)
  		 C++: pow(a,2)+pow(b,2)	               	
  	 b)	 2*a*(b+c)	 f)	 ПАСКАЛЬ:	sqr(a+b)/(a–b)
  				 C++:	pow(a+b,2)/(a-b)
  	   c)	 sqrt((a+b)/(a–b))	 g)	 ПАСКАЛЬ:	(x>0) or (q<p)	
      			C++:	                            (x>0) || (q<p)
  	 d)	 exp(x+y)	 h)	 ПАСКАЛЬ: not(x and y)
  				 C++: !(x && y)
  	ОБРАТИТЕ ВНИМАНИЕ! Какие из следующих выражений на языке, кото-
    рый вы изучаете, содержат ошибки? Для ответа воспользуйтесь синтаксиче-
    скими диаграммами рис. 3.3.
  	   a)	 ((((+x))))				                   k)	 not q and p	
  	   b)	 ((((x))))	                       l)	 a+–b
  	   c)	 sinx+cosx	                       m)	 sin(–x)
  	   d)	 sqr(x)+sqr(y)	                   n)	 sin–x
  	   e)	 a<<b or c>d	                     o)	 cos(x+y)
  	   f)	 not not not p	                   p)	 sin(abs(x)+abs(y))
  	   g)	 q and not p	                     q)	 sqrt(–y)
  	 h)	 a!=b || c>d	                       r)	 !q && p
  	 i)	 !!! p	                             s)	 x>0 or q<p
  	 j)	 Q && ! p	                          t)	EXP(x)



  3.3. Вычисление выражений
   Под вычислением некоторого выражения понимается нахождение его значения.
Результат вычисления зависит от значений операндов и от операций, применяемых к
ним. Правила вычисления выражений – такие же, как и в математике:
   – операции выполняются в соответствии с их приоритетом;
   – в случае одинаковых приоритетов операции выполняются слева направо;
   – первыми вычисляются значения выражений, заключенных в скобках.

102
   Приоритеты операций приведены в таблице 3.2.	
                                                                             Таблица 3.2
                   Приоритеты операций языка ПАСКАЛЬ и C++
                                 Операции
      Категория                                                         Приоритет
                            ПАСКАЛЬ                      C++
                                                  +, - (знак), !,
Унарные операции        +, -(знак), not, @                        Первый (наивысший)
                                                  &, --, ++
Мультипликативные
                        *, /, div, mod, and       *, /, %           Второй
операции
Аддитивные операции     +, -, or                  +, -              Третий
Операции                                          a) <, <=, >=, >
                        <, <=, =, >=, >, <>, in                     Четвертый и пятый
отношения                                         b) ==, !=
                                                  a) &&             Шестой и седьмой
Логические операции                -
                                                  b) ||             (наименьший)

   Пример:
   Пусть x и y целые, а m и n вещественные числа, имеющие значения x = 2, y = 6, m =
5 и n = 1,5. Тогда:
   1)	 2*x+y = 2*2+6 = 4+6 = 10.
   2)	 2*(x+y) = 2(2+6) = 2 ⋅8 = 16.	 		
   3)	 x+y/x–y = 2+6/2–6 = 2+3–6 = 5–6 = –1.	                		
   4)	 (x+y)/x–y = (2+6)/2–6 = 8/2–6 = 4–6 = –2.
   5)	 ПАСКАЛЬ: x/y = 2/6 = 0.3333.
   5)*	 C++: x/y = 2/6 = 0. В случае целочисленных операндов выполняется цело-
      численное деление, а результат операции / является частным от целочисленного
      деления.
   6)	 ПАСКАЛЬ: m/n = 5/1.5 = 3.3333.
   6)*	 C++: m/n = 5/1,5 = 3.3333. В случае операндов вещественного типа
       (float, double, long double) выполняется десятичное деление, а результат
       операции / является результатом деления «с запятой».
   7)	 ПАСКАЛЬ: x+y/(x–y) = 2+6/(2–6) = 2+6/(–4) = 2+(–1.5) = 0.5;
   7)*	 C++: x+y/(x–y) = 2+6/(2–6) = 2+6/(–4) = 2+(–1) = 1;
   8)	 n+x/(m–y) = 1,5+2/(5–6) = 1.5+2/(–1) = 1.5-2 = -0.5;
   9)	 x+y<15 = 2+6<15 = 8<15 = true;
   10)	ПАСКАЛЬ: (x+y<15)and(x>3) = (2+6<15)and(2>3) = (8<15 and (2>3) =
       	= true and false = false.
   10)*	C++: (x+y<15)&&(x>3) =(2+6<15)&&(2>3) = (8<15)&&(2>3) = true
      	&& false = false.
   Отметим, что составные части выражения (рис. 3.3) вычисляются в следующем
порядке:
   1) факторы; 2) термы; 3) простые выражения; 4) само выражение.

                                                                                       103
   Текущее значение выражения можно вывести на экран так:
     ПАСКАЛЬ				C++
     writeln(<Выражение>);		       cout << <Выражение> << endl;
   Приведенные ниже программы выводят на экран результаты вычисления выра-
жений х*у+z и х+у<z–1.0. Текущие значения переменных х, у и z считываются с
клавиатуры.
             ПАСКАЛЬ                                    C++
 Program P39;                         // Программа P39
  { Вычисление выражений }            #include <iostream>
 var x, y, z : real;                  using namespace std;
 begin                                // Вычисление выражений
   writeln(’Введите                   int main()
 вещественные числа x, y, z:’); {
   readln(x, y, z);                   double x, y, z;
   writeln(x*y+z);                    cout<<″Введите вещественные
   writeln(x+y<z–1.0);                числа x, y, z:\n″;
 end.                                 cin>>x>>y>>z;
                                      cout<<x*y+z<<endl;
                                      cout<<(x+y<z-1.0);
                                      return 0;
                                      }

  Вопросы и упражнения
  	ПРИМЕНИТЕ! Пусть х=1, у=2 и z=3. Вычислите следующие выражения:
  	 a)	 x+y+2*z	                       f)	 x*(y+y)*z
  	b)	  (x+y+2)*z	                     g)	 x*y<y*z
  	 c)	 x*y+y*z	                       h)	ПАСКАЛЬ: (x>y) or (6*x>y+z)
  					C++:                                          (x>y) || (6*x>y+z)
  	 d)	 x*(y+y)*z	                     i)	 ПАСКАЛЬ: not(x+y+z>0)
  					C++: !(x+y+z>0)
  	e)	  (x*y+y)*z	                     j)	 ПАСКАЛЬ: not(x+y>0) and not(z<0)
  					 C++:                                       !(x+y>0) && !(z<0)
  	Сформулируйте правила вычисления выражений на языке, который вы
    изучаете.
  	Назовите приоритеты операций языка, который вы изучаете.
  	Укажите порядок вычисления компонент выражений в языке, который вы
    изучаете.
  	РАЗРАБОТАЙТЕ! Напишите программу, которая вычисляет выражения
    c) и g) из задания 1. Текущие значения вещественных переменных х, у и
    z считываются с клавиатуры.
  	Какие значения будут получены при вычислении выражений
                    ПАСКАЛЬ                                C++
      a)   sqr(2)+2*sgr(2)                 a)   pow(2,2)+pow(2,3)
      b)   (1+sqrt(4))/3                   b)   1+sqrt(4))/3
      c)   trunc(sqrt(20))                 c)   floor(sqrt(20))
      d)   trunc(27%4) + round(27.3) / 4   d)   floor(27%4) + ceil(27.3) / 4
      e)   trunc( -47%5 –                  e)   floor( -47%5 –
            sqrt(2))/round(19.3)/3              sqrt(2))/ceil(19.3)/3

104
    3.4.Тип выражений
   Каждому выражению, в зависимости от множества его значений, ставится в соот-
ветствие определенный тип данных. Согласно концепции данных, реализованной в
языках ПАСКАЛЬ и C++, тип выражения определяется типами операндов и операциями,
применяемыми к ним. Таким образом, тип выражения можно определить, не вычисляя
его значения.
   Типы результатов операций указаны в таблице 3.3.
   Таблица 3.4. содержит тип результатов стандартных функций языка ПАСКАЛЬ/C++.


                                                                    Таблица 3.3.
                  Типы результатов, предоставляемых операциями

                                    ПАСКАЛЬ
    Операция                    Тип операндов              Тип результата
                      integer                       integer
+, –, *
                      один integer, другой real     real
/                     integer или real              real
div                   integer                       integer
mod                   integer                       integer
not, and, or          boolean                       boolean
                      Идентичные типы               boolean
<, <=, =, >=, >, <>   Совместимые типы              boolean
                      один integer, другой real     boolean

                                         C++
    Операция                    Тип операндов              Тип результата
                      int                           int
+, –, *
                      один int, другой double       double
                      Идентичные либо совместимые   Идентичный с типом
++, ––
                      типы                          операндов
                      int                           int
/
                      double                        double
%                     int                           int
!, &&, ||             bool                          bool
                      Идентичные типы               bool
<, <=, ==, >=, >, != Совместимые типы               bool
                      один int, другой double       bool

                                                                            105
                                                                 Таблица 3.4
                Типы результатов, предоставляемых операциями
                                 ПАСКАЛЬ
      Функция                Тип аргумента            Тип результата
abs(x)             integer или real              Совпадает с типом x
sin(x)             integer или real              real
cos(x)             integer или real              real
arctan(x)          integer или real              real
sqr(x)             integer или real              Совпадает с типом x
sqrt(x)            integer или real              real
exp(x)             integer или real              real
ln(x)              integer или real              real
round(x)           real                          integer
trunc(x)           real                          integer
odd(i)             integer                       boolean
ord(v)             Порядковый                    integer
pred(v)            Порядковый                    Совпадает с типом v
succ(v)            Порядковый                    Совпадает с типом v
chr(i)             integer                       char
eof(f)             Файловый                      boolean
eoln(f)            Файловый                      boolean

                                     C++
      Функция                Тип аргумента              Тип результата

                                                 double
abs(x)
                   int или double
или fabs(x)
sin(x)             int или double                double
cos(x)             int или double                double
atan(x)            int или double                double
pow(x,2)           int или double                double
                   int или double
pow(x,n)           если x<0, то n должно         double
                   быть целым
sqrt(x)            int или double                double
exp(x)             int или double                double
log(x)             double, x>0                   double

106
round(x)           double                             double
trunc(x)           double                             double
log10(x)           double                             double
ceil(x)            double                             double
floor(x)           double                             double
EOF                Файловый                           bool
   В языке ПАСКАЛЬ независимо от типа операндов операция / (деление) возвращает
результат типа real, а операции отношения возвращают результат типа boolean.
   В языке C++ операция / предоставит целочисленный результат, если оба операнда
целые числа, и результат вещественного типа, если хотя бы один операнд имеет веще-
ственный тип, а операции отношения - только результаты типа bool.
   Для того чтобы определить тип выражения, факторы, термы и простые выражения
рассматриваются в порядке их вычисления, причем тип каждой составной части опре-
деляется с помощью таблиц 3.3 и 3.4.
   Например, рассмотрим выражение:
   6*i<sin(x/y)
в котором i – переменная типа integer/int, а х и у – переменные типа real/
double.
   Определим тип составных частей и всего выражения в порядке выполнения вычис-
лений:
   	1)	6*i	                              результат типа integer/int;
  	2)	x/y	                               результат типа real/double;
  	3)	sin(x/y)	                          результат типа real/double;
  	4)	6*i < sin(x/y)	                    результат типа boolean/bool.
  Таким образом, рассматриваемое выражение относится к типу boolean.
  В зависимости от типа выражения разделяются на:
  – арифметические (integer или real в ПАСКАЛЕ, int или double в C++);
  – порядковые (integer, boolean, char, перечисляемые, в ПАСКАЛЕ, int, bool,
char, перечисляемые в C++);
  – логические (boolean в ПАСКАЛЕ, bool в C++).


  Вопросы и упражнения
  	Как определяется тип выражения?
  	ОБРАТИТЕ ВНИМАНИЕ! При наличии объявлений:
                 ПАСКАЛЬ                                   C++
   var x, y : real;                          double x, y;
       i, j : integer;                       int i, j;
       p, q : boolean;                       bool p, q;
       r : char;                             char r;
       s : (A, B, C, D, E, F, G, H);         enum s {A, B, C, D, E, F, G, H};

                                                                              107
  определите типы следующих выражений:

           ПАСКАЛЬ                                           C++
 a) i mod 3                               a)    i % 3
 b) i/3                                   b)    i/3
 c) i mod 3 > j div 4                     c)    i % 3 > j / 4
 d) x+y/(x–y)                             d)    x+y/(x–y)
 e) not(x<i)                              e)    !(x<i)
 f) sin(abs(i)+abs(j))                    f)    sin(abs(i)+abs(j))
 g) sin(abs(x)+abs(y))                    g)    sin(abs(x)+abs(y))
 h) p and (cos(x)<=sin(y))                h)    p && (cos(x)<=sin(y))
 i) sqr(i)–sqr(j)                         i)    pow(i,2)-pow(j,2)
 j) sqr(x)–sqr(y)                         j)    pow(x,2)-pow(y,2)
 k) trunc(x)+trunc(y)                     k)    trunc(x)+trunc(y)
 l) chr(i)                                l)    char(i)
 m) ord(r)                                m)    int(r)
 n) ord(s)>ord(r)                         n)    ceil(x)>floor(y)
 o) pred(E)                               o)    2*floor (x+y)
 p) (–x+sin(x–y))/(2*i)                   p)    (–x+sin(x–y))/(2*i)

  	ОБРАТИТЕ ВНИМАНИЕ И ПРИМЕНИТЕ! Тип выражения можно узнать
    из текстовой формы результатов, выведенных на экран с помощью  оператора
	 В языке ПАСКАЛЬ				         В языке C++
	writeln(<Выражение>)		 cout<<Выражение<<endl;
  Примеры::
      Выведенный на экран     Тип выражения в
                                                            Тип выражения в C++
           результат             ПАСКАЛЕ
 1)          100                  integer                           int
 2)   1.0000000000E+02              real                           double
 3)             A                   char                           char

  	   Напишите соответствующие программы и на основании текстовой формы
      результатов, выведенных на экран, определите типы следующих выражений:

              ПАСКАЛЬ                                       C++
 a)   1+1.0                          a)        1+1.0
 b)   1/1+1                          b)        1/1+1
 c)   9*3 mod 4                      c)        9*3 % 4
 d)   4*x>9*y                        d)        4*x>9*y
 e)   chr(65)                        e)        char(65)

108
f)    not(x>y)                    f)   !(x>y)
g)    pred(9)>succ(7)             g)   9 > 7
h)    15 div ord(3)               h)   15 / 3
i)    trunc(x)+round(6*y)         i)   trunc(x)+round(6*y)
j)    sqr(3)–sqrt(16)             j)   pow(3,2)–sqrt(16)
 	 где переменные х и у являются переменными вещественного типа.
 	ОБРАТИТЕ ВНИМАНИЕ! Даны описания:
             ПАСКАЛЬ                                C++
     type T1=1..10;               typedef     int T1;
          T2=11..20;              typedef     int T2;
          T3=’A’..’Z’;            typedef     char T3;
          T4=(A, B, C, D, E, F,   enum T4     {A, B, C, D, E, F, G, H};
     G, H);                       T1 i;
     var i : T1;                  T2 j;
         j : T2;                  T3 k;
         k : T3;                  char m;
         m : ’C’..’G’;            T4 n;
         n : T4;                  T4 p;
         p : C..G;                bool q;
         q : boolean;
 	    Найдите типы следующих выражений:

              ПАСКАЛЬ                               C++
a)    i–j                         a)   i–j
b)    i div j                     b)   i / j
c)    6.3*i                       c)   6.3*i
d)    cos(3*i–6*j)                d)   cos(3*i–6*j)
e)    4*i>5*j                     e)   4*i>5*j
f)    k<m                         f)   k<m
g)    k<>m                        g)   k!=m
h)    chr(i)                      h)   char(i)
i)    ord(k)                      i)   int(k)
j)    ord(m)                      j)   int(m)
k)    n>p                         k)   n>p
l)    ord(n)                      l)   int(n)
m)    succ(n)                     m)   n+1
n)    pred(p)                     n)   p-1
o)    ord(p)                      o)   int(p)
p)    ord(k)>ord(m)               p)   int(k)> int(m)
q)    (i>j) and q                 q)   (i>j) && q

                                                                    109
 r)   not(i+j>0) or q                  r)        !(i+j>0) || q

  	Какого типа будет результат выражений?
            ПАСКАЛЬ                                          C++
 a)   sqrt(2)+2*sgr(2)                      a)    pow(2.5,2)
 b)   (1+sqr(4))*3                          b)    (1+pow(4,2))*3
 c)   trunc(sqrt(20))                       c)    floor(sqrt(20))
 d)   trunc(27%4) + round(27.8)             d)    floor(27%4) + ceil(27.8)
 e)   (trunc(-47%3) – round(19.5))*2        e)    (floor(-47%5) – ceil(19.5))*2

  	ПРОАНАЛИЗИРУЙТЕ! Какое из следующих выражений имеет значе-
    ние true (1) тогда и только тогда, когда вещественное число, хранящееся в
    переменной x, находится в диапазоне (-2,2)? Укажите порядок, в котором
    выполняются операции.
            ПАСКАЛЬ                                          C++
 a)   x*x–4<=0                              a)    x*x–4<=0
 b)   4-x*x>0                               b)    4–x*x>0
 c)   (2<x) and (x<–2)                      c)    (2<x)&&(x<–2)
 d)   (x–2)*(x+2)>0                         d)    (x–2)*(x+2)>0

  	Пусть x = 8 и y = 6. Какое из следующих выражений имеет значение false?
    Укажите порядок, в котором выполняются операции.
            ПАСКАЛЬ                                          C++
 a)   3*x–4*y= 0                            a)    3*x–4*y==0
 b)   (x+y)/2 > x mod y+1                   b)    (x+y)/2 > x%y+1
 c)   not (x/2+2 = y)                       c)    !(x/2+2 == y)
 d)   x–y+3 <> 0                            d)    x–y+3 != 0

  	Пусть переменная x вещественного типа. Какое из следующих выражений
    имеет значение true тогда и только тогда, когда вещественное число, хра-
    нящееся в переменной x, принадлежит диапазону (5, 8)?
             ПАСКАЛЬ                                         C++
 a)   (x<=8) or (x>5)                       a)    (x<=8) || (x>5)
 b)   (x>8) or (x<=5)                       b)    (x>8) || (x<=5)
 c)   (x<=8) and (x>5)                      c)    (x<=8) && (x>5)
 d)   (x<8) and (x>=5)                      d)    (x<8) && (x>=5)

110
   3.5. Преобразования типов в языке C++
   При вычислении выражений в языке C++ могут происходить неявные или явные
преобразования типов.
   Преобразование типов (конверсия) по умолчанию выполняется автоматически.
При присваивании (v = Выражение) тип правой части присваивания преобразуется в
тип левой части, который и является типом результата.
   При изучении параграфа 2.9 мы столкнулись с некоторыми ситуациями преобра-
зования типов.
   Примеры преобразований типов по умолчанию:
   int i;
   char c=’c’;
   float f;
   char c1, c2;
   c1=100;	 /* 100 автоматически преобразуется в char, c1
		                 получит значение символа с кодом 100, т. е. ’d’*/
   i=c;	       /* i будет равно 99 (код ASCII символа ’c’) */
   i=2.9;	     /* 2.9 по умолчанию преобразуется к целому int, значит i
   		          будет равно 2 */
   c2=c1;	     /* c2 будет равно ’d’ */
   f=’A’;	     /* f будет равно 65.0 ( код ASCII символа ’A’) */
   i=30000+c;	 /* выражение вычисляется на области значений 		
		             int, i будет равно 30099 */
   ВНИМАНИЕ! Возможны следующие моменты:
   •	 потеря точности (double –> float –> long int);
   •	 потеря значимых битов (long –>int);
   •	неопределенности.
     Оператор явного преобразования типа используется в случаях, когда требуется, чтобы
тип операнда (выражения) был другим, чем тип по умолчанию. Оператор имеет вид:
     (<Тип>) <Выражение> или <Тип> (<Выражение>)
   Такие конструкции называются выражениями cast (cast – нечто).
   Первая форма – традиционная, вторая – специфическая. В специфической форме имя
предопределенного или определяемого пользователем типа данных используется как
«функция преобразования» с указанием в качестве параметра типа преобразования.
   Поскольку в обоих режимах все типы данных обрабатываются одинаково, рекомен-
дуется использовать традиционную форму.
   Примеры явных преобразований типов:
   float r;
   long l;
   int i, x=7, y=3, z=-2;
   float a=2.1,b=3.0, c=-1.5, m;
   double d;
   r=5/2;		            /* деление производится в области int, значит.
			                    r будет равно 2 */
   r=(float)5/2;	 /* r будет равен 2.5, т.к. первый операнд
                    конвертируется к типу float, значит вычисления
                    производятся в области вещественных чисел */

                                                                                   111
r=(float)(5/2);		              /* r будет равен 2, т.к. результат
				                           целочисленного деления преобразуется к
				                           типу float, значит, вычисления
				                           производятся в области int */
l=(long)(’A’ + 1.0);              // l=66
i=(int)(b*b-4*a*c);               // i=21
d=(double)(x+y)/z;                // d=-5.0
m=x*y/z;                          // m=-10
m=(float)x*y/z;                  // m=-10.5
m=x/(float)2;                    // m=3.5



   3.6. Оператор присваивания

   Оператор присваивания имеет вид:
      <Переменная> := <Выражение>
   При выполнении оператора присваивания происходит следующее:
   а) вычисляется выражение, стоящее в правой части;
   б) полученное значение присваивается переменной, стоящей в левой части.
   Примеры:
   1)	 x:=1					4)	 p:=not q				
   2)	 y:=x+3				5)	 q:=(a<b) or (x<y)				
   3)	 z:=sin(x)+cos(y)		            6)	 c:=’A’
   Отметим, что символ “:=” (читается «присвоить») означает присваивание и не следует
путать его с операцией отношения “=” (равно).
   Присваивание возможно только тогда, когда переменная и результат вычисления
выражения совместимы с точки зрения присваивания. В противном случае возникает
ошибка.
   Переменная и результат вычисления выражения являются совместимыми с точки
зрения присваивания, если справедливо одно из следующих утверждений:
   1) тип переменной и тип результата идентичны;
   2) тип результата является интервалом типа переменной;
   3) оба типа являются интервалами одного и того же типа, а тип результата принад-
лежит интервальному типу переменной;
   4) тип переменной – real, а тип результата – integer или его интервал.
   В качестве примера рассмотрим следующую программу:
      Program P40;
       { Совместимость с точки зрения присваивания }
      type T1=1..10; { интервал типа integer }
           T2=5..15; { интервал типа integer }

112
    var i : T1;
         j : T2;
         k, m, n : integer;
         x : real;
    begin
      write(’k=’);
      readln(k);
      i:=k;         { верно        для 1<=k<=10 }
      write(’m=’);
      readln(m);
      j:=m;         { верно        для 5<=m<=15 }
      write(’n=’);
      readln(n);
      i:=n+5;       { верно        для –4<=n<=5 }
      j:=n+2;       { верно        для 3<=n<=13 }
      x:=i+j;
      writeln(’x=’, x);
    end.

   Программа будет работать без ошибок только при следующих значениях на входе:
                         1 ≤ k ≤ 10; 5 ≤ m ≤1 5; 3 ≤ n ≤ 5.
   Очевидно, что в программе Р39 операторы вида
    k:=x			i:=x+1		 j:=sin(i)
являются ошибочными, так как тип выражений х, х+1, sin(i) – real, а тип пере-
менных k, i, j – integer или его интервал.



   Изучаемый оператор имеет вид:
     <Переменная> = <Выражение>
   Выполнение оператора присваивания предполагает:
   a) вычисление выражения из правой части;
   b) присвоение полученного значения переменной из левой части оператора.
   Примеры:
   1)	 x=1		      			4)	                   p= !q
   2)	 y=x+3			 	5)	                       q=(a<b) || (x<y)
   3)	 z=sin(x)+cos(y)		 6)	               c=’A’
   Запомните, что символ “=” (читается “присвоить”) означает присваивание и не сле-
дует путать его с операцией отношения “==” (равно).
   Присваивание происходит, если переменная и результат вычисления выражения
совместимы с точки зрения присваивания. В противном случае будет выдано сообще-
ние об ошибке.

                                                                               113
  Примеры:
  Даны объявления:
    int x, y;
    float m, n;
  и присваивания:
  x=2;		         Значение 2 присваивается переменной х.
  y=x+2;		       Переменной y присваивается значение 2 + 2 = 4.
 m=x/y;		 Переменной m присваивается значение 0, поскольку в процессе
			       вычисления выражения в правой части присваивания происходит
			целочисленное деление 2/4.
  n=m*2+x-5;	 Переменной n присваивается значение 0 × 2 + 2 - 5 = -3.
  x=y+12;	       Значение 4 + 12 = 16 присваивается переменной x.
  x=(m>n);	      Переменной x присваивается значение (0> -3), т.е. true.
   В языке C++ используются и операции составного присваивания +=, -=, /=, *=, %=,
позволяющие более компактное написание программ. Форма операторов присваивания
с использованием таких операций следующая:
   <Переменная> <Операция составного присваивания> = <Выражение>
  Примеры:
  Даны объявления:
    int x=6, y=3;
  и составные присваивания:
  x+=12;		      Эквивалентно x = x + 12. Переменной x присваивается 18.		
 y/=5;		         Эквивалентно y = y / 5. Поскольку операнды имеют тип int,
			              выполняется деление нацело. Переменной x присваивается значение 0.
  x%=y;		        Эквивалентно x = x% y. Переменной x присваивается значение 0.
  y*=2;		        Эквивалентно y = y * 2. Переменной y присваивается значение 3.
   Отметим, что выражение в правой части оператора присваивания также может быть
оператор присваивания, то есть можно записывать связанные операторы присваивания.
   Примеры:
   Даны объявления:
    int a=8, b=2, c=7, j=9, k=11;
  и составные присваивания:
  a=b*=2;	Эквивалентно a=b*2. Переменным a и b присваивается значение 4.
  a=b=a*b;	      Эквивалентно a=b=8*2. Переменным a и b присваивается значение 16.
k%=j-=4;	 Сначала выполняется присваивание j- = 4. Следовательно, переменной
			j будет присвоено значение 5. Это значение используется для
			выполнения присваивания k% = j, поэтому переменной k будет
			присвоено значение 1.
  a=b=c=10;	 Каждой из переменных a, b, c будет присвоено значение 10.
  В эту же категорию входят унарные операции инкремента (++) и декремента (--).

114
 Вопросы и упражнения
 	 Как выполняется оператор присваивания?
 	Объясните понятие “совместимость с точки зрения присваивания”.
 	Даны следующие объявления:
               ПАСКАЛЬ                            C++
     type Zi = (L, Ma, Mi, J,      enum Zi {L, Ma, Mi, J, V, S, D};
     V,                            enum Culoare {Galben, Verde,
           S, D);                        Albastru, Violet};
           Culoare = (Galben,      int i, j, k;
           Verde, Albastru, Vio-   Zi z;
     let);                         Culoare c;
     var i, j, k : integer;        double x;
         z : Zi;
         c : Culoare;
         x : real;
 Какие из следующих операторов являются правильными?

              ПАСКАЛЬ                                C++
a)    i:=12                        a)   i=12
b)    j:=ord(i)                    b)   j=int(i)
c)    x:=ord(z)+1                  c)   x=int(z)+1
d)    k:=ord(x)+2                  d)   k=int(x)+2
e)    c:=i+4                       e)   c=i+4
f)    c:=Verde                     f)   c=Verde
g)    z:=D                         g)   z=D
h)    c:=Pred(Galben)              h)   c=Galben-1
i)    x:=Succ(z)                   i)   x=z+1
j)    i:=Succ(c)                   j)   i=c+1
 	Уточните, для каких значений переменной j нижеследующие программы
   будут выполняться без ошибок.

               ПАСКАЛЬ                               C++
     Program P41;                  // Программа P41
     var i : –10..+10;             #include <iostream>
          j : integer;             using namespace std;
     begin                         int main()
       write(’j=’);                {
       readln(j);                  short int i;
       i:=j+15;                    int j;
       writeln(’i=’, i);           cout<<″j=″; cin>>j;
     end.                          i=j+15;    cout<<″i=″<<i;
                                   return 0;
                                   }

                                                                    115
  	ПРОАНАЛИЗИРУЙТЕ! Дана следующая последовательность операторов
    программы на языке PASCAL/C++,  в которой переменные x, y и z представ-
    ляют целочисленные величины.

                ПАСКАЛЬ                                    C++
      x:=y+z; z:=x-z; y:=z; z:=x-y;        x=y+z; z=x-z; y=z; z=x-y;

  	    После выполнения этого фрагмента программы некоторые из переменных
       x, y, z могли изменить свои значения. Выберите из списка, приведенного
       ниже, вариант, содержащий все переменные, значения которых останутся
       неизменными:
                               a) x;		     d) x и y;
                               b) y;		     e) x и z;
                               c) z;	 	    f) x, y и z.


  3.7.Оператор вызова процедуры в языке ПАСКАЛЬ
   ПРИМЕЧАНИЕ
   В языке C++ существуют только подпрограммы типа функции. Для процедур ис-
   пользуется специальная форма функций, которая будет изучаться в следующем
   классе. Следовательно, данный параграф предусмотрен только для учеников,
   изучающих язык ПАСКАЛЬ.
   Процедура представляет собой подпрограмму, к которой в процессе выполнения
программы можно обращаться произвольное число раз. Каждая процедура имеет свое
имя, например: readln, writeln, CitireDate, A15 и т. д. Язык ПАСКАЛЬ
содержит ряд стандартных процедур, известных любой программе: read, readln,
write, writeln, get, put, new и т. д. В дополнение к ним программист может
создавать собственные процедуры.
   Оператор вызова процедуры вызывает процедуру с соответствующим именем.
Оператор имеет вид:
  <Вызов процедуры> ::= <Имя процедуры> [<Список фактических параметров>]
  <Имя процедуры> ::= <Идентификатор>
  <Список фактических параметров> ::= (<Фактический параметр>
  					                               {, <Фактический параметр>})
   Синтаксические диаграммы указанных металингвистических формул представлены
на рис. 3.4.
   Как правило, <Фактический параметр> является выражением.
   Примеры:
  	1)	      Exit
  	2)	      writeln(x+y, sin(x))
  	3)	      writeln(2*x)

   Тип каждого фактического параметра и порядок его появления в списке указываются
в разделе описаний соответствующих процедур. Правила составления списка фактиче-
ских параметров будут изучены в следующих главах.

116
            <Оператор вызова процедуры>
                     Имя процедуры


                                          Список фактических
                                             параметров


            <Список фактических параметров>
                                      Фактический
                                       параметр




            <Имя процедуры>
                                     Идентификатор




          Рис. 3.4. Синтаксические диаграммы оператора вызова процедуры

  Вопросы и упражнения
  	 Для чего необходим оператор вызова процедуры?
  	 ПРОАНАЛИЗИРУЙТЕ! Даны следующие операторы:
  	   a)	 readln(x, y, z, q)
  	   b)	 CitireDate(ff, tt)
  	   c)	 Halt
  	   d)	 writeln(’x=’, x, ’y=’, y)
  	   e)	 writeln(’x+y=’, x+y, ’sin(x)=’, sin(x))
  	   Укажите имена вызываемых процедур, число фактических параметров
      каждой процедуры, а также назовите эти фактические параметры.
  	 Укажите на синтаксических диаграммах рис. 3.4 пути, которые соответствуют
     операторам из задания 2.



  3.8.Вывод алфавитно-цифровой информации

   В большинстве версий языков ПАСКАЛЬ и C++ экран монитора является
стандартным устройством вывода.

                                                                          117
   В языке ПАСКАЛЬ, как правило, экран разделяется на условные зоны, называемые
символьными. Указанные зоны образуют 25 строк по 80 символов в каждой. Зона, в
которой будет выведен текущий символ, обозначается курсором.
   Данные выводятся на экран с помощью процедуры write(x) или writeln(x).
   Вызов процедуры
    write(x1, x2, ..., xn)
  эквивалентен последовательности
    write(x1); write(x2); ...; write(xn)
  Фактические параметры процедур write или writeln называются параметрами вывода.
Они могут иметь следующий вид:
   	                  e	e : w	                           e:w:f
где е – выражение типа integer, real, boolean, char или строкового типа, значение
которого нужно вывести на экран; w и f являются выражениями типа integer и на-
зываются спецификаторами формата. Значение выражения w указывает минимальное
число символов, используемых для вывода значения е; если для представления значения
е требуется меньше, чем w символов, то ему предшествует такое число пробелов, чтобы
было записано точно w символов (рис. 3.5).




                     Рис. 3.5. Значение спецификатора формата w
   Спецификатор формата f может присутствовать только в том случае, когда е является
выражением типа real. Данный параметр указывает количество цифр после запятой в
представлении значения выражения е с фиксированной точкой, без масштабного мно-
жителя. При отсутствии f значение е записывается с плавающей точкой, с масштабным
множителем (рис. 3.6).




                     Рис. 3.6. Значение спецификатора формата f

118
   Разница между процедурами write и writeln состоит в том, что после вывода
данных write оставляет курсор в текущей строке, тогда как writeln переводит курсор на
начало следующей строки. Рациональное использование процедур write, writeln
и параметров размера поля обеспечивает вывод данных в форме, удобной для чтения.
При выводе на экран нескольких значений рекомендуется указывать соответствующие
им идентификаторы или сопровождать их комментариями.
   Примеры:

   	 1)	 write(’Сумма введенных чисел’)
   	 2)	 writeln(s:20)
   	 3)	 writeln(’Сумма=’, s)
   	 4)	 writeln(’s=’, s)
   	 5)	 writeln(’x=’, x, ’y=’:5, y, ’z=’:5, z)



  В языке C++ вывод чисел и строк символов на экран (консоль) осуществляется с
помощью оператора:
                               cout << <Выражение>
   Примеры:
   	1)	 cout<<x;
   	2)	 cout<<x<<y<<z;
   	3)	 cout<<”Aria cercului=”<<(Pi*r*r);
   	4)	 cout<<x<<endl;
   	 5)	 cout<<”Введите целое число \n”;
   Чтобы вывести алфавитно-цифровую информацию на определенном количестве
символьных позиций и установить размер каждого отображаемого значения, исполь-
зуется оператор setw, который также называется манипулятором:
   	     cout<<setw(n);
   Количество позиций (столбцов), установленных для отображения, называется
полем. Отображаемое значение будет выровнено по правому краю, а позиции полей,
оставленные свободными, будут заполнены пробелами. Параметр n – это целочисленное
выражение, называемое спецификатором размера поля.
   Чтобы использовать манипулятор setw, – в программу C++ должен быть включен
iomanip, что выполняется с помощью директивы #include.
   Примеры:
   В присутствии объявления
       double x=3;

                                                                                 119
оператор
    cout<<setw(10)<<x;	
выведет значение переменной x на 10 позициях.
  Так как значение переменной x равно 3, для его вывода нужна лишь одна позиция.
Следовательно, остальные девять позиций будут заполнены пробелами.
  Смысл спецификатора n манипулятора setw представлен на рис. 3.5*.
  При отображении вещественных данных могут использоваться специальные функции

                        cout<<(-1234)
              cout<<setw(10)<<(-1234)



                        cout<<’a’
               cout<<setw(5)<<’a’



                         cout<<’a’<<’b’
           cout<<setw(5)<<’a’<<setw(5)<<’b’

                Fig. 3.5*. Смысл спецификатора поля манипулятора setw
форматирования, устанавливающие определенную точность отображения, например,
количество цифр после запятой числа типа double. Для этого в программу могут быть
включены следующие операторы:
 cout.setf(ios::fixed);	              Действительные числа должны отображаться в
		                                    десятичной форме.
 cout.setf(ios::showpoint);	          Десятичная точка отображается всегда, даже для
			                                   целых чисел.
 cout.precision(n);	                  Указывает количество отображаемых десятичных
			                                   знаков n.
   Первый оператор позволяет использовать функцию precision только для дробной
части (после точки); в противном случае учитывалось бы все число.
   Второй оператор обязательно отображает десятичную точку, даже для целых чисел.
   Третий оператор устанавливает точность числа до n десятичных знаков. Выводимое
значение округляется! Аргумент n должен быть положительным целым числом или
выражением типа int.
   Выполнив эти операторы, функция cout отобразит вещественные числа в новом
формате.
   При указании размера поля для вещественных чисел необходимо учитывать, что деся-
тичная точка также занимает позицию. Например, значение 3.14 занимает не 3, а 4 позиции.
   Примеры:
   double pi = 3.14159;
   cout<<pi<<endl;          // будет выведено 3.14159
   cout.setf(ios::fixed);
   cout.setf(ios::showpoint);
   cout.precision(2);
   cout<<pi;                  // будет выведено 3.14

120
   Операторы форматирования, использованные в представленном выше примере,
могут быть записаны в одной строке:
  cout<<setiosflags(ios::fixed)<<setiosflags(ios::showpoint)<<
  setprecision(2)<<pi;

или в короткой форме:
  cout<<fixed<<showpoint<<setprecision(2)<<pi;
  Для отображения числа в экспоненциальном представлении (с масштабным коэф-
фициентом) будут использоваться следующие операторы:
cout.setf(ios::scientific); /*	                Обеспечивает отображение
						                                         числа в экспоненциальном
						                                         представлении (с масштабным
						                                         коэффициентом) */
 cout.setf(ios::showpoint);
 cout.precision(2);
 cout<<pi;                  //	                будет выведено 3.14e+000
или
  cout<<setiosflags(ios::scientific)<<setiosflags(ios::showpoint)<<
  setprecision(2)<<pi;
или в еще более короткой форме:
  cout<<scientific<<showpoint<<setprecision(2)<<pi;
  Примеры:
      double x = 0.0000123;
      cout.setf(ios::scientific);
      cout.setf(ios::showpoint);
      cout.precision(3);
      cout << x;                // будет выведено 1.230e-005

         cout<<setprecision(10)
                                    - 1 2 3 4 . 5 6 7 8 9
                 <<-1234.567890

                 cout<<setw(20)
                                                          - 1 2 3 4 . 5 6 7 8 9
                 <<-1234.567890

        cout<<setiosflags(ios::
                                    - 1 . 2 3 4 5 6 7 8 9 0 0 E + 0 0 3
      scientific)<<-1234.567890

      cout<<setiosflags(ios::       - 1 . 2 E + 0 0 3
 scientific)<<setprecision(1)
               <<-1234.567890

   cout.setf(ios::fixed);
   cout.setf(ios::showpoint);       - 1 2 3 4 . 5 6 7 8 9 0
   cout.precision(10):
   cout<<-1234.567890

          Рис. 3.6*. Значение спецификаторов формата для вещественных чисел

                                                                              121
  Другой часто используемый манипулятор – endl, который обеспечивает переме-
щение курсора на новую строку:
  Примеры:
   cout<<”Введите два числа”<<endl;
   Этот оператор отобразит текст Введите два числа на экране, а затем последу-
ющий вывод переместится на новую строку.
   Для перехода на новую строку можем также использовать спецификатор «\ n» (escape).
Это эквивалент endl. Управляющий символ escape должен быть введен в текст в кавыч-
ках. Он не будет отображаться, но заставит курсор переместиться на следующую строку:
   Примеры:
   	1)	 cout<<”Сумма введенных чисел равна \n”;
   	2)	cout<<s<<endl;
   	3)	 cout<<”Давным \n давно \n”;	
   	4)	cout<<”s=”<<s<<endl;
   	5)	cout<<”\n x=”<<x<<”\n y=”<<y<<” \n z=”<<z<<endl;



   Вопросы и упражнения
   	Для чего нужны спецификаторы формата?
   	(ПАСКАЛЬ) Как называются фактические параметры процедур write и
     writeln?
   	 (C++) Как называются параметры манипулятора setw?
   	ПРИМЕНИТЕ! Определите форматы данных, выводимых на экран следу-
     ющими программами:
               ПАСКАЛЬ                                      C++
   Program P42;                          // Программа P42
    { Вывод данных типа inte-            #include <iostream>
   ger }                                 #include <iomanip>
   var i : integer;                      using namespace std;
   begin                                 //Вывод данных типа int
     i:=–1234;                           int main()
     writeln(i);                         {
     writeln(i:1);                       int i;
     writeln(i:8);                       i=-1234;
     writeln(i, i);                      cout<<i<<endl;
     writeln(i:8, i:8);                  cout<<setw(1)<<i<<endl;
     writeln(i, i, i);                   cout<<setw(8)<<i<<endl;
     writeln(i:8, i:8, i:8);             cout<<i<<i<<endl;
   end.                                  cout<<setw(8)<<i<<setw(8)<<i;
                                         cout<<i<<i<<i<<endl;
                                         cout<<setw(8)<<i<<setw(8)<<i;
                                         return 0;
                                         }

122
        ПАСКАЛЬ                           C++
Program P43;                // Программа P43
{Вывод данных типа real }   #include <iostream>
var x : real;               #include <iomanip>
begin                       using namespace std;
  x:=–1234.567890;          // Вывод данных вещественных типов
  writeln(x);               int main()
  writeln(x:20);            {
  writeln(x:20:1);          double x;
  writeln(x:20:2);          x=-1234.567890;
  writeln(x:20:4);          cout<<x<<endl;
  writeln(x, x, x);         cout<<setw(20)<<x<<endl;
  writeln(x:20, x:20,       cout<<setw(20)<<setprecision(1)<<x
x:20);                        <<endl;
  writeln(x:20:4, x:20:4,   cout<<setw(20)<<setprecision(2)<<x
x:20:4);                      <<endl;
end.                        cout<<setw(20)<<setprecision(4)<<x
                              <<endl;
                            cout<<x<<x<<x<<endl;
                            cout<<setw(20)<<x<<setw(20)<<x<<
                              setw(20)<<x<<endl;
                            cout<<setw(20)<<setprecision(4)<<x
                              <<setw(20)<<setprecision(4)<<x
                              <<endl;
                            cout<<fixed<<showpoint<<setpreci-
                              sion(2)<<x<<endl;
                            cout<<scientific<<showpoint<<
                              setprecision(2)<<x<<endl;
                            return 0;
                            }
Program P44;                // Программа P44
 { Вывод данных типа boo-   #include <iostream>
lean }                      #include <iomanip>
var p : boolean;            using namespace std;
begin                       // Вывод данных типа bool
  p:=false;                 int main()
  writeln(p);               {
  writeln(p:10);            bool p;
  writeln(p, p);            p=false;
  writeln(p:10, p:10);      cout<<p<<endl;
end.                        cout<<setw(10)<<p<<endl;
                            cout<<p<<p<<endl;
                            cout<<setw(10)<<p<<setw(10)
                              <<p<<endl;
                            return 0;
                            }

                                                           123
      Program P45;                     // Программа P45
        {Вывод строк символов }        #include <iostream>
      begin                            #include <iomanip>
        writeln(’abc’);                using namespace std;
        writeln(’abc’:10);             // Вывод строк символов
        writeln(’abc’, ’abc’);         int main()
        writeln(’abc’:10,              {
           ’abc’:10);                  cout<<″abc″<<endl;
      end.                             cout<<setw(10)<<″abc \n″;
                                       cout<<″abc″<<″abc \n″;
                                       cout<<setw(10)<<″abc″<<setw(10)
                                         <<″abc \n″;
                                       return 0;
                                       }
  	ПРИМЕНИТЕ! Напишите программу, которая выводит на экран значения
  1234567890, 123, 123.0 и true следующим образом:
         1234567890
         123
         123.0
         true
         1234567890
                                123
                                123.000
                                true




  3.9. Ввод данных с клавиатуры
  Как правило, стандартным устройством ввода является клавиатура.


   В ПАСКАЛЕ ввод данных с клавиатуры выполняется с помощью стандартных проце-
дур read или readln. Список фактических параметров процедуры read или readln
может включать переменные типа integer, real, char и строкового типа.
   Вызов
     read(x)
выполняет следующие действия: если переменная х является переменной типа integer
или real, тогда считывается вся строка символов, представляющая целое или веще-
ственное значение; если переменная х является переменной типа char, то процедура
считывает только один символ.
   Вызов
      read(x1, x2, ..., xn)
  эквивалентен последовательности
      read(x1); read(x2); ...; read(xn)

124
   Числа, вводимые с клавиатуры, должны разделяться пробелами или символами
конца строки. Пробелы, стоящие перед самим числом, игнорируются. Строка символов,
представляющая собой число, должна соответствовать синтаксису числовых констант
соответствующего типа. В противном случае возникает ошибка ввода-вывода.
   Например, рассмотрим программу:
    Program P46;
      { Считывание чисел с клавиатуры }
    var 	i, j : integer;
    	    x, y : real;
    begin
    	 read(i, j, x, y);
    	writeln(’Были введены:’);
    	writeln(’i=’, i);
    	writeln(’j=’, j);
    	writeln(’x=’, x);
    	writeln(’y=’, y);
    end.
в которой считываются с клавиатуры значения переменных i, j, х, у. После запуска
программы на выполнение пользователь набирает:
    1<ENTER>
    2<ENTER>
    3.0<ENTER>
    4.0<ENTER>
  На экран будет выведено:
   Были введены:
   i=1
   j=2
   x=3.0000000000E+00
   y=4.0000000000E+00
  Если данные вводить одной строкой, то результат не изменится:
    1 2 3.0 4.0<ENTER>
   В случае необходимости целые числа, введенные пользователем, переводятся в
вещественные значения. Например, в программе Р46 пользователь может набрать на
клавиатуре
    1 2 3 4<ENTER>
   Процедура readln считывает данные точно так же, как и процедура read. Однако
после считывания последнего значения оставшиеся символы текущей строки игнори-
руются. В качестве примера рассмотрим программу Р47:
    Program P47;
     { Использование процедуры readln }
    var	 i, j : integer;
    	    x, y : real;

                                                                             125
      begin
      	writeln(’Использование процедуры read’’);
      	 read(i, j);
      	 read(x, y);
      	writeln(’Были введены::’);
      	writeln(’i=’, i, ’ j=’, j, ’ x=’, x, ’ y=’, y);
      	writeln(’Использование процедуры readln’);
      	 readln(i, j);
      	 readln(x, y);
      	writeln(’Были введены’);
      	writeln(’i=’, i, ’ j=’, j, ’ x=’, x, ’ y=’, y);
      end.

   При выполнении операторов
      read(i, j);
      read(x, y);
числовые значения из строки
      1 2 3 4<ENTER>
введенной пользователем, будут присвоены соответственно переменным i, j, x, у. При
выполнении оператора

      readln(i, j)
числовые значения 1 и 2 из строки
      1 2 3 4<ENTER>
будут присвоены переменным i и j. Числа 3 и 4 игнорируются. Затем компьютер выпол-
няет оператор:
      readln(x, y)
т. е. ожидается набор значений для х и у. Отметим, что при вызове процедуры readln без
параметров компьютер ожидает нажатия клавиши <ENTER>. Такой вызов процедуры
используется с целью приостановки выполнения программы, предоставляя тем самым
пользователю возможность прочитать результаты, выведенные до этого на экран.
     Для того чтобы сообщить пользователю, какие данные нужно вводить, рекомендуется
выводить на экран соответствующие наводящие сообщения.
   Примеры:
   1)	   write(’Введите два числа:’); readln(x, y);		
   2)	   write(’Введите целое число:’); readln(i);
   3)	   write(’x=’); readln(x);	              		
   4)	   write(’Ответьте да/D или нет/N:’); readln(c);

126
   В C++ ввод данных с клавиатуры выполняется с помощью оператора
      cin >> <Переменная> ;
где <Переменная> может указывать переменные целых, вещественных типов, символы
или строки.
   Вызов
      cin >> x;
состоит во вводе некоторого значения с клавиатуры и автоматическом присваивании
введенного значения переменной x.
   Если переменная x имеет тип int или double, то считывается вся строка, представ-
ляющая целое или вещественное значение. Если x имеет тип char, оператор считывает
один символ.
   Оператор
      cin >> x1 >> x2 >> ... >> xn ;
   Эквивалентна следующим операторам:
     cin >> x1; cin >> x2; ...; cin >> xn;
   Числовые данные, вводимые с клавиатуры, должны быть разделены пробелами или
символами конца строки. Пробелы перед числовым значением игнорируются. При
чтении символьных переменных пробелы игнорируются.
   Для облегчения ввода данных рекомендуется, чтобы операторам ввода предшествовал
вывод наводящих сообщений.
   Примеры:
   1)	   cout<<”Введите два числа: ”;            cin>>x>>y;
   2)	   cout<<”Введите целое число: ”; cin>>i;
   3)	   cout<<”x= ”; cin>>x;
   4)	   cout<<”Ответьте да/D или нет/N: ”; cin>>c;


   Вопросы и упражнения
   	 Как разделяются числовые данные, вводимые с клавиатуры?
   	(ПАСКАЛЬ) Каковы различия между процедурами read и readln?
   	ПРОАНАЛИЗИРУЙТЕ! Даны следующие программы:
              ПАСКАЛЬ                                     C++
    Program P48;                        // Программа P48
    var i : integer;                    #include <iostream>
        c : char;                       using namespace std;
        x : real;                       int main()
    begin                               {
      readln(i);                        int i;
      readln(c);                        char c;
                                        double x;
                                        cin>>i;

                                                                               127
        readln(x);                     cin>>c;
        writeln(’i=’, i);              cin>>x;
        writeln(’c=’, c);              cout<<″i=″<<i<<endl;
        writeln(’x=’, x);              cout<<″c=″<<c<<endl;
        readln;                        cout<<″x=″<<x<<endl;
      end.                             return 0;
                                       }
  	    Определите результаты, которые будут выведены на экран при вводе
       следующих данных:
  	a)	1	 b)	 1 2 3	 c)	 123	 d)	 123	 456 789	
   	2		      5 6 7		    456		    abc	 def ghi	
   	3		      8 9 0		    789		    890	 abc def

  	ПРИМЕНИТЕ!  Напишите программу, которая считывает символ или число
    с клавиатуры и отображает на экране следующее:
  	a) *             b) ############           c)  00          00
      **                 ########             0       0    0      0
     ***                   ####              0             0           0
    ****                     #               0                          0
   *****                                       0                   0
                                                    0          0
                                                          0
  	С клавиатуры считываются две меры углов, выраженные в градусах, минутах
    и секундах: g1, m1, s1; g2, m2, s2. Напишите программу, которая вычислит
    и отобразит на экране сумму измерений двух углов, выраженную также в
    градусах, минутах и ​​секундах.
  	С клавиатуры считываются координаты двух точек: x1, y1; х2, у2. Напишите
    программу, которая отобразит на экране длину отрезка, образованного этими
    двумя точками, и координаты его середины.
  	Товар имеет цену x леев за единицу, к которой при продаже применяется
    НДС в размере t процентов. Значения x и t считываются с клавиатуры.
    Напишите программу, которая отобразит на экране цену продажи.
  	Мария и Петр хотят испечь яблочный пирог. Для этого им нужно x граммов
    муки, y граммов сахара, p яиц, m кг яблок, z мл молока. Известно, что цена
    за килограмм муки равна px леев, за килограмм сахара py леев, килограмм
    яблок стоит pm леев, литр молока стоит pz леев, а яйца стоят pp леев / штука.
    Напишите программу, которая определит и отобразит на экране цену пирога.




  3.10. Пустой оператор
   Выполнение данного оператора никак не влияет на значения переменных, исполь-
зуемых в программе. Синтаксис пустого оператора:
  <Пустой оператор> ::=

128
   Таким образом, в тексте программы пустой оператор ничем не представляется. Так
как операторы программы разделяются с помощью «;», присутствие пустого оператора
отмечается появлением этого символа.
   Например, в тексте:
	          П А С К А Л Ь 				 C + +
	      x:=4;;;; y:=x+1		    x=4;;;; y=x+1
есть 5 операторов, 3 из которых – пустые.
   Обычно пустой оператор используется на этапах разработки и отладки сложных
программ. Хотя пустой оператор не выполняет никаких действий, ее (точнее, символа
«;») присутствие или отсутствие может повлиять на ход программы.



    3.11. Оператор if
   Оператор ветвления if выполняет одно из двух возможных действий в зависи-
мости от значения некоторого условия – логического выражения. Синтаксис данного
оператора:
    ПАСКАЛЬ
 <Оператор if> ::= if <Логическое выражение> then <Оператор1>
		                 [else <Оператор2>]
  C+
 <Оператор if> ::= if (<Логическое выражение>) <Оператор1>
		                 [else <Оператор2>]

              <Оператор if>

                                 Логическое выражение




                        Оператор 1                      Оператор 2

               <Оператор if>

                          (      Логическое выражение       )




                Оператор 1       ;                      Оператор 2

                 Рис. 3.7. Синтаксическая диаграмма <Оператор if>

                                                                             129
   Синтаксическая диаграмма рассматриваемого оператора представлена на рис. 3.7.
Логическое выражение, входящее в состав оператора if, называется условием.
   Выполнение оператора if начинается с проверки условия. Если результатом провер-
ки является true, то выполняется Оператор1. Если условие принимает значение false,
то либо выполняется Оператор2, стоящая после ключевого слова else (если оно есть),
либо управление передается оператору, следующему непосредственно за оператором if.
   В следующих программах оператор if используется для определения максимального
из двух чисел х и у, считываемых с клавиатуры.

              ПАСКАЛЬ                                         C++
Program P49;                               // Программа P49
{ Определение большего из двух             #include <iostream>
чисел }                                    using namespace std;
var x, y, max : real;                      /* Определение большего из двух
begin                                      чисел */
  writeln(’Введите два числа:’);           int main()
  write(’x=’); readln(x);                  {
  write(’y=’); readln(y);                  float x, y, max;
  if x>=y then max:=x                      cout<<″Введите два числа: \n″;
           else max:=y;                    cout<<″x=″; cin>>x;
  writeln(’max=’, max);                    cout<<″y=″; cin>>y;
  readln;                                  if (x>=y) max=x; else max=y;
end.                                       cout<<″max=″<<max;
                                           return 0;
                                           }
   Следующая программа переводит римские цифры: I (один), V (пять), Х (десять), L
(пятьдесят), C (сто), D (пятьсот), M (тысяча), считываемые с клавиатуры, в соответству-
ющие им числа в десятичной системе счисления.

              ПАСКАЛЬ                                   C++
Program P50;                               // Программа P50
 { Конверсия римских цифр }                #include <iostream>
var i : integer; c : char;                 using namespace std;
begin                                      // Конверсия римских цифр
  i:=0;                                    int main()
  writeln(Введите одну из                  {
римских цифр’);                            int i; char c;
  writeln(’ I, V, X, L, C,                 i=0;
D, M’);                                    cout<<″Введите одну из
  readln(c);                               римских цифр\n″;
  if c=’I’ then i:=1;                      cout<<″I, V, X, L, C, D, M
  if c=’V’ then i:=5;                      \n″;
  if c=’X’ then i:=10;                     cin>>c;
  if c=’L’ then i:=50;                     if (c==’I’) i=1;
  if c=’C’ then i:=100;                    if (c==’V’) i=5;

130
  if c=’D’ then i:=500;               if (c==’X’) i=10;
  if c=’M’ then i:=1000;              if (c==’L’) i=50;
  if i=0 then writeln(c,              if (c==’C’) i=100;
  ’ – не является римской             if (c==’D’) i=500;
цифрой’)                              if (c==’M’) i=1000;
           else writeln(i);           if (i==0) cout<<c<<″ не
  readln;                             является римской цифрой″; else
end.                                  cout<<i;
                                      return 0;
                                      }


 Вопросы и упражнения
 	Для чего необходим оператор if?
 	ПРОАНАЛИЗИРУЙТЕ И ПРИМЕНИТЕ! Какие значения будет
   принимать переменная х после выполнения каждого из следующих
   операторов? Подразумевается, что а = 18, b = -15, p = true.
           ПАСКАЛЬ                                          C++
a)   if a>b then x:=1 else x:=4      a)   if (a>b) x=1; else x=4
b)   if a<b then x:=15 else x:=–21   b)   if (a<b) x=15; else x=–21
c)   if p then x:=32 else x:=638     c)   if (p) x=32; else x=638
d)   if not p then x:=0 else x:=1    d)   if (!p) x=0; else x=1
     if (a<b) and p then x:=–1
e)   else x:=1                       e)   if ((a<b)&& p) x=–1; else x=1

     if (a>b) or p then x:=–6             if ((a>b)|| p) x=–6;
f)   else x:=–5                      f)   else x=–5
     if not (a>b) then x:=19
g)   else x:=–2                      g)   if (!(a>b)) x=19; else x=–2

     if (a=b) or p then x:=89             if ((a==b)||p) x=89;
h)   else x:=–15                     h)   else x=–15

 	ПРИМЕНИТЕ! Напишите программу, которая вычисляет значение одной
   из следующих функций:

                                                          √x+y, если c>0;
 	   a)	             	b)	                      	   c)	 z=
                                                          x ∙ y, если c=0;
                                                           1 , если c<0;
                                                          x–y
                                                            x 3–6x, если x< –12;
 	   d)	                	     e)	          	       f)	 y=   √x 4+12, если –12≤x< –5;
                                          ;                 2x+12, если – 5≤x<2;
                                                            14, если x≥2.
                   x + 6, x > 4;
 Пример, для y =
                   x – 3, x ≤ 4;

                                                                                131
                ПАСКАЛЬ                               C++
      Program P51;                   // Программа P51
      var x, y : real;               #include <iostream>
      begin                          using namespace std;
        write(’x=’); readln(x);      int main()
        if x>4 then y:=x+6           {
           else y:=x–3;              float x, y;
        writeln(’y=’, y);            cout<<″x=″; cin>>x;
        readln;                      if (x>4) y=x+6; else y=x-3;
      end.                           cout<<″y=″<<y<<endl;
                                     return 0;
                                     }
  	Какие результаты выведет на экран следующая программа?
               ПАСКАЛЬ                                C++
      Program P52;                   // Программа P52
      var x, y : real;               #include <iostream>
      begin                          using namespace std;
        write(’x=’); readln(x);      int main()
        y:=x;                        {
        if x>0 then; y:=2*x;         float x, y;
        writeln(’y=’, y);            cout<<″x=″; cin>>x;
        readln;                      y=x;
      end.                           if (x>0); y=2*x;
                                     cout<<″y=″<<y;
                                     return 0;
                                     }
  	Прокомментируйте сообщения, выводимые на экран в процессе компиляции
    программы Р52:
               ПАСКАЛЬ                                C++
      Program P53;                   // Программа P53
      var x, y : real;               #include <iostream>
      begin                          using namespace std;
        write(’x=’);                 int main()
        readln(x);                   {
        if x>4 then y:=2*sqr(x)+6;   float x, y;
               else y:=x*x*x–3;      cout<<″x=″; cin>>x;
        writeln(’y=’, y); readln;    if (x>4) y=2*pow(x,2)+6;
      end.                                     else y=x*x*x-3;
                                     cout<<″y=″<<y;
                                     return 0;
                                     }
  	Напишите программу, которая переводит десятичные числа 1, 5, 10, 50, 100,
    500 и 1000, считываемые с клавиатуры, в римские.
  	Дано ненулевое натуральное число N, представляющее отметку ученика.
    Выведите на экран сообщение «Переведен», если N ≥ 5, и «Не переведен» в
    противном случае.
  	Дни недели закодированы следующим образом: 1 - Понедельник, 2 -
    Вторник, ..., 7 -  Воскресенье. Напишите программу, которая считывает с

132
    клавиатуры ненулевое натуральное число n, 1 ≤ n ≤ 7 и отображает на экране
    название дня, которому соответствует это число (Понедельник, Вторник, ...,
    Воскресенье).
  	Напишите программу, которая решала бы уравнение второй степени,
    ax2+bx+c = 0. где a, b и c – вещественные числа, считываемые с клавиатуры.
  	Даны три отрезка длиной a, b и c соответственно. Напишите программу,
    которая проверяет, можно ли построить треугольник из этих отрезков.
    Если такое построение возможно, программа отобразит тип треугольника
    (равносторонний, равнобедренный или разносторонний) и его площадь.
    Для вычисления площади треугольника воспользуйтесь формулой Герона.
    Действительные числа a, b и c читаются с клавиатуры.



  3.12. Оператор множественного ветвления
   В предыдущем параграфе мы познакомились с одним из операторов ветвления и
заметили, что оператор if позволяет нам создавать потоки выполнения максимум с
двумя ветвями. В случаях, когда необходимо создать потоки выполнения с более чем
двумя ветвями, используются операторы множественного ветвления.
   Оператор множественного ветвления обязательно включает выражение, называемое
переключателем (селектором), и список операторов. Каждому оператору соответствует
префикс в виде одной или нескольких констант выбора. Синтаксис рассматриваемого
оператора:
  ПАСКАЛЬ
    <Оператор case> ::= case <выражение> of [<Вариант>{; <Вариант>}] [;] end
    <Вариант> ::= <Константа> {, <Константа>} : <Оператор>

    C++
    <Оператор switch> ::= switch (<выражение>) { <Вариант>[{; <Вариант>}];
    					 [default: <Оператор> }
    <Вариант> ::= case <Константа> :{case <Константа>:} <Оператор>; break;
  Соответствующие синтаксические диаграммы представлены на рис. 3.8.
                  <Оператор case>
                  <Оператор case>
                       Выражение               Вариант
                       Выражение               Вариант




           <Вариант>
           <Вариант>
                       Константа                  Оператор
                       Константа                  Оператор




           Рис. 3.8. Синтаксическая диаграмма <Oператор case>, ПАСКАЛЬ

                                                                             133
             <Оператор switch>
      switch      (      Выражение   )




      {        Вариант                                                     }

                                 default              Оператор

 <Вариант>
          case     Константа               Оператор              break




              Рис. 3.8*. Синтаксическая диаграмма <Oператор switch>, C++

   Селектор должен относиться к порядковому типу. Константы выбора должны быть
совместимыми с типом селектора и не могут повторяться.
  Примеры:
               ПАСКАЛЬ                                       C++

                                                 int i; char c; float a, b, y;
      var i : integer; c :
      char; a, b, y : real;
 1)   case i of                             1)
                                             switch (i)
        0, 2, 4, 6, 8 :                      {
      writeln(’Четная цифра’);               case 0: case 2: case 4: case
        1, 3, 5, 7, 9 :                      6:case 8: cout<<″Четная циф-
      writeln(’Нечетная циф-                 ра″; break;
      ра’);                                  case 1: case 3: case 5: case 7:
      end;                                   case 9: cout<<″Нечетная циф-
                                             ра″;
                                             }
  2) case c of                            2) switch (c)
         ’+’ : y:=a+b;                       {
         ’–’ : y:=a–b;                       case ’+’ : y=a+b; break;
         ’*’ : y:=a*b;                       case ’–’ : y=a-b; break;
         ’/’ : y:=a/b;                       case ’*’ : y=a*b; break;
      end;                                   case ’/’ : y=a/b; break;
                                             }
   Выполнение оператора множественного ветвления начинается с проверки селектора.
Если селектор принимает одно из значений констант выбора, то выполняется оператор,
соответствующий этой константе.
   В следующей программе оператор множественного ветвления используется для
перевода римских цифр в десятичные числа.

134
           ПАСКАЛЬ                                     C++
Program P54;                            // Программа P54
 { Перевод римских цифр в               #include <iostream>
десятичные }                            using namespace std;
var	 i : integer; c : char;             // Перевод римских цифр в
begin                                   десятичные
  i:=0;                                 int main()
  writeln(’Введите одну из              {
римских цифр’);                         int i; char c;
  writeln(’I, V, X, L, C, D,            i=0;
M’);                                    cout<<″Введите одну из
  readln(c);                            римских цифр ″;
  case c of                             cout<<″ I, V, X, L,
     ’I’ : i:=1;                            C, D, M \n″;
     ’V’ : i:=5;                        cin>>c;
     ’X’ : i:=10;                       switch (c)
     ’L’ : i:=50;                       {
     ’C’ : i:=100;                      case ’I’ : i=1; break;
     ’D’ : i:=500;                      case ’V’ : i=5; break;
     ’M’ : i:=1000;                     case ’X’ : i=10; break;
  end;                                  case ’L’ : i=50; break;
  if i=0 then writeln(c, ’ –            case ’C’ : i=100; break;
не является римской цифрой’)            case ’D’ : i=500; break;
     else writeln(i);                   case ’M’ : i=1000; break;
  readln;                               }
end.                                    if (i==0) cout<<c<<″ не яв-
                                        ляется римской цифрой″; else
                                        cout<<i;
                                        return 0;
                                          }
   Отметим, что в некоторых версиях языка ПАСКАЛЬ/C++ синтаксис и семантика
оператора case/switch были изменены. Список вариантов может включать опера-
тор, которому предшествует ключевое слово else / default (в некоторых версиях
otherwise).
  Пример:
             ПАСКАЛЬ                       C++
Program P55;                  // Программа P55
 { Модель карманного          /* Модель карманного
калькулятора }                калькулятора */
var a, b : real;              #include <iostream>
    c : char;                 using namespace std;
begin                         int main()
  write(’a=’); readln(a);     {
  write(’b=’); readln(b);     double a, b;
  write(’Код операции ’); re- char c;
adln(c);                      cout<<″a=″; cin>>a;
                              cout<<″b=″; cin>>b;

                                                                         135
  case c of                             cout<<″Код операции ″; cin>>c;
    ’+’ : writeln(’a+b=’, a+b);         switch (c)
    ’–’ : writeln(’a–b=’, a–b);         {
    ’*’ : writeln(’a*b=’, a*b);         case ’+’ : cout<<″a+b=″<<a+b;
    ’/’ : writeln(’a/b=’, a/b);         break;
     else writeln (’Недопусти-          case ’-’ : cout<<″a-b=″<<a-b;
мый код операции’);                       break;
  end;                                  case ’*’ : cout<<″a*b=″<<a*b;
  readln;                                 break;
end.                                    case ’/’ : cout<<″a/b=″<<a/b;
                                          break;
                                        default: cout<<″Недопустимый
                                        код операции″;
                                        }
                                        return 0;
                                        }


  Вопросы и упражнения
  	 Укажите на синтаксических диаграммах рис. 3.8 (соответственно, рис.3.8*)
     пути, которые соответствуют операторам множественного ветвления из
     программ, представленных в этом параграфе.
  	Как выполняется оператор множественного ветвления? Каким должен быть
     тип селектора?
  	Какие константы можно использовать в качестве констант выбора?
  	Замените   операторы множественного ветвления в программах из этого
     параграфа последовательностью эквивалентных ему операторов if.
  	ПРИМЕНИТЕ! Используя оператор множественного ветвления, напишите
     программу, которая переводит десятичные числа 1, 5, 10, 50, 100, 500, 1000,
     считываемые с клавиатуры, в римские цифры.
  	ПРОАНАЛИЗИРУЙТЕ! Что появится на экране в процессе выполнения
     следующих программ?
               ПАСКАЛЬ                                  C++
      Program P56;                      // Программа P56
      type Semnal=(Rosu, Galben,        #include <iostream>
      Verde);                           using namespace std;
      var s : Semnal;                   int main()
      begin                             {
        s:=Verde;                       enum Semnal {Rosu, Galben, Verde};
        s:=pred(s);                     Semnal s;
        case s of                       int x;
         Rosu   : writeln(’СТОП’);      s=Verde; x=s-1;
        Galben : writeln(’ВНИМАНИЕ’);   switch ((Semnal)x)
         Verde : writeln(’СТАРТ’);      {
        end;                            case Rosu : cout<<″СТОП″; break;
        readln;                         case Galben : cout<<″ВНИМАНИЕ″;
      end.                                break;
                                        case Verde : cout<<″СТАРТ″; break;
                                        }
                                        return 0;
                                        }

136
	ПРОАНАЛИЗИРУЙТЕ! Прокомментируйте следующие программы:
        ПАСКАЛЬ                              C++
Program P57;                   // Программа P57
 { Ошибка }                    #include <iostream>
var x : real;                  using namespace std;
begin                          // Ошибка
  writeln(’x=’); readln(x);    int main()
  case x of                    {
     0,2,4,6,8 : writeln       double x;
(’Четная цифра’);              cout<<″x=″; cin>>x;
     1,3,5,7,9 : writeln       switch (x)
(’Нечетная цифра’);            {
  end;                         case 0: case 2: case 4: case 6:
  readln;                        case 8 : cout<<″Четная цифра″;
end.                             break;
                               case 1: case 3: case 5: case 7:
                                 case 9 : cout<<″Нечетная цифра″;
                                 break;
                               }
                               return 0;
                               }

Program P58;                   // Программа P58
 { Ошибка }                    #include <iostream>
var i : 1..4;                  using namespace std;
begin                          // Ошибка
  write(’i=’); readln(i);      int main()
  case i of                    {
     1 : writeln(’один’);      enum Dis {A,B,C,D} x;
     2 : writeln(’два’);       int i;
     3 : writeln(’три’);       cout<<″i=″; cin>>i;
     4 : writeln(’четыре’);    x=(Dis)i;
     5 : writeln(’пять’);      switch (x)
  end;                         {
  readln;                      case A : cout<<″один″; break;
end.                           case B : cout<<″два″; break;
                               case C : cout<<″три″; break;
                               case D : cout<<″четыре″; break;
                               case E : cout<<″пять″; break;
                               }
                               return 0;
                               }

Program P59;                   // Программа P59
 { Ошибка }                    #include <iostream>
type Semnal = (Rosu, Galben,   using namespace std;
  Verde);                      // Ошибка
     Culoare = (Albastru,      int main()
  Portocaliu);                 {
var s : Semnal;                enum Semnal {Rosu, Galben, Verde};
    c : Culoare;               enum Culoare {Albastru,
                                 Portocaliu};

                                                              137
      begin                                Semnal s; Culoare c;
        { ... }                            // ...
        case s of                          switch (s)
         Rosu     :    writeln             {
      (’СТОП’);                            case Rosu : cout<<″СТОП″; break;
         Galben   :    writeln             case Galben : cout<<″ВНИМАНИЕ″;
      (’ВНИМАНИЕ’);                          break;
         Verde    :    writeln             case Verde: cout<<″СТАРТ″; break;
      (’СТАРТ’);                           case Albastru : cout<<″ПАУЗА″;
         Albastru :    writeln             }
      (’ПАУЗА’);                             // ...
        end;                               return 0;
        { ... }                            }
      end.

   	ПРОГРАММИРУЙТЕ! Дни недели понедельник, вторник, ..., воскресенье
     пронумерованы числами 1, 2, 3, ...,7. Напишите программу, которая
     считывает с клавиатуры число x и отображает на экране:
   	 a) название дня, которому соответствует считанное число;
   	 b) сообщение «Учебный день», если число соответствует учебным дням, и
     сообщение «Свободный день», если оно соответствует выходным дням.
   	СОЗДАЙТЕ! Напишите программу, которая многократно выполняет
     следующие операции:
   	1)	 Считывает с клавиатуры действительные числа x и y.
   	2)	 Отображает на экране меню, содержащее  команды, определяющие опе-
         рации, которые необходимо выполнить над  числами x и y.
   	 3)	 Считывает с экрана целое число c, обозначающее выбранную пользова-
         телем команду.
   	 4)	 В зависимости от команды c вычисляет и отображает на экране
         действительное число r – результат выполнения соответствующей
         операции над числами x и y.
   	 5)	 Повторяющийся процесс продолжается до тех пор, пока пользователь не
         выберет из меню команду выхода из программы.
   	 Меню, которое будет отображаться на экране, имеет вид:
   		 ВЫЧИСЛИ:
   		 1. Сумму
   		 2. Разность
   		 3. Произведение
   		 4. Соотношение
   		 5. Выход
   	 Очевидно, целое число c, введенное пользовательем, может принимать только
     значения 1,2, 3, ...., 5. Если пользователь вводит неправильное значение,
     будет отображено сообщение «Неверная команда» и повторяющийся процесс
     возобновится..


   3.13. Оператор for
    Оператор for предназначен для повторного выполнения другого оператора, в зависимости
от значения управляющей переменной. Синтаксис рассматриваемого оператора:

138
    ПАСКАЛЬ
    <Оператор for> ::= for <Переменная> := <Выражение1> <Шаг> <Выражение2>
     							 do <Оператор>
    <Шаг> ::= to | downto
    C++
 <Операция for> ::= for (<Переменная>=<Выражение1>; <Переменная>
							<Операция> <Выражение2> ; <Выражение3>) <Оператор>
  <Операция>::= < | <= | > | >=
  Соответствующие синтаксические диаграммы представлены на рис. 3.9.


                  <Оператор for>

                                   Переменная                  Выражение




                                       Выражение                     Оператор




                  <Оператор for>

                            (      Переменная       =      Выражение1       ;



                        <

                       <=
     Переменная                 Выражение2      ;       Выражение3      )       Оператор
                        >

                       >=

                   Рис. 3.9. Синтаксическая диаграмма <Оператор for>

   Переменная, находящаяся после ключевого слова for, называется управляющей
переменной, параметром цикла или счетчиком. Эта переменная должна принадлежать
некоторому порядковому типу.
   Значения выражений, входящих в состав оператора for, должны быть совместимы-
ми, с точки зрения присваивания, с параметром цикла. Выражение1 указывает исходное
значение параметра цикла, а Выражение2 – конечное значение.
   Оператор, встроенный в цикл for, выполняется для каждого значения из диапазона,
определяемого начальным и конечным значениями.

                                                                                           139
   Процесс выполнения оператора for можно описать так:



   Шаг 1. Вычисляются значения выражений 1 и 2. Эти значения вычисляются только
один раз, в начале выполнения цикла.
   Шаг 2. Сравнивается начальное (Выражение1) и конечное (Выражение2) значения
диапазона повторения. Если конечное значение больше для случая to и меньше для
случая downto, чем начальное значение, оператор, встроенный в цикл for, никогда
не выполняется, и процесс выполнения оператора for завершается.
   Шаг 3. Счетчику присваивается начальное значение (значение Выражения1).
   Шаг 4. Выполняется оператор, встроенный в цикл for. Это может быть простой
или составной оператор.
   Шаг 5. Значение счетчика изменяется (в случае to производится переход к последую-
щему значению, а в случае downto – к предшествующему значению текущего значения
счетчика).
   Шаг 6. Если измененное значение счетчика больше для случая to и меньше для случая
downto конечного значения (Выражения2), выполнение оператора for заканчивается,
в противном случае происходит переход к Шагу 4.



   Шаг 1. Вычисляется значение Выражения1, которое в качестве начального значения
присваивается Переменной-счетчику.
   Шаг 2. Вычисляется значение Выражения2.
   Шаг 3. Вычисляется значение логического выражения, указывающего на условие
повторения.
   Шаг 4. Если текущее значение логического выражения ложно (false), выполнение
оператора for завершается.
   Шаг 5. Если же значение логического выражения истинно (true), выполняется
оператор, встроенный в цикл for. Это может быть простой или составной оператор.
   Шаг 6. Вычисляется выражение 3, которое показывает, насколько текущее значение
счетчика увеличится или уменьшится и осуществляется переход к Шагу 2.
   Примечание. Любое из трех выражений в заголовке оператора for может отсут-
ствовать, обязательным является только наличие двух символов «;» (точка с запятой).
Если Выражение2 отсутствует, условие возобновления итерации считается неявно
удовлетворенным. В этом случае, если принудительный выход (скачком) из цикла не
предусмотрен, выполнение оператора for будет продолжаться бесконечно.
   Пример:
              ПАСКАЛЬ                                  C++
Program P60;                              // Программа P60
 { Оператор for }                         #include <iostream>
var i : integer;                          #include <iomanip>
    c : char;                             using namespace std;
begin                                     // Оператор for
  for i:=0 to 9 do write(i:2);            int main()
  writeln;                                {
                                          int i; char c;

140
for i:=9 downto 0 do                             for (i=0; i<=9; i++)
write(i:2);                                      cout<<setw(2)<<i;
  writeln;                                       cout<<endl;
  for c:=’A’ to ’Z’ do                           for (i=9; i>=0; i--)
write(c:2);                                      cout<<setw(2)<<i;
  writeln;                                       cout<<endl;
  for c:=’Z’ downto ’A’ do                       for (c=’A’; c<=’Z’; c++)
write(c:2);                                      cout<<setw(2)<<c;
  writeln;                                       cout<<endl;
  readln;                                        for (c=’Z’; c>=’A’; c--)
end.                                             cout<<setw(2)<<c;
                                                 cout<<endl;
                                                 return 0;
                                                 }
   Результаты, выводимые на экран:
    0   1   2   3   4   5   6   7   8   9
    9   8   7   6   5   4   3   2   1   0
    A   B   C   D   E   F   G   H   I   J K L M N O P Q R S T U V W X Y Z
    Z   Y   X   W   V   U   T   S   R   Q P O N M L K J I H G F E D C B A
   Значения параметра цикла не могут быть изменены внутри цикла, т. е.
   1) параметру цикла не присваиваются никакие значения;
   2) параметр цикла не может быть параметром цикла другого вложенного опера-
тора for;
   3) нельзя использовать операторы считывания, в которых указывается параметр
цикла.
   После выхода из оператора for значение параметра цикла не определено, за исклю-
чением случая, когда выход из цикла осуществляется принудительно, через оператор
безусловного перехода goto.
   Оператор for используется для программирования итеративных алгоритмов, в кото-
рых число повторений известно. В качестве примера рассмотрим программы, которые
                              n
вычисляют соответственно n!, x , и сумму                     .

          ПАСКАЛЬ                                             C++
Program P61;                                     // Программа P61
 { Вычисление факториала }                       // Вычисление факториала
var n, i, f : 0..MaxInt;                         #include <iostream>
begin                                            using namespace std;
  write(’n=’); readln(n);                        int main()
  f:=1;                                          {
  for i:=1 to n do f:=f*i;                       unsigned short int n, i, f;
  writeln(’n!=’, f);                             cout<<″n=″; cin>>n;
  readln;                                        f=1;
end.                                             for (i=1; i<=n; i++) f=f*i;
                                                 cout<<″n!=″<<f<<endl;
                                                 return 0;
                                                 }

                                                                               141
Program P62;                          // Программа P62
 { Вычисление х в степени n }           /* Вычисление х в степени n */
var x, y : real;                      #include <iostream>
     n, i : 0..MaxInt;                using namespace std;
begin                                 int main()
  write(’x=’); readln(x);             {
  write(’n=’); readln(n);             float x, y;
  y:=1;                               unsigned short int n, i;
  for i:=1 to n do y:=y*x;            cout<<″x=″; cin>>x;
  writeln(’y=’, y);                   cout<<″n=″; cin>>n;
  readln;                             y=1;
end.                                  for (i=1; i<=n; i++) y=y*x;
                                      cout<<″y=″<<y<<endl;
                                      return 0;
                                      }

Program P63;                          // Программа P63
 { Вычисление суммы 1 + 1/2 +         /* Вычисление суммы 1 + 1/2 +
1/3 + ... + 1/n }                     1/3 + ... + 1/n */
var n, i : 1..MaxInt;                 #include <iostream>
     s : real;                        using namespace std;
begin                                 int main()
  write(’n=’);                        {
  readln(n);                          unsigned short int n, i;
 s:=0;                                double s;
  for i:=1 to n do s:=s+1/i;          cout<<″n=″; cin>>n;
  writeln(’s=’, s);                   s=0;
  readln;                             for (i=1; i<=n; i++)
end.                                  s=s+(double)1/i;
                                      cout<<″s=″<<s<<endl;
                                      return 0;
                                      }


  Вопросы и упражнения
  	Укажите на синтаксической диаграмме рис. 3.9 пути, которые соответствуют
     операторам for из программы Р60, для языка ПАСКАЛЬ или C++ (соответ-
     ственно выбору языка).
  	Как выполняется оператор for?
  	 ПРОАНАЛИЗИРУЙТЕ! Что выведут на экран следующие программы?
              ПАСКАЛЬ                                C++
      Program P64;                  Программа P64
      type Zi = (L, Ma, Mi, J, V,   #include <iostream>
      S, D);                        using namespace std;
      var z : Zi;                   int main()
      begin                         {
        for z:=L to S do            enum Zi {L,Ma,Mi,J,V,S,D};

142
      writeln(ord(z));              int z;
        readln;                     for (z=(int)L; z<=(int)V; z++)
        for z:=D downto Ma do       cout<<z; cout<<endl;
      writeln(ord(z));              for (z=(int)D; z>=(int)Ma; z--)
        readln;                     cout<<z; cout<<endl;
      end.                          return 0;
                                    }
  	Даны объявления:
              ПАСКАЛЬ                               C++
      var i, j, n : integer;        int i,j,n;
          x, y : real;              double x,y;
          c : char;                 char c;

  	    Какие из следующих операторов являются синтаксически правильными?

             ПАСКАЛЬ                               C++
 a)    for i:=–5 to 5 do j:=i+3     a)   for (i=–5; i<=5; i++) j=i+3
 b)    for i:=–5 to 5 do i:=j+3     b)   for (i=–5; i<=5; i++) i=j+3
 c)    for j:=–5 to 5 do i:=j+3     c)   for (j=–5; i<=5; i++) i=j+3
 d)    for i:=1 to n do y:=y/i      d)   for (i=1; i<=n; i++) y=y/i
 e)    for x:=1 to n do y:=y/x      e)   for (x=1; x<=n; x++) y=y/x
       for c:=’A’ to ’Z’ do              for (c=’A’; c<=’Z’; c++)
 f)    writeln(ord(c))              f)   cout<<(int)c
       for c:=’Z’ downto ’A’ do          if (c=’Z’; c>=’A’; c--)
 g)    writeln(ord(c))              g)   cout<<c
       for i:=–5 downto –10 do
 h)    readln(i)                    h)   if (i=–5; i>=–10; i--) cin>>i

       for i:=ord(’A’) to                for (i=(int)’A’; i<=(int)
 i)    ord(’A’)+ 9 do writeln(i)    i)   ’A’+9; i++) cout<<i
       for c:=’0’ to ’9’ do              for (c=’0’; c<=’9’; c++)
 j)    writeln(c, ord(c):3)         j)   cout<<c<<setw(3)<<(int)c
       for j:=i/2 to i/2+10 do           for (j=i/2; j<=i/2+10; j++)
 k)    writeln(j)                   k)   cout<<j
 	 ПРОАНАЛИЗИРУЙТЕ! Даны объявления:
		        П А С К А Л Ь 				                        C++
         var i, m, n : integer;			              int i, m, n;
  	    Сколько раз будут выполнены   операторы вывода, входящие в состав
       операторов  for?
                ПАСКАЛЬ                              C++
      for i:=m to n do writeln(i);   for (i=m; i<=n; i++) cout<<i;
      for i:=m to n do writeln(2*i); for (i=m; i<=n; i++) cout<<2*i;

                                                                       143
  если:
  	a)	m=1, n=5;	                              c)	 m=3, n=3;
  	b)	m=3, n=5;	                              d)	 m=5, n=3.

  	ПРИМЕНИТЕ! Напишите программу, которая выводит на экран коды
    символов ’A’, ’B’, ’C’, ..., ’Z’.
  	Вычислите для первых n элементов:
  	a)	1 + 3 + 5 + 7 +… 	 и	1·3·5·7·…;
  	b)	2 + 4 + 6 + 8 +… 	 и	2·4·6·8·…;
  	c)	3 + 6 + 9 + 12 +… 	 и	3·6·9·12·…;	
  	d)	4 + 8 + 12 + 16 +… 	и	4·8·12·16·… ;
               1 —
       e)	 1 – —  1 1 1 1
  	              + – — + — – — + ... .
               2 3 4 5 6
  	  Например: При n=3 имеем 1 + 3 + 5 = 9; 1·3·5 = 15.
  	 Напишите программу, которая считывает с клавиатуры n целых чисел и
     отображает на экране:
  	 a) сколько из введенных чисел являются четными;
  	b) сумму положительных чисел, введенных с клавиатуры;
  	c) сумму всех чисел, введенных с клавиатуры;
  	d) среднее арифметическое значение введенных чисел.
  	 Напишите программу, которая считывает с клавиатуры n символов и
     отображает на экране, сколько раз в этой последовательности символов были
     набраны буквы A и B.
  	 Увлеченный садоводством Михай посадил несколько деревьев. В первый
     год плодоношения с одной из яблонь Михай собрал M яблок, а в следующем
     году урожай вырос на P процентов. Напишите программу, которая опреде-
     лит количество яблок в урожае N-го  года. Числа M, P и N нужно считать с
     клавиатуры.
   	 В парке, созданном при поддержке учеников-волонтеров из местной средней
     школы, для маленьких детей установили качели. В парке играют четверо
     детей. Напишите программу, которая определяет, могут ли двое из этих детей
     сесть на качели так, чтобы качели находились в равновесии. Вес каждого
     из детей считывается с клавиатуры.



  3.14.Составной оператор
  Синтаксис составного оператора:
  ПАСКАЛЬ
      <Составной оператор> ::= begin <Оператор> {; <Оператор>} end
      C++
      <Составной оператор> ::= { <Оператор> ;{ <Оператор>;} }

144
  Соответствующая синтаксическая диаграмма представлена на рис. 3.10.


             <Составной оператор>
                                     Оператор




             <Составной оператор>
                         {           Оператор                  }




             Рис. 3.10. Синтаксическая диаграмма <Составной оператор>
  Примеры:
             ПАСКАЛЬ                                       C++
 1)   begin                              1)   {
        a:=x+12;                              a=x+12;
        p:=q and r;                           p=q && r;
        writeln(p)                            cout<<p<<endl;
      end;                                    }
 2)   begin                              2)   {
        write(’x=’);                          cout<<”x=”;
        readln(x)                             cin>>x;
      end;                                    }
   В языке ПАСКАЛЬ ключевые слова begin и end соответственно, символы { и }
выступают в роли “скобок”. Последовательность операторов, заключенных в данные
скобки, является, с точки зрения языка, одним оператором. Таким образом, составной
оператор используется для того, чтобы несколько операторов поместить в те места
программы, где разрешается наличие только одного оператора (см. операторы if,
for, case, switch и др.).
  Примеры:
  	   ПАСКАЛЬ
  1)	 if a>0 then begin x:=a+b; y:=a*b end
             else begin x:=a–b; y:=a/b end;
  2)	 case c of
     		 ’+’ : begin y:=a+b; writeln(’Сложение’) end;
     		 ’–’ : begin y:=a–b; writeln(’Вычитание’) end;
     		 ’*’ : begin y:=a*b; writeln(’Произведение’) end;
     		 ’/’ : begin y:=a/b; writeln(’Деление’) end;
  	 end ;

                                                                              145
  3)	 for i:=1 to n do
     		 begin
       	 write(’x=’);
       	 readln(x);
       	 s:=s+x
     		 end;

  	C++
  1)	 if (a>0) {x=a+b; y=a*b ;}
        	 else {x=a-b; y=a/b;}
  2)	 switch (c)
  	 {
  	case ’+’ :        y=a+b;    cout<<Сложение \n″; break;
  	case ’-’ :        y=a-b;    cout<<Вычитание \n″; break;
  	case ’*’ :        y=a*b;    cout<<Произведение \n″; break;
  	case ’/’ :        y=a/b;    cout<<Деление \n″; break;
  	 }
  3)	 for (i=1; i<=n; i++)
  	 {
       cout<<″x=″;
       cin>>x;
       s=s+x;
  	 }
   Отметим, что выполняемая часть любой программы является составным операто-
ром, так как она представляет собой последовательность операторов, заключенных в
“скобки” begin и end в языке ПАСКАЛЬ или { и } в C++.
   Для того чтобы программы были удобными для чтения, “скобки” операторов пи-
шутся строго одна под другой, а операторы внутри “скобок” смещаются на несколько
позиций вправо. Если составные операторы включаются в состав других операторов
(if, for, case, switch и др.), то их “скобки” смещаются вправо.
   В качестве примера рассмотрим программу на языке ПАСКАЛЬ и соответственно
на C++, в которой вычисляется среднее арифметическое n чисел, считываемых с кла-
виатуры.

                                 ПАСКАЛЬ
Program P65;
 { Среднее арифметическое n чисел }
var x, Suma, Media : real;
    i, n : integer;
begin
   write(’n=’); readln(n);
   Suma:=0;
   writeln(’Введите ’, n, ’ чисел:’);
   for i:=1 to n do

146
      begin
         write(’x=’); readln(x);
         Suma:=Suma+x;
      end;
   if n>0 then
      begin
         media:=Suma/n;
         writeln(’среднее=’, Media);
      end
   else
      writeln(’Media= *****’);
   readln;
end.

                                C++
// Программа P65
// Среднее арифметическое n чисел
#include <iostream>
using namespace std;
int main()
{
  double x, Suma, Media;
  int i, n;
  cout<<″n=″; cin>>n;
  Suma=0;
  cout<<″Введите ″<<n<<″ чисел:″<<endl;
  for (i=1; i<=n; i++)
  {
  cout<<″x=″; cin>>x;
  Suma=Suma+x;
  };
  if (n>0)
  {
  Media=Suma/n;
  cout<<″среднее= ″<<Среднее<<endl;
  }
  else cout<<″Media= *****″;
  return 0;
}


 Вопросы и упражнения
 	Для чего необходим  составной оператор?
 	Укажите на синтаксической диаграмме рис. 3.10 пути, которые соответ-
   ствуют составному оператору из программы Р65,вариант ПАСКАЛЬ, или
   соответственно вариант C++.

                                                                   147
  	ПРИМЕНИТЕ! Напишите программу, которая считывает с клавиатуры n
    чисел и затем выводит на экран:
  	 a) сумму и среднее арифметическое считанных чисел;
  	 b) сумму и среднее арифметическое положительных чисел;
  	 c) сумму и среднее арифметическое отрицательных чисел;
  	Напишите программу, которая считывает с клавиатуры n символов и затем
    выводит на экран:
  	a) количество считанных десятичных цифр;
  	b) количество четных цифр;
  	c) количество нечетных цифр;
  	d) количество считанных букв;
  	e) количество гласных;
  	f) количество согласных.
  	 Вводимые символы разделяются нажатием   клавиши <E N T E R >.
    Предполагается, что будут вводиться десятичные цифры 0, 1, 2, ... 9 и
    прописные буквы латинского алфавита A, B, C, ... Z.
  	Напишите программу, которая считывает с клавиатуры целое число n и
    выводит на экран «фигуры», состоящие из цифр:
  a)	 1              b)	 123456...n     c)	 1              d)	      1
  	12                	...               	22                        222
  	123               	1234              	333                      33333
  	1234              	123               	4444                      ...
  	...               	12                	...                     nnnnnnn
  	1234...n          	1                 	nnn...n                   ...
                                                                  33333
                                                                   222
                                                                    1



  3.15. Оператор while
   Как и любой другой язык программирования, языки ПАСКАЛЬ и C ++ имеют не-
сколько операторов для управления повторным выполнением других операторов, други-
ми словами, для организации циклов. С одним из таких операторов мы познакомились
в предыдущих параграфах, а именно с оператором for.
   Напоминаем, что оператор for повторно выполняет другой оператор, простой или
составной, определенное количество раз, известное на момент написания программы.
Однако бывают также ситуации, когда количество повторений неизвестно на момент
написания программы, например, когда требуется повторять вычисления до тех пор,
пока не будет выполнено определенное условие или не будет достигнута определенная
цель. Такие ситуации возникают при написании программ, предназначенных для вычис-
лений, направленных на получение максимальной прибыли, минимизацию возможных
затрат, прогнозирование доходов или убытков компании, моделирование процессов
распространения эпидемий и т. д.
   Операторы повторения, которые позволяют организовать циклы с заранее неиз-
вестным числом повторений, в зависимости от текущих значений других переменных
в программе, подразделяются на:
   • операторы повторения с начальным тестом (предусловием);
   • операторы повторения с конечным тестом (постусловием).

148
   В этом параграфе мы изучим оператор повторения с начальным тестом. Этот оператор
обозначается ключевым словом while. Он содержит логическое выражение, которое
контролирует повторное выполнение другого оператора. Синтаксис этого оператора:
   ПАСКАЛЬ
      <Оператор while> ::= while <Логическое выражение> do <Оператор>

      C++
      <Оператор while> ::= while (<Логическое выражение>) <Оператор>
   Синтаксическая диаграмма оператора представлена на рис. 3.11.


            <Оператор while>

                          Логическое выражение             Оператор




            <Оператор while>

                         (     Логическое выражение    )      Оператор



                Рис. 3.11. Синтаксическая диаграмма <Оператор while>>

   Примеры:
              ПАСКАЛЬ                                       C++
 1)   while x>0 do x:=x–1;                1)     while (x>0) x=x-1;
 2)   while x<3.14 do                     2)     while (x<3.14)
        begin                                     {
          x:=x+0.001;                               x=x+0.001;
          writeln(sin(x));                          cout<<sin(x);
        end;                                      }
 3)   while p do                          3)     while (p)
        begin                                     {
          x:=x+0.001;                                x=x+0.001;
          y:=10*x;                                   y=10*x;
          p:=y<1000;                                 p=y<1000;
        end;                                      }
   Выполнение простого либо составного оператора из состава оператора while
повторяется до тех пор, пока значение логического выражения равно true. Если зна-
чение логического выражения становится false, соответствующий оператор больше
не выполняется. Рекомендуется, чтобы логическое выражение было как можно более
простым, так как оно вычисляется при каждой итерации.

                                                                               149
   Обычно оператор while используется при организации вычислений с переменными
контроля вещественного типа.
   В нижеследующих программах оператор while применяется для вывода на экран
значений функции y=2x. Аргумент x принимает значения от х1 до х2 с шагом Δх.
             ПАСКАЛЬ                                  C++
Program P66;                            // Programul P66
 { Таблица функции y=2*x }              // Таблица функции y=2*x
var x, y, x1, x2, deltaX : real;        #include <iostream>
begin                                   #include <iomanip>
  write(’x1=’); readln(x1);             using namespace std;
  write(’x2=’); readln(x2);             int main()
  write(’deltaX=’);                     {
  readln(deltaX);                       double x, y, x1, x2, deltaX;
  writeln(’x’:10, ’y’:20);              cout<<″x1=″; cin>>x1;
  writeln;                              cout<<″x2=″; cin>>x2;
  x:=x1;                                cout<<″deltaX=″; cin>>deltaX;
  while x<=x2 do                        cout<<setw(10)<<’x’<<setw(20)
     begin                              <<’y’;
       y:=2*x;                          cout<<endl;
       writeln(x:10, y:20);             x=x1;
       x:=x+deltaX;                     while (x<=x2)
     end;                                 {
  readln;                                  y=2*x;
end.                                       cout<<setw(10)<<x<<setw(20)
                                                   <<y<<endl;
                                           x=x+deltaX;
                                          }
                                        return 0;
                                        }

   Оператор while особенно полезен в случаях, в которых трудно вычислить число
повторений некоторой последовательности операторов.
   Для примера представляем программу P67, которая отображает на экране среднее
арифметическое положительных чисел, считанных с клавиатуры.

             ПАСКАЛЬ                                 C++
Program P67;                            // Программа P67
{Среднее арифметическое                 #include <iostream>
положительных чисел,                    /* Среднее арифметическое
считанных с клавиатуры}                 положительных чисел, считанных
var x, suma : real;                     с клавиатуры */
    n : integer;                        #include <iomanip>
begin                                   using namespace std;
  n:=0;                                 int main()
  suma:=0;                              {

150
  writeln(’Введите                      double x, suma;
положительные числа:’);                 int n;
  readln(x);                            n=0;
  while x>0 do                          suma=0;
     begin                              cout<<″Введите положительные
       n:=n+1;                          числа: \n″;
       suma:=suma+x;                    cin>>x;
       readln(x);                       while (x>0)
     end;                                 {
  writeln(’Вы ввели ’,n, ’                   n=n+1;
положительных чисел.’);                      suma=suma+x;
  if n>0 then writeln                        cin>>x;
(’среднее=’, suma/n)                        };
           else                         cout<<″Вы ввели ″<<n<<
writeln(’среднее=*****’);               ″положительных чисел.\n″;
  readln;                               if (n>0) cout<<среднее=″<<su-
end.                                    ma/n<<endl;
                                        else cout<<среднее=*****″;
                                        return 0;
                                        }
   Обратите внимание, что количество повторных выполнений оператора, входящего
в состав оператора while, не может быть рассчитано заранее. Выполнение оператора
while заканчивается, когда пользователь вводит число x≤0.


  Вопросы и упражнения
  	Как выполняется оператор while?
  	Укажите на синтаксических диаграммах рис. 3.11 пути, которые
    соответствуют операторам while в программах Р66 и Р67 для варианта
    ПАСКАЛЬ или C++, соответственно.
  	ПРИМЕНИТЕ! Используя оператор while, напишите программу, которая
    выводит на экран значения функции y = f(x) для аргумента, принимающего
    значения от х1 до х2 с шагом ∆x:

  	   a)	         	                           c)	

  	   b)	     	                               d)	

  	ПРИМЕНИТЕ! Пользователь вводит с клавиатуры целые положительные
    числа, разделяемые нажатием клавиши <ENTER>. Признаком конца
    последовательности является число 0. Напишите программу, которая
    выводит на экран:
  	 a) сумму и среднее арифметическое четных чисел;
  	 b) сумму и среднее арифметическое нечетных чисел.

                                                                            151
  	ПРОАНАЛИЗИРУЙТЕ И ПРИМЕНИТЕ! Напишите программу, которая
    выводит на экран значения функции y = f(x). Аргумент х принимает значения
    от х1 до х2 с шагом ∆x:

      a)                                    c)
  	        	          	                       	              	


      b)                                    d)
  	        	          	                          	


  Пример:

                ПАСКАЛЬ                                C++
Program P68;                          // Программа P68
 { Таблица функции }                  // Таблица функции
var x, y, x1, x2, deltaX :            #include <iostream>
real;                                 #include <iomanip>
begin                                 using namespace std;
  write(’x1=’); readln(x1);           int main()
  write(’x2=’); readln(x2);           {
  write(’deltaX=’); readln(del-       double x, y, x1, x2, deltaX;
taX);                                 cout<<″x1=″; cin>>x1;
  writeln(’x’:10, ’y’:20);            cout<<″x2=″; cin>>x2;
  writeln;                            cout<<″deltaX=″; cin>>deltaX;
  x:=x1;                              cout<<setw(10)<<’x’<<setw(20)
  while x<=x2 do                      <<’y’;
    begin                             cout<<endl;
       if x>8 then y:=x+1 else        x=x1;
y:=x-2;                               while (x<=x2)
       writeln(x:20, y:20);             {
       x:=x+deltaX;                       if (x>8) y=x+1; else y=x-2;
     end;                                 cout<<setw(10)<<x<<setw(20)
  readln;                             <<y
end.                                      <<endl;
                                          x=x+deltaX;
                                        }
                                      return 0;
                                      }

 	ОТКРОЙТЕ! Оператор повторения
		        П А С К А Л Ь 				                                     C++
           for i:=i1 to i2 do	           for (i=i1; i<=i2; i++) cout<<i;
                        writeln(ord(i))	

152
 эквивалентен следующей последовательности операторов:
               ПАСКАЛЬ                               C++
     i:=i1;                              i=i1;
     while i<=i2 do                      while (i<=i2)
       begin                               {
         writeln(ord(i));                    cout<<i;
         i:=succ(i);                         i:=i+1;
       end.                                }
 	    Напишите эквивалентную последовательность операторов для оператора
      повторения:
		              П А С К А Л Ь 				                          C++
        for i:=i1 downto i2 do 	      for (i=i1; i>=i2, i--) cout<<i;
                      writeln(ord(i))

 	ПРОАНАЛИЗИРУЙТЕ И ОТКРОЙТЕ! Даны описания:
		        П А С К А Л Ь 				                  C++
        var x1, x2, deltaX : real;       double x1, x2, deltaX;
            i, n : integer;	             int i, n;

 	    Какие из следующих последовательностей операторов эквивалентны?
            ПАСКАЛЬ                                 C++
1)    x:=x1;                        1)   x=x1;
      while x<=x2 do                     while (x<=x2)
      begin                               {
        writeln(x);                         cout<<x<<endl;
        x:=x+deltaX;                        x=x+deltaX;
      end;                               };
2)    n:=trunc((x2–x1)/deltaX)+1;   2)   n=trunc((x2–x1)/deltaX)+1;
      x:=x1;                             x=x1;
      for i:=1 to n do                   for (i=1; i<=n; i++)
        begin                               {
          writeln(x);                          cout<<x<<endl;
          x:=x+deltaX;                         x=x+deltaX;
        end;                                };
3)    n:=round((x2–x1)/deltaX)+1;   3)   n=round((x2–x1)/deltaX)+1;
      x:=x1;                             x=x1;
        for i:=1 to n do                  for (i=1; i<=n; i++)
          begin                            {
            writeln(x);                       cout<<x<<endl;
            x:=x+deltaX;                      x=x+deltaX;
          end;                             };
 	    Аргументируйте свой ответ.

                                                                        153
  	ПРОГРАММИРУЙТЕ! Используя оператор повторения while, напишите
      программу, которая вводит с клавиатуры  натуральное ненулевое число N
      и отобразит на экране:
  a)	 последнюю цифру числа N;
  b)	 первую цифру числа N;                       ЗНАЕТЕ ЛИ ВЫ, ЧТО
  c)	 сумму цифр числа N                          Самый длинный в мире
  d)	 произведение цифр числа N;                  палиндром написан на
  e)	 сколько раз цифра C появляется в за-
      писи числа N. Цифра C считывается с финском языке Теему
      клавиатуры;                                 Пааволайненом (Teemu
  f)	 наибольшую цифру из записи числа N;         Paavolainen) в 1992 году.
  g)	 наименьшую цифру из записи числа N;
  h)	 перевертыш числа N (число, записанное
                                                  В нем 49 935 знаков.
      в обратном порядке). Например, для N = (Источник ro.wikipedia.org)
      12345 будет выведено 54321;
  i)	 число N, в котором первая и последняя цифры поменяны местами. Например,
      для N = 1234 будет выведено 4231;
  j)	 сообщение ”палиндром” или ”не палиндром” в зависимости от того, обладает
      или нет число таким свойством. Число является палиндромом, если оно
      совпадает со своим перевертышем. Например, для N = 1234321 будет
      выведено ”палиндром”.
  	Напишите программу, которая:
  a)	 сначала вводит с клавиатуры символ, который обозначим с;
  b)	 затем по одному вводить с клавиатуры символы, количество которых априори
      неизвестно;
  c)	 процесс ввода символов  прерывается вводом символа ”!”;
  d)	 выводит на экран   количество появлений символа с во введенной с
      клавиатуры последовательности символов.
  	Банк предоставляет годовую процентную ставку, равную p процентам.
      Напишите программу, которая вычисляет и отображает на экране:
  a)	 сумму денег, которая будет через x лет у клиента, изначально внесшего Si
      лей. Значения p, x и Si считываются с клавиатуры.
  b)	 через сколько лет на счету клиента, который изначально внес Si лей, будет
      Sf лей? Значения p, Si и Sf считываются с клавиатуры.



  3.16.Оператор повторения с постусловием
   В операторах повторения с постусловием проверка условия окончания цикла осу-
ществляется после выполнения входящих в их состав операторов.
   В языке ПАСКАЛЬ оператор повторения с постусловием обозначается ключевыми
словами repeat … until (повторять… пока), а в C++ – ключевыми словами do …
while (делать… пока).
   Синтаксис этих операторов:
     ПАСКАЛЬ
   <Оператор	    repeat> ::=
   		         	 repeat <Оператор> {;<Оператор>} until <Логическое выражение>
     C++
   < Оператор	 do...while> ::=
   			           do {<Оператор>;{ <Оператор>;}} while (<Логическое выражение>)

154
  Синтаксические диаграммы представлены на рисунке 3.12.


                   <Оператор repeat>

                               Оператор                    Логическое выражение




             <Оператор do...while>

                 do     {       Оператор        ;      }




                              while        (    Логическое выражение      )


      Fig. 3.12. Синтаксические диаграммы операторов повторения с постусловием

             ПАСКАЛЬ                                          C++
 1)   repeat x:=x–1 until x<0;             1)   do x=x-1; while (x>=0);
 2)   repeat                               2)   do
        y:=y+delta;                              { y=y+delta;
        writeln(y)                                 cout<<y<<endl; }
      until y>20.5;                             while (y<=20.5);
 3)   repeat                               3)   do
        readln(i);                              { cin>>i;
        writeln(odd(i))                          (i%2==0)? cout<<″True \n″ :
      until i=0;                                            cout<<″False \n″;
                                                 }
                                                while (i!=0);
   Простые или составные операторы, входящие в состав оператора повторения с
постусловием, выполняются повторно до тех пор, пока логическое выражение ложно,
в случае языка ПАСКАЛЬ и истинно в случае языка C++. Когда это выражение стано-
вится истинным (ПАСКАЛЬ) и соответственно ложным (C++), управление передается
оператору, следующему за оператором повторения.
   Очевидно, что операторы из состава оператора повторения с постусловием будут
выполнены по крайней мере один раз, потому что вычисление логического выражения
происходит после их выполнения.
   Обычно операторы повторения с постусловием используются вместо операторов
повторения с начальным тестом, когда оценку выражения, управляющего повторени-
ем, необходимо осуществить после выполнения последовательности операторов из их
состава.

                                                                                  155
   Следующие программы отображают на экране четность целых чисел, считанных с
клавиатуры.
          ПАСКАЛЬ                                      C++
Program P69;                             // Программа P69
 { Четность целых чисел,                 /* Четность целых чисел,
считанных с клавиатуры }                 считанных с клавиатуры */
var i : integer;                         #include <iostream>
begin                                    #include <iomanip>
 writeln(’Введите целые чис-             using namespace std;
ла:’);                                   int main()
  repeat                                 {
   readln(i);                              int i;
   if odd(i) then                         cout<<″Введите целые числа:″;
   writeln(i:6, ’– нечетное                do
число’)                                     {
              else                            cin>>i;
   writeln(i:6, ’ – четное                  if (i%2!=0) cout<<setw(6)
число’);                                 <<i<<″ нечетное число\n″;
  until i=0;                                  else cout<<setw(6)<<i<<
  readln;                                ″четное число\n″;
end.                                        }
                                           while (i!=0);
                                         return 0;
                                         }
   Выполнение оператора повторения заканчивается, когда пользователь вводит i=0.
   Оператор повторения с постусловием часто применяется для проверки правильности
ввода с клавиатуры исходных данных.
   Например, предположим, что необходимо написать программу, считывающую с
клавиатуры вещественное число x и выводящую на экран квадратный корень           .
Очевидно, отрицательные значения переменной x недопустимы.

           ПАСКАЛЬ                                        C++
Program P70;                              // Программа P70
 { Вычисление квадратного                 /* Вычисление квадратного
корня }                                   корня */
var x, y : real;                          #include <iostream>
begin                                     #include <cmath>
  repeat                                  using namespace std;
     write(’Введите                       int main()
неотрицательное число x=’);               {
     readln(x);                             double x, y;
  until x>=0;                               do
  y:=sqrt(x);                                {
  writeln(’Квадратный корень                     cout<<″Введите
y=’, y);                                      неотрицательное число x=″;
  readln;                                        cin>>x;
end.                                           }

156
                                            while (x<0);
                                            y=sqrt(x);
                                            cout<<″Квадратный корень
                                          y=″<<y;
                                            return 0;
                                          }
   После запуска этих программ на выполнение пользователю предлагается ввести число,
большее или равное нулю. Если пользователь случайно вводит отрицательное число,
операторы чтения и записи, входящие в состав оператора повторения, будут выполнены
снова. Повторяющийся процесс будет продолжаться до тех пор, пока пользователь не
введет правильное значение.
   Из приведенных примеров видно, что оператор повторения с постусловием полезен
в ситуации, когда количество повторных выполнений последовательности операторов
трудно оценить.



   Вопросы и упражнения
   	Как выполняется оператор повторения с постусловием?
   	Укажите на синтаксических диаграммах, приведенных на рисунке 3.12,
     пути, соответствующие  операторам повторения с постусловием из программ
     данного параграфа.
   	ПРОАНАЛИЗИРУЙТЕ! Даны следующие операторы:
            ПАСКАЛЬ                                        C++
 a)                                      a)   do
       repeat
                                              { <Оператор 1>;
         <Оператор 1>;
                                                 <Оператор 2>;
         <Оператор 2>;
                                                 ...
         ...
                                                 <Оператор n>;
         <Оператор n>;
                                               }
       until p
                                              while (!p)
 b)    while not p do                    b)   while (!p)
         begin                                 {
           <Оператор 1>;                           <Оператор 1>;
           <Оператор 2>;                           <Оператор 2>;
            ...                                      ...
           <Оператор n>;                           <Оператор n>;
         end.                                    }
   	   Являются ли эти операторы эквивалентными? Аргументируйте свой ответ.
   	ПРИМЕНИТЕ! Разработайте программу, которая считывает с клавиатуры
     последовательность символов и отображает на экране:
   		 a) количество прочитанных АРАБСКИХ цифр;
   		 b) количество четных цифр;
   		 c) количество нечетных цифр.

                                                                                157
    	 Введенные символы разделяются нажатием клавиши <ENTER>. Допускают-
      ся десятичные цифры 0, 1, 2, ..., 9 и символ *, обозначающий конец
      последовательности.
    	Разработайте программу, которая считывает с клавиатуры вещественное
      число x и отображает значение выражения . Очевидно, что значение х=0
      недопустимо. Проведите проверку правильности ввода данных с клавиатуры
      с помощью оператора повторения с постусловием.
    	ПРОАНАЛИЗИРУЙТЕ! Является ли эквивалентным оператор
	               П А С К А Л Ь 				 C + +
           for i:=i1 to i2 do	           for (i=i1; i<=i2; i++) cout<<i;
                        writeln(ord(i))	
    	 c последовательностью операторов?
                 ПАСКАЛЬ                                   C++
        i:=i1;                             i=i1;
        repeat                             do
          writeln(ord(i));                  {
          i:=succ(i) ;                        cout<<i;
        until i>i2;                           i=i+1;
                                            }
                                           while (i<=i2);
    	    Аргументируйте свой ответ.
    	ПРИМЕНИТЕ! Напишите программу, которая выведет на экран значения
      функции у = f(x). Аргумент функции x принимает значения от х1 до х2 с
      шагом Δх. Цикл необходимо организовать с помощью оператора повторения
      с постусловием.
    	    a)	      	c)	

    	    b)	       	d)	

    	 ПРИМЕНИТЕ! Разработайте программу, которая считывает с клавиатуры
        последовательность символов и отображает на экране:
    		    a) количество считанных букв;
    		    b) количество заглавных букв;
    		    c) количество строчных букв.
    	 Введенные символы разделяются нажатием клавиши <ENTER>. Допуска-
        ются только буквы латинского алфавита и символ *, обозначающий конец
        последовательности.
     	 В банке, в целях безопасности, код сейфа меняется еженедельно. Код счи-
        тается безопасым, если количество четных цифр, входящих в состав кода,
        превышает количество нечетных цифр. Напишите программу, которая
        проверяет, удовлетворяет ли введенный код условиям безопасности, чтобы
        банк мог его использовать. Цифры кода вводятся до тех пор, пока не будет
        введена цифра 0, которая указывает на конец кода и не является его частью.

158
   3.17. Оператор goto
   Как правило, операторы программы выполняются последовательно в том порядке,
в котором они появляются в тексте программы. Оператор безусловного перехода goto
позволяет изменить этот порядок и продолжить работу в другой части текста программы.



   В языке ПАСКАЛЬ синтаксис рассматриваемого оператора:

    <Оператор goto> ::= goto <Метка>
    Напомним, что метка в ПАСКАЛЕ – это целое число без знака, которое предшествует
некоторому оператору программы (рис. 3.1, стр. 93). Метки перечисляются в разделе
описаний программы после ключевого слова label. Синтаксис данного описания:
    <Раздел описания меток> ::= label <Метка> {, <Метка>};
   Синтаксические диаграммы соответствующих грамматических единиц представлены
на рис. 3.13.
   Отметим, что перечисление меток в разделе описаний label обязательно.

            <Оператор goto>

                                              Метка



            <Раздел описания меток>

                                       Метка




                Рис. 3.13. Синтаксические диаграммы <Оператор goto>
                       и <Раздел описания меток>, язык ПАСКАЛЬ

   При выполнении оператора goto управление передается оператору, помеченному
соответствующей меткой.
   В качестве примера представим программу Р71, которая вычисляет значение функции




   Значения аргумента х считываются с клавиатуры.
    Program P71;
     { Выполнение оператора goto }
    label 1, 2;

                                                                                159
      var x, y : real;
      begin
        write(’x=’); readln(x);
        if x>=0 then goto 1;
        y:=2*x;
        writeln(’x<0, y=’, y);
        goto 2;
      1: y:=x;
        writeln(’x>=0, y=’, y);
      2: readln;
      end.
   Если пользователь набирает любое значение х, x≥0, то выполняется оператор goto
1 и управление передается оператору присваивания:
      1: y:=x;
  После этого выполняются операторы:
      	 writeln(’x>=0 , y=’, y);
      2:	readln;
  Если пользователь набирает любое значение x < 0, то выполняются операторы:
      y:= 2*x;
      writeln(’x<0 , y=’, y);
      goto 2;
  Последний оператор передает управление оператору:
      2: readln;
   В любой программе для меток и операторов должны выполняться следующие правила:
   1) каждая метка должна быть описана с помощью ключевого слова label;
   2) каждая метка должна стоять перед одним и только одним оператором;
   3) переходы внутрь структурированных операторов (if, for, while, ... и др.)
запрещаются.
  Пример:
  1)	 if i>5 then 1: writeln(’i>5’) else writeln(’i<=5’);
  	...
  	 goto 1; {Ошибка}	

  2)	 for i:=1 to 10 do
  	begin
  	 10: writeln(’i=’, i);
  	 end;
  	...
  	 goto 10; {Ошибка}	

160
   При отсутствии оператора goto все операторы программы выполняются в том по-
рядке, в котором они появляются в тексте программы. Следовательно, операторы goto
нарушают соответствие между текстом программы и порядком выполнения операторов,
что усложняет разработку, проверку и отладку программ. Таким образом, использование
оператора goto нежелательно.
   Например, программу Р71 можно переписать в следующем виде:

    Program P72;
     { Исключение оператора goto из программы P71 }
    var x, y : real;
    begin
     	write(’x=’);
     	readln(x);
     	if x>=0 then
     	 begin
     		 y:=x;
     		 writeln(’x>=0, y=’, y);
     	 end
     		 else
     	 begin
     		 y:=2*x;
     		 writeln(’x<0, y=’, y);
     	 end;
     readln;
    end.

   Как правило, оператор goto используется в исключительных случаях, например для
уменьшения размеров программы.



   В языке C++ оператор безусловного перехода имеет следующий синтаксис:
    <Оператор goto> ::= goto <Метка>;
   Напомним, что в языке C++ метка — это идентификатор, за которым следует символ
двоеточие, предшествующий оператору программы (рис. 3.13*).

            <Оператор goto>

                                             Метка             ;


           Рис. 3.13*. Синтаксические диаграммы <Оператор goto>, Язык C++

   Метка не может появляться более одного раза в теле одной и той же функции, область
видимости метки ограничена телом функции, в которой она появляется. Эти метки ис-
пользуются только оператором goto, в любом другом контексте помеченный оператор
выполняется без учета наличия метки.

                                                                                 161
   Для примера представим программу, которая вычисляет значение функции



   Значения аргумента x считываются с клавиатуры.
      // Программа P71
      #include <iostream>
      using namespace std;
      int main()
      {
        double x, y;
        cout<<″x=″; cin>>x;
        if (x>=0) goto A1;
        y=2*x;
        cout<<″x<0, y=″<<y;
        goto A2;
      A1: y=x;
          cout<<″x>=0, y=″<<y;
      A2:
      return 0;
      }
   Если пользователь вводит значение х ≥ 0, выполняется оператор goto A1 и контроль
передается оператору присваивания
      A1: y=x;
   После этого выполняются операторы
          cout<<”x>=0, y=”<<y;
      A2: return 0;
   Если пользователь вводит значение х < 0, выполнятся операторы
      y= 2*x;
      cout<<”x<0 , y=”<<y;
      goto A2;

   Последний оператор передает управление оператору
      A2: return 0;

   Очевидно, что любая метка должна быть префиксом только одного оператора.
   При отсутствии goto операторы программы выполняются в том порядке, в котором
они написаны. Следовательно, операторы goto нарушают соответствие между текстом
программы и порядком выполнения операторов. Это затрудняет разработку, проверку
и отладку программ. Следовательно, использование оператора goto не рекомендуется.

162
  Например, указанную выше программу можно переписать следующим образом:
    // Программа P72
    #include <iostream>
    using namespace std;
    int main()
    {
    double x, y;
    cout<<″x=″;
    cin>>x;
    if (x>=0)
       {
         y=x;
         cout<<″x>=0, y=″<<y;
       }
          else
       {
         y=2*x;
         cout<<″x<0, y=″<<y;
       }
    return 0;
    }
   Как правило, оператор goto используется в исключительных случаях, например,
для уменьшения размеров программы.
   В языке C++ оператор безусловного перехода имеет следующий синтаксис:


  Вопросы и упражнения
  	Для чего необходим оператор goto?
  	Укажите на синтаксических диаграммах рис. 3.13 (соответственно, рис. 3.13*)
    пути, которые соответствуют меткам и операторам goto из программ этого
    параграфа.
  	ПРИМЕНИТЕ! Перепишите следующие программы без использования
    оператора goto:
             ПАСКАЛЬ                                   C++
   Program P73;                          // Программа P73
    { Вывод приветствия на экран }       // Вывод приветствия на экран
   label 1, 2, 3;                        #include <iostream>
   var i : 6..23;                        using namespace std;
   begin                                 int main()
     write(’Который час?’); re-          {
   adln                                    unsigned short int i;
   (i);                                     cout<<″Который час? \n″;
     if i>12 then goto 1;                cin>>i;
     writeln(’Доброе утро!’);              if (i>12) goto Timp1;
     goto 3;                               cout<<″Доброе утро!″;
                                           goto Timp3;

                                                                           163
      1: if i>17 then goto 2;          Timp1: if (i>17) goto Timp2;
        writeln(’Добрый день!’);        cout<<″Добрый день!″;
        goto 3;                         goto Timp3;
      2: writeln(’Добрый вечер!’);     Timp2: cout<<″Добрый вечер!″;
      3: readln;                       Timp3: return 0;
      end.                             }

  	 ПРОАНАЛИЗИРУЙТЕ! Прокомментируйте следующую программу:
               ПАСКАЛЬ                               C++
      Program P74;                     // Программа P74
       { Ошибка }                      // Ошибка
      label 1;                         #include <iostream>
      var i : 1..5;                    using namespace std;
      begin                            int main()
        i:=1;                            {
      1: writeln(i);                     unsigned short int i;
        i:=i+1;                          i=1;
        goto 1;                        E1: cout<<i;
      end.                                 i+=1;
                                           goto E1;
                                         return 0;
                                       }
  	 ПРОАНАЛИЗИРУЙТЕ! Что выведет на экран следующая программа?

               ПАСКАЛЬ                               C++
      Program P75;                     // Программа P75
       { Ошибка }                      // Ошибка
      label 1;                         #include <iostream>
      var x : real;                    using namespace std;
      begin                            int main()
        x:=0;                            {
      1: writeln(x);                     double i;
        x:=x+1e–30;                      x=0;
        goto 1;                        E1: cout<<x;
      end.                                 x=x+1e-30;
                                           goto E1;
                                       return 0;
                                       }
  	    Напомним, что в ПАСКАЛЕ работу программы можно прервать нажатием
       клавиш <CTRL+C> или <CTRL+BREAK>, а в C++, просто закрыв окно Run.
   	ПРОАНАЛИЗИРУЙТЕ! Прокомментируйте следующую программу:

               ПАСКАЛЬ                               C++
      Program P76;                     // Программа P76
       { Ошибка }                      // Ошибка
      label 1;                         #include <iostream>
      var i : integer;                 using namespace std;
      begin                            int main()
        i:=1;                          {

164
     while i<=20 do                     int i;
        begin                           i=1;
          writeln(i);                      while (i<=20)
          1: i:=i+1;                        {
        end;                                   cout<<i<<endl;
     goto 1;                              A1:   i+=1;
   end.                                     }
                                           goto A1;
                                           return 0;
                                        }

  	 ИЗУЧИТЕ! Работу над заданием можно организовать индивидуально или
     в группах, разделив на отдельные подзадания.
  	 В языке C ++ есть и другие операторы, которые позволяют делать переходы,
     например: break, continue и return. Проанализируйте, как работает
     каждый из них. Измените программу из задания 3 таким образом, чтобы
     не использовать оператор goto.


  3.18. Структура программы ПАСКАЛЬ / C++

  Программа на языке ПАСКАЛЬ имеет следующую структуру:
    <Программа> ::= <Заголовок программы>
	                 <Тело>.
  Заголовок программы содержит имя программы и, если необходимо, список фор-
мальных параметров:
  <Заголовок программы> ::= Program <Идентификатор> [(<Идентификатор> {,
<Идентификатор>})];
  Примеры:
    1)	Program A1;
    2)	Program B6(Intrare);
    3)	Program C15(Intrare, Iesire);
   Обычно формальные параметры используются для связи программы со средой
ввода/вывода.
   Тело программы состоит из раздела объявлений и выполняемой части:
 <Тело> ::= <Объявления>
		<Составной оператор>
  Синтаксис раздела объявлений::
<Объявления> ::= 	 [<Метки>]
		[<Константы>]
		[<Типы>]
		[<Переменные>]
		[<Подпрограммы>]

                                                                        165
   Выполняемая часть представляет собой составной оператор begin...end.
   Синтаксические диаграммы соответствующих грамматических единиц представлены
на рис. 3.14.


            <Программа>
                 Заголовок программы              Тело

            <Заголовок программы>
                                  Идентификатор




                              Идентификатор




            <Тело>
                     Объявления        Составной оператор

            <Объявления>
                                       Метки

                                    Константы

                                       Типы

                                    Переменные

                                   Подпрограммы


                 Рис. 3.14. Структура программы на языке ПАСКАЛЬ

   Отметим, что конец программы обозначается символом “.” (точка).
   В заключение в качестве примера представляем программу Р77, которая вычисляет
длину дуги окружности, на которую опирается центральный угол в α градусов, и пло-
щадь соответствующего сектора.

      Program P77;
       { Длина дуги окружности и площадь соответствующего сектора }
      label 1, 2;
      const Pi=3.141592654;

166
    type grade=0..360;
    var alfa : grade;
        raza, lungimea, aria : real;
    begin
      write(’радиус=’); readln(raza);
      if raza<0 then goto 1;
      write(’alfa=’); readln(alfa);
      lungimea:=Pi*raza*alfa/180;
      writeln(’длина=’, lungimea);
      aria:=Pi*sqr(raza)*alfa/360;
      writeln(’площадь=’, aria);
      goto 2;
    1: writeln(’Ошибка: радиус<0’);
    2: readln;
    end.




   Программа на C ++ состоит из следующих компонентов:
   – директивы;
   – глобальные объявления, которые описывают типы пользователей, объявляют типы
данных, переменные, глобальные константы, используемые в программе;
   – пользовательские функции;
   – основная функция main.
   Отметим, что программа, написанная на языке C++, представляет собой набор
функций, каждая из которых выполняет четко определенное действие. Функция main
– это основная функция. Именно с нее начинается выполнение любой программы на
C++ и ее наличие обязательно. Все остальные функции являются необязательными, и
их имена задает программист.
   Форма основной функции main:
    int main ()      // Заголовок функции
    {                // Начало тела функции
        Локальные объявления;;
        Операторы;;
        return 0;
    }               // Конец тела функции, завершение программы.
   Оператор return используется для завершения выполнения функции и возврата
значения указанного в ней выражения.
   Напомним, что на языке C++ программы пишутся строчными буквами.
   Для примера ниже представляем программу, которая вычисляет длину дуги окруж-
ности, на которую опирается центральный угол в α градусов и площадь соответству-
ющего сектора.

                                                                            167
         // Программа P77
         #include <iostream>
         #include <cmath>
         using namespace std;
         /* Программа P76 на языке C++ */
         /* Длина дуги окружности и площадь соответствующего
	            сектора */
         int main()
         {
           const double Pi=3.141592654;
           unsigned int alfa;
           double raza, lungimea, aria;
           cout<<»радиус=»; cin>>raza;
           if (raza<0) goto R1;
           cout<<»alfa=»; cin>>alfa;
           lungimea=Pi*raza*alfa/180;
           cout<<»длина=»<<lungimea<<endl;
           aria=Pi*pow(raza,2)*alfa/360;
           cout<<»площадь=»<<aria<<endl;
           goto R2;
         R1: cout<<»Ошибка: радиус<0»;
         R2: return 0;
         }

     Вопросы и упражнения
     	(ПАСКАЛЬ) Для чего необходим заголовок программы? Как обозначается
       конец программы?
     	 (C++) Каково назначение заголовка функции? Как обозначается конец
       функции?
     	Укажите на синтаксических диаграммах рис. 3.14 пути, которые соответ-
       ствуют грамматическим единицам из программ данного параграфа.
     	ПРИМЕНИТЕ! Перепишите программу Р77 без использования оператора
       goto. Укажите составные части созданной программы.
     	(C++) Укажите директивы, основную функцию, начало и конец тела основной
       функции, локальные объявления и константы программы P77.


     Тест для самопроверки № 3
  1. Запишите в соответствии с правилами языка программирования ПАСКАЛЬ/
C++ следующие выражения:
    a)   (a + b) – 2ab;                d)   2αβ – 5πr;
                                            πr2 + αβ2;
           2                2
    b)   6a + 15ab –13b ;              e)
    c)   (a + b) (a – b);              f)   xy ∨ xz.

168
   2. Запишите в обычном виде выражения, представленные в соответствии с
правилами языка программирования ПАСКАЛЬ/C++ :
            ПАСКАЛЬ                                  C++
 1)    sqr(a)+2/sqr(b)             1)   pow(a,2)+2/pow(b,2)
 2)    2*a/(b+c)                   2)   2*a/(b+c)
 3)    15*sqrt(a/(a–b))            3)   15*sqrt(a/(a–b))
 4)    not(x and y) or z           4)   !(x && y) || z
 5)    sqr((a+b)/2)                5)   pow((a+b)/2,2)
 6)    (x<>0) and (q<p)            6)   (x!=0) && (q<p)

  3. Какие из нижеследующих выражений на языке, который вы изучаете,
ошибочны?
            ПАСКАЛЬ                                  C++
 1)    2*a+2*b                     1)   2*a+2*b
 2)    4*sinx+4*cosy               2)   4*sinx+4*cosy
 3)    3*sqr(x)+3/sin(y)           3)   3*pow(x,2)+3/sin(y)
 4)    a+2*–b                      4)   a+2*–b
 5)    not (q and p)               5)   ! (q && p)
 6)    2*(+x)+((-y))               6)   2*(+x)+((-y))

  4. Пусть x=1, y=2 и z=3. Вычислите значения нижеследующих выражений:
            ПАСКАЛЬ                                  C++
 1)    x+2*y+3*z                   1)   x+2*y+3*z
 2)    (1+x+y-2)*z                 2)   (1+x+y-2)*z
 3)    x*y+y*(-z)                  3)   x*y+y*(-z)
 4)    not(x+y+z>0)                4)   !(x+y+z>0)
 5)    x*y<y+z                     5)   x*y<y+z
 6)    (x>y)or(2*x<y+z)            6)   (x>y)||(2*x<y+z)

  5. Пусть заданы объявления переменных:
                 ПАСКАЛЬ                              C++
      var x : real;                     double x;
            i : integer;                int i;
            p : boolean;                bool p;
            s : char;                   char s;
            Zi : (Luni, Marti,          enum {Luni, Marti, Miercuri,
      Miercuri, Joi, Vineri,            Joi, Vineri, Sambata, Duminica}
      Sambata, Duminica);               Zi;

                                                                         169
Определите тип каждого из следующих выражений:

             ПАСКАЛЬ                                  C++
 a)    i mod 9                       a)   i % 9
 b)    i/9                           b)   i/9
 c)    i+x                           c)   i+x
 d)    ord(pred(Zi))                 d)   Zi+1
 e)    ord(Zi)+trunc(x)              e)   Zi+trunc(x)
 f)    sqr(ord(s))                   f)   pow(s,2)
 g)    p or (x>i)                    g)   p ||(x>i)
 h)    chr(i+ord(p))                 h)   char(i+p)

  6. Напишите программу, которая выводит на экран значение выражения
15i(x+y) . Значения целой переменной i и вещественных переменных x, y
считываются с клавиатуры.

  7. Даны следующие объявления:
                 ПАСКАЛЬ                                C++
      type FunctiaOcupata = (Mun-         enum FunctiaOcupata {Muncitor,
      citor, SefDeEchipa, Maistru,        SefDeEchipa, Maistru,
      SefDeSantier, Director);            SefDeSantier, Director};
           StareaCivila = (Casato-        enum StareaCivila {Casatorit,
      rit, Necasatorit);                  Necasatorit};
      var i : integer;                    int i;
          x : real;                       double x;
          f : FunctiaOcupata;             FunctiaOcupata f;
          s : StareaCivila;               StareaCivila s;

      Какие из нижеприведенных операторов являются правильными?

             ПАСКАЛЬ                                  C++
 1)    i:=ord(f)+15                  1)   i=f+15
 2)    f:=Casatorit                  2)   f=Casatorit
 3)    x:=ord(f)+1                   3)   x=f+1
 4)    i:=2*x-15                     4)   i=2*x-15
 5)    s:=pred(s)                    5)   s=s-1
 6)    f:=succ(SefDeEchipa)          6)   f=SefDeEchipa+1

170
  8. Напишите программу, которая вычисляет значение функции:




  Значение вещественной переменной x считывается с клавиатуры.

   9. Используемые в Республике Молдова монеты имеют значения 1, 5, 10, 25
или 50 бань. Напишите программу на языке ПАСКАЛЬ/C++, которая считывает
с клавиатуры числовое значение монеты и выводит на экран это же значение,
выраженное словами. Например, если пользователь вводит „25”, то на экран
выводится „двадцать пять бань”. Если же пользователь вводит отличное от 1, 5, 10,
25 или 50 значение, то на экран выводится сообщение „недопустимое значение”.

  10. Напишите программу, которая, используя оператор for, вычисляет для первых
n элементов сумму


и произведение



  11. Напишите программу, которая, используя оператор while, вычисляет и
выводит на экран значения функции




для значений аргумента х от x1 до x2 с шагом ∆x.

  12. Специальные сообщения мобильной телефонной связи определяются с
помощью следующих металингвистических формул:
  <Цифра> ::= 0123456789
  <Специальное сообщение> ::= *{<Цифра>}#
   Напишите на языке ПАСКАЛЬ/ C++ программу, которая, используя оператор
повторения с постусловием, вычисляет и выводит на экран количество цифр,
содержащихся в специальном сообщении. Например, если пользователь вводит:
  *104#<ENTER>
на экран должно выводиться число 3.




                                                                             171
Глава 4

                                     МОДУЛИ ПО ВЫБОРУ

   Модули из этой главы не являются обязательными. Что это значит? Вы можете
выбрать один из модулей и изучить его в удобном для вас темпе, самостоятельно или
с одноклассниками, на основе практики и разработки проектов, с помощью компью-
терного обучения. Выбрав модуль, вы, совместно с учителем информатики, решите,
какие прикладные программы будут использоваться, убедитесь, что эти программы
лицензированы или свободно распространяются, что они установлены на компьютерах
в компьютерных классах и/или на личных устройствах, в зависимости от обстоятельств.




   4.1.Веб-дизайн
   В широком смысле Веб-дизайн означает разработку веб-сайтов, начиная с их структу-
ры и заканчивая содержанием и формой, в которой они будут предлагаться пользователю.
Первым веб-дизайнером был Тим Бернерс-Ли (Tim Berners-Lee), изобретатель одного из
самых распространенных интернет-сервисов WWW (World Wide Web – Всемирная пау-
тина). Эта «паутина» состоит из множества связанных друг с другом сайтов, документов
и информации, к которым можно получить доступ через глобальную сеть Интернет.
   В области веб-дизайна используются следующие термины:
   Веб-страница – файл, содержащий простой неформатированный текст, отображение
компонентов которого указывается с помощью языка разметки, называемого HTML
(Hyper Text Markup Language). Помимо информации о фактическом стиле отображения
текста (символы, абзацы, списки, таблицы и т. д.) язык HTML позволяет создавать эле-
менты управления (кнопки, текстовые поля, раскрывающиеся списки, счетчики и т. д.) и
ссылки (link-и). Ссылки могут указывать как на объекты внутри веб-страницы, так и на
различные внешние объекты. Внешние объекты, такие как изображения, аудиоклипы,
видеоклипы и даже другие веб-страницы, могут храниться как на локальном компьютере,
так и на любом другом компьютере, подключенном к Интернету.
   Веб-документ – набор взаимосвязанных веб-страниц вместе с их внешними объек-
тами, хранящимися на локальном компьютере.
   Веб-сайт – Веб-документ, опубликованный в Интернете.
   Процесс изучения веб-дизайна будет осуществляться в соответствии с этапами
разработки веб-документов:
   1. Выбор приложений для разработки веб-документов. Эти приложения могут
быть общего или специального назначения.

172
   В случае приложений общего назначения наиболее часто используются офисные
приложения, изучаемые в гимназических классах: текстовые редакторы, редакторы элек-
тронных таблиц, приложения для электронных презентаций. Эти приложения позволяют
сохранять документы в веб-форматах: HTML (текстовый формат, предназначенный
для представления веб-страниц) и MHT (формат для архивированных веб-докумен-
тов). Подчеркнем, что приложения общего назначения полезны только на начальных
этапах изучения веб-дизайна, так как не дают больших возможностей использовать все
инструменты для персонализации веб-страниц, вставки мультимедийных элементов,
обеспечения интерактивности, выбора информации, предоставляемой пользователю в
соответствии с его профилем.
   В случае специализированных приложений, изучение которых требует больше вре-
мени и усилий, ученики смогут детально спроектировать структуру веб-документа и
работать на уровне каждого его компонента. Им предоставится возможность развивать
свой творческий потенциал, сосредоточив деятельность на художественных аспектах
создаваемых ими цифровых продуктов.
   Отметим, что крупные компании, предоставляющие Интернет-услуги, предлагают
пользователям онлайн-приложения для разработки веб-документов, которые сопрово-
ждаются системами поддержки и электронными руководствами, предназначенными для
самостоятельного изучения процессов разработки веб-документов.
   2. Определение целевой группы. В подавляющем большинстве случаев веб-доку-
менты размещаются в Интернете и к ним могут получить доступ многие пользователи.
Пользователи могут иметь самые разные профили: возрастная категория (дети, под-
ростки, молодежь, взрослые), уровень образования (начальное, среднее, лицейское, про-
фессионально-техническое, высшее), профессиональный статус (школьники, студенты,
сотрудники, безработные, пенсионеры), профессиональная сфера (сельское хозяйство,
промышленность, торговля, образование, здравоохранение, правоохранительные орга-
ны, юстиция, искусство, государственное управление и др.), предпочитаемые языки и т. д.
   Очевидно, что влияние веб-документа тем сильнее, чем больше его содержание и
стиль представления соответствуют профилю целевой группы, для которой он разра-
ботан. Таким образом, веб-дизайнер должен точно определить характеристики целевой
группы, для которой предназначен разрабатываемый документ.
   Например, документ, предназначенный для младших школьников, будет содержать
меньше текста и больше изображений, шрифт текста будет достаточно крупным, чтобы
не создавать визуального дискомфорта, структура документа будет максимально про-
стой, без ненужных многоуровневых ссылок. Предлагаемое детям содержание будет
соответствовать их возрастным особенностям, оно будет адаптировано к их способу
восприятия и познания мира через элементы наблюдения и игры.
   Документ для старшеклассников будет иметь более строгую структуру, без отвле-
кающей графики, с логической системой навигации, без образующих замкнутые круги
ссылок.
   3. Определение цели веб-документа. Веб-документы могут преследовать различные
цели: информация, продвижение, художественное выражение, социализация, предо-
ставление определенных услуг, развлечения, отдых и др.
   Исходя из намеченной цели, веб-дизайнер будет выбирать содержание и стили его
представления, избегая предоставления нерелевантной по отношению к намеченной

                                                                                   173
цели информации и загромождения документа ненужными стилями, которые иллю-
стрируют лишь индивидуальную способность автора обращаться с определенными
цифровыми инструментами.
   Например, в случае веб-документа о продвижении волонтерства основное внима-
ние будет уделяться содержанию, которое подчеркивает роль волонтерства в жизни
сообщества, мотивацию участвовать в такой деятельности, влияние волонтерства на
благополучие сообщества в целом или отдельных категорий граждан в частности. Содер-
жимое веб-документа (текстовое, графическое, звуковое и видео) будет мобилизующим,
корректным по отношению к персональной информации отдельных бенефициаров,
будет содержать примеры передовой практики, предложит пользователям возможные
области расширения волонтерской деятельности.
   В случае веб-документа, продвигающего гендерное равенство, упор будет делаться на
успешные примеры, на передовой опыт. Следует избегать загромождения содержания
длинными цитатами из юридических документов, предназначенных только для специ-
алистов в области права. Следует избегать также морализаторского тона. Достижения
и недостатки, которые все еще сохраняются в этой области, будут рассматриваться на
равной основе с точки зрения обоих полов. Содержание будет больше ориентировано
на преодоление стереотипов, на осознание благотворного влияния гендерного равенства
на развитие человечества.
    4. Разработка структуры веб-документа. Традиционно в повседневной деятель-
ности, которая день ото дня все больше оцифровывается, значение термина документ
считается очень близким к значению термина файл.
    В случае веб-документов такая ассоциация может быть неверной, поскольку веб-до-
кумент обычно содержит несколько файлов. Основной файл, в формате HTML, читается
и отображается программой навигации (browser – браузером), который, следуя содер-
жащимся в нем ссылкам, отображает/запускает другие файлы. Обычно это файлы в
текстовом, графическом, аудио- и видеоформатах. Очевидно, что ссылки в основном
файле могут вести к другим файлам HTML, создавая таким образом многоуровневую
структуру.
    Следовательно, структуры веб-документа могут быть следующие.
    Структура веб-страницы, отображаемая на экране браузером. Эта структура состо-
ит из текстов, изображений и элементов управления: навигации, ввода информации,
воспроизведения аудио- и видеопоследовательностей и т. д.
    При разработке структуры веб-страницы, отображаемой на экране, дизайнер учтет
специфику целевой группы, цель документа, а также особенности оборудования, с помо-
щью которого будут открываться соответствующие страницы: стационарное, мобильное,
большой или маленький экран, с помощью клавиатуры, мыши или сенсорных экранов,
разрешение экрана, пропускную способность интернет-канала и т. д.
    Структура веб-документа, состоящая из главной страницы, подчиненных страниц
и внешних объектов. Главная страница находится на верхнем уровне иерархии (уровень
0), а подчиненные страницы - на уровнях 1, 2, 3 и так далее. Практически уровень под-
чиненной страницы определяется количеством кликов, необходимых для перехода на
нее, начиная с главной страницы.
    При разработке веб-документов рекомендуется следовать «золотому правилу Ин-
тернета»: к любой подчиненной странице можно получить доступ не более чем за три
щелчка мышью.

174
   Обычно, чтобы упростить процесс проектирования, структура веб-документа пред-
ставляется с помощью рисунка, состоящего из небольших прямоугольников, представ-
ляющих веб-страницы, и линий, иллюстрирующих переход от одной страницы к другой.
Рекомендуется, чтобы рассматриваемый рисунок не содержал «замкнутых кругов», т.е.
чтобы его можно было ассоциировать с деревом, ветви которого растут вниз. В «корне»
дерева находится главная страница (уровень 0), а подчиненные страницы символизи-
руются его «листьями».
   Структура файловой системы веб-документов. Как и любая другая файловая
структура, она состоит из каталогов, содержащих локальные внешние объекты, такие
как текст, графика, аудио, видео и, конечно же, файлы HTML. Обычно в случае при-
ложений общего назначения эта структура создается автоматически при сохранении
веб-документа и состоит из единственного каталога, имя которого происходит от имени
HTML-страницы. В случае специализированных приложений соответствующая струк-
тура представляет собой древовидную структуру, причем соответствующие каталоги
создаются автоматически или веб-дизайнером. В большинстве случаев веб-дизайнеры
предпочитают, чтобы один из этих каталогов содержал графические файлы, другой –
аудиофайлы, третий – видеофайлы и так далее.
   5. Создание веб-страниц. Этот шаг включает в себя создание каждой из веб-страниц,
составляющих веб-документ, и состоит из вставки и форматирования составляющих их
объектов. В некоторой степени этот процесс похож на процесс создания традиционных
документов:
   – установление иерархической структуры веб-страницы;
   – вставка текстов, списков, таблиц и их форматирование;
   – вставка и форматирование диаграмм, изображений, формул, аудиофрагментов,
     видеофрагментов, элементов навигации и управления;
   – вставка ссылок на внешние объекты;
   – макет страницы.
   Подчеркнем, что объекты, которые будут вставлены на веб-страницы, могут быть
взяты из других источников или созданы авторами веб-документа с помощью специа-
лизированных приложений, например, с помощью программ для создания и обработки
растровых и векторных изображений, цифровой обработки аудио и видео. Очевидно,
что в таких случаях работа по созданию веб-документов может быть организована
в командах, причем каждый член команды специализируется на определенном типе
объектов.
   6. Тестирование веб-документа. Для начала веб-документ будет протестирован
локально с помощью программы навигации (браузера). В процессе тестирования про-
веряется доступность всех объектов в веб-документах, правильность ссылок, работа
инструментов навигации, правильность отображения изображений, точность воспро-
изведения аудио и видео.
   В случае возникновения ошибок необходимо вернуться к этапу создания веб-страниц
и объектов, из которых они состоят.
   Подчеркнем, что для тестирования в специализированных приложениях для раз-
работки веб-документов есть специальные средства, которые упрощают проверку
документов на стадии доработки.

                                                                                175
   7. Проверка соблюдения авторских прав. Как правило, в веб-документ можно
вставлять объекты, созданные другими авторами. В таких случаях особое внимание
необходимо уделить соблюдению авторских прав. Перед вставкой объекта, загружен-
ного из Интернет-источника, печатной или мультимедийной публикации, например,
книги с аудио- или видеокомпакт-диска и т. д., веб-дизайнеры проверяют, защищен ли
объект авторским правом, и если да, то какой лицензией он защищен (проприетарная
или бесплатная). В зависимости от типа лицензии веб-дизайнеры уточнят требования
для использования этих объектов в своих веб-документах, и если они решат их исполь-
зовать, то должны обязательно указать источники.
   8. Проверка соблюдения требований относительно защиты персональных данных
и безопасности в Интернете. Поскольку подавляющее большинство веб-документов
предназначено для публикации в Интернете, они не должны включать персональные
данные, будь то личные, одноклассников или учителей. Очевидно, что веб-документ
не должен включать средства запроса и сбора персональных данных от пользователей,
которые будут иметь доступ к этому документу.
   Веб-документ не должен содержать объекты, в которых могут быть вредоносные
программы (вирусы) или ссылки на другие веб-сайты, содержащие такие программы.
   Как правило, следует избегать ссылок на сайты, на которых явно не указаны выходные
данные: владелец сайта, авторы материалов на сайте, дата последнего обновления этих
материалов, адреса и номера телефонов компаний, управляющих сайтом.
   9. Публикация веб-документа в Интернете. Существует несколько способов публи-
кации веб-документов, основные из которых:
   – на личном сайте;
   – на сайте учебного заведения;
   – на сайте общественной организации.
   В зависимости от статуса сервера, на котором был размещен веб-документ, формули-
руются требования к содержанию и дизайну его веб-страниц, моральная и материальная
ответственность авторов, обладателей и владельцев сайта.
   В случае личных вебсайтов вся ответственность ложится на их обладателей и вла-
дельцев. Очевидно, что в случае учащихся, которые еще не достигли совершеннолетия,
создание личных веб-сайтов требует согласия их родителей/законных представителей.
   В случае веб-сайтов образовательных учреждений и общественных объединений
ответственность несут соответствующие организации и авторы веб-документов. Оче-
видно, что в случае образовательных учреждений соответствующие документы должны
отвечать миссии и целям образовательной системы, а в случае общественных органи-
заций – их миссии, целям, задачам и сферам деятельности.
   10. Поддержка и развитие веб-документа. В зависимости от цели веб-документы
могут размещаться в Интернете в течение относительно короткого или более длитель-
ного периода времени.
   Для коротких сообщений веб-документы не нужно обновлять, их следует удалить из
виртуального пространства и заархивировать по истечении ожидаемого времени. Такой
подход позволяет избежать явлений «информационных помех», «информационной
инфляции» и «информационного насыщения».

176
   Для длительных сообщений веб-документы необходимо обновлять. Эти обновления
могут производиться как по запросу пользователей, так и по собственной инициативе
их авторов. Элементом хорошего тона считается включение в веб-документы некоторых
автоматизированных средств, которые позволили бы пользователям сигнализировать о
возможной ошибке в содержании или структуре соответствующих документов.
   Если веб-документ был разработан и опубликован в онлайн-сервисе, обновления
производятся в реальном времени, заменяя и / или изменяя желаемые объекты. Если
веб-документ был создан на локальном компьютере, а затем размещен в Интернете,
очевидно, что обновление также выполняется на локальном компьютере с последующей
публикацией обновленной версии в том же месте в виртуальном пространстве.
   Как уже упоминалось выше, рекомендуется четко указывать дату последнего обновле-
ния на каждой из веб-страниц, что поможет пользователю оценить новизну полученной
информации.



   Рекомендуемая учебная деятельность и продукты
   Упражнения:
   –	 идентификация объектов в составе веб-страницы;
   –	 идентификация объектов в составе веб-документа;
   –	 представление структуры веб-страницы;
   –	 представление структуры веб-документов в виде рисунка;
   –	 разработка структуры веб-страницы;
   –	 разработка структуры веб-документа;
   –	 разработка файловой структуры веб-документа;
   –	 разграничение этапов разработки веб-документа и разъяснение содержания
      каждого этапа;
   –	 создание веб-документов с использованием офисных приложений;
   –	 создание веб-документов с использованием специализированных приложений;
   –	 создание веб-документов с помощью онлайн-приложений;
   –	 проверка соблюдения авторских прав (сайты, предложенные преподавателем, и
      веб-документы, разработанные в классе);
   –	 проверка соблюдения правил интернет-безопасности и защиты персональных
      данных (сайты, предложенные преподавателем, и веб-документы, разработанные
      в классе);
   – публикация веб-документов в локальной сети и в Интернете.

   Исследования:
   –	 Сообщения, отправляемые сайтами, часто посещаемыми учениками.
   –	 Цели сайтов, часто посещаемых учениками.
   –	 Структура, графический вид, функциональность и удобство использования сай-
      тов, предложенных преподавателем и часто посещаемых учениками.
   –	 Взаимосвязь между целями и дизайном сайтов, часто посещаемых учениками.

                                                                               177
  –	 Взаимосвязь между спецификой целевых групп и дизайном сайтов, часто посе-
     щаемых учениками.
  –	 Актуальность, оригинальность, значимость, объективность, справедливость и
     правильность информации на сайтах, часто посещаемых учениками.

   Разработка веб-сайтов:
   –	 Мой дом / Моя школа / Мой город / Родное село.
   –	 Мой класс / Мой школьный кружок / Моя спортивная секция.
   –	 Ученический совет / Молодежный совет.
   –	 Волонтерство в моей школе, в моем селе / городе.
   –	 Книжный магазин / Библиотека / Дом культуры / Музыкальный салон.
   –	 Музей села / Городской музей.
   –	 История моего села / города.
   –	 Замечательные люди из моего села / города.
   –	 Искусство в моей жизни (в сферах: музыка, пластика, декоративное искусство).
   –	 Спорт в моей жизни.
   –	 Здорово быть здоровым.
   –	 Тренажерные залы / фитнес-залы.
   –	 Салоны красоты / Модные салоны.
   –	 Швейные / Ремонтные мастерские (автомобили, компьютеры, бытовая техника,
      аудио, видео).
   –	 Крестьянское хозяйство.
   –	 Магазины (детские товары, школьные товары, хозяйственные товары, одежда).
   Проекты, охватывающие обширные темы, например касающиеся города, села,
школы, будут разрабатываться в командах учащихся, причем каждый член команды
специализируется на определенном аспекте, например историческом, демографическом,
экономическом, культурном, этнографическом и др.
   Также в командах будут разрабатываться проекты, которые характеризуются бога-
тым мультимедийным контентом, специализация членов команды осуществляется по
жанрам соответствующих материалов, например растровая графика, векторная графика,
анимация, фото, аудио, видео и т. д.



  4.2. Компьютерная графика
   Компьютерная графика, часто называемая цифровой графикой, – это область ком-
пьютерных наук, которая занимается теоретическими основами и прикладными аспек-
тами, связанными с обработкой изображений с помощью компьютеров. Теоретические
и практические знания в этой очень важной области информатики, которая имеет
тесную связь с изобразительным искусством, используются для синтеза, модификации,
хранения и управления изображениями, а также для обработки визуальной инфор-
мации, полученной из окружающей действительности. Знание основных элементов

178
компьютерной графики необходимо инженерам, ученым, художникам-оформителям,
дизайнерам, фотографам, аниматорам и др. Также для многих компьютерная графика
стала приятным занятием вне профессиональной деятельности (хобби).
   В зависимости от того, как изображения представлены в памяти компьютера, раз-
личаем точечно-ориентированную графику и объектно-ориентированную графику.

  Точечно-ориентированная графика
   Напомним, что в точечно-ориентированной графике изображения представлены
в памяти компьютера путем разделения их на микрозоны, называемые точками или
пикселями. Разложение изображения на пиксели производится с помощью растра (от
латинского слова raster, буквально «грабли»).
   Растр представляет собой плоскую, обычно прямоугольную поверхность, на которой
нанесены два набора параллельных линий, перпендикулярных друг другу. Плотность
линий и плотность пикселей соответственно характеризуют разрешающую способность
оборудования для воспроизведения или создания изображений.
   В процессе оцифровки изображения обход пикселей происходит в том порядке, в
котором они читаются: слева направо, сверху вниз. Каждому пикселю соответствует
двоичное число, которое в компьютерной форме представляет информацию о его яр-
кости и цвете.
   Другими словами, в цифровой форме, в точечно-ориентированной графике, изо-
бражение представлено последовательностью двоичных чисел, и вся его обработка
выполняется операциями с этими числами.
   Последовательности двоичных чисел, содержащие информацию о яркости и цвете
пикселей, называются растровыми цифровыми изображениями или, проще, растровыми
изображениями.
   Чаще всего растровые изображения используются для обработки визуальной ин-
формации, полученной из окружающей среды. Обычно большая часть оборудования
для оцифровки изображений, такого как фотоаппараты, видеокамеры, сканеры и т. д.,
обеспечивает вывод растровых изображений, точнее файлов в форматах, специально
разработанных для представления, хранения и обработки растровых изображений.
Растровые изображения также используются для отображения визуальной информации
на экранах цифровых устройств и для их печати.
   Основное преимущество растровых изображений – их достоверность, то есть акку-
ратность и точность представления или воспроизведения реальности. Из недостатков
отметим большой объем памяти, необходимый для хранения растровых изображений,
и ухудшение качества при их увеличении.

  Объектно-ориентированная графика
   Чтобы обеспечить лучшее качество цифровых изображений при изменении их раз-
мера и уменьшение объема памяти, необходимой для их хранения, в объектно-ориен-
тированной графике изображения состоят из простых графических объектов: линий,
квадратов, прямоугольников, кругов, эллипсов и т. д.
   В компьютере каждый графический объект в изображении кодируется набором дво-
ичных чисел обычно называемых вектором. Такой набор двоичных чисел содержит всю

                                                                             179
информацию, необходимую для рисования объекта: координаты центра и радиуса каж-
дого круга, координаты вершин каждого прямоугольника и т. д. Очевидно, что вектор,
который характеризует графический объект, также включает информацию о цвете и
толщине линий, которые его образуют, цвете заливки, цветовых градиентах и т.д.
    Обработка векторных изображений производится путем пересчета координат и
размеров каждого графического объекта, содержащегося в изображении, по формулам
из аналитической геометрии. Важно знать, что в аналитической геометрии, в отличие
от традиционной геометрии, фигуры определяются не изображениями, а с помощью
формул, и их преобразование чисто алгебраическое. Для этого плоскость, в случае
двухмерных изображений, и пространство, в случае трехмерных изображений, снаб-
жены системами координат, обычно декартовыми.
    Векторные изображения можно увеличивать и уменьшать без ухудшения их качества,
пересчитывая их размеры в соответствии с математическими формулами, связанными с
каждым графическим объектом. Более того, с помощью расчетов графические объекты
можно анимировать, перемещать в пространстве, перекрашивать, трансформировать
и т.д., что особенно важно при создании цифровых симуляторов и компьютерных игр.
Очевидно, что в случае приложений цифровой графики компоненты аналитической
геометрии, на которых основана обработка векторных изображений, то есть формулы
и вычислительные алгоритмы, «невидимы» для пользователя, он оперирует только
терминами, характерными для графического дизайна.
    Недостатком векторных изображений является то, что кодирование сложной визу-
альной информации простыми графическими объектами, описываемыми с помощью
математических формул, приводит к снижению достоверности представления или
воспроизведения реального мира. Очевидно, что снижение точности вызвано не са-
мими математическими формулами, а сложностью и большим количеством объектов,
которые могут потребоваться для обеспечения желаемого уровня точности. Однако с
увеличением производительности современных компьютеров сложность и количество
графических объектов перестают быть непреодолимым препятствием, что можно лег-
ко наблюдать в случае компьютерных игр, изображения в которых становятся более
сложными и близкими к таким, какими мы видим их в реальном мире.

   Преобразование изображений
   Растровые изображения можно преобразовывать в векторные изображения и
наоборот, векторные изображения – в растровые. Более того, современные приложения
для обработки изображений позволяют создавать и обрабатывать смешанные цифровые
изображения, т. е. изображения, содержащие как растровые, так и векторные компоненты.
   Обычно преобразование растровых изображений в векторные изображения про-
изводится для того, чтобы уменьшить занимаемый ими объем, объединить реальный
мир с элементами виртуального мира (дополненная реальность), распознавать формы.
Преобразование векторных изображений в растровые производится с целью их ото-
бражения на экранах цифровой техники и для печати.

   Обработка растровых изображений
   Для формирования и развития навыков обработки растровых изображений реко-
мендуется прохождение следующих тем.

180
   1. Повторение понятий из гимназических классов: пиксель, растр, растровое изобра-
жение, разрешение, размеры, цветовая модель.
   2. Рабочее пространство графического редактора: панели, меню, инструменты, ли-
нейки, мобильные линейки, направляющие, настройка рабочего пространства.
   3. Инструменты рисования: перо, кисть, фон, графические фигуры / примитивы.
   4. Управление свойствами инструмента рисования.
   5. Инструменты для выделения и редактирования: селектор, маски, ножницы, пи-
петка, ластик, нож.
   6. Инструменты для обработки текста: написание, редактирование, форматирование.
   7. Базовая обработка растровых изображений:
   –	 рисование / перерисовка изображений стандартными инструментами;
   –	 импорт изображений из внешних источников (камеры, сканеры);
   –	 вставка и форматирование текстов;
   –	 добавление контента;
   –	 регулировка уровней прозрачности и затенения;
   –	 применение художественных эффектов (мозаика, мокрое стекло, кристаллизация,
       текстура, размытие).
   8. Работа с графическими объектами: создание, редактирование, клонирование,
сортировка, группировка / разгруппировка / перегруппировка.
   9. Работа со слоями: добавление / редактирование; выделение, группировка и при-
вязка; перемещение, наложение и блокировка.
   10. Расширенная обработка текста: масштабирование, поворот, применение геоме-
трических эффектов, применение художественных эффектов.
   11. Применение спецэффектов: трехмерная геометрия, размытие, фильтрация, кон-
турная декомпозиция, текстура, четкость.
   12. Хранение и распространение изображений: архивирование, подготовка к печати,
организация в локальных альбомах и / или в Интернете.

   Обработка векторных изображений
   Навыки, необходимые для обработки векторных изображений, можно сформировать
и развить, изучив следующие темы.
   1. Основы объектно-ориентированной графики: точка / узел, прямые линии, кривые
Безье (Bezier), разрешение, размеры, цветовые модели.
   2. Рабочее пространство редактора векторной графики и его настройка.
   3. Инструменты рисования: трассировки линий, преобразователь линий, четыреху-
гольники, многоугольники, графические примитивы, построитель сетки.
   4. Управление свойствами инструмента рисования.
   5. Инструменты для выбора и редактирования: селектор объекта / узла, ножницы,
пипетка, нож.
   6. Обработка текста.
   7. Создание и редактирование объектов.
   8. Растеризация векторных изображений.
   Предлагаемые для изучения темы можно найти в системах поддержки редакторов
растровых и векторных изображений, в открытых образовательных ресурсах, разме-

                                                                                181
щенных в сети Интернет. В процессе создания, редактирования и распространения
изображений особое внимание необходимо уделить соблюдению правил интернет-без-
опасности, цифровой этики, авторского права.


  Рекомендуемая учебная деятельность и продукты
  Упражнения:
  –	 выявление открытых образовательных ресурсов для изучения цифровой графики;
  –	 настройка рабочего пространства графических редакторов;
  –	 идентификация элементов и свойств изображений, предложенных учителем, и
     изображений, загруженных из Интернета;
  –	 идентификация графических объектов в составе изображений и их свойств;
  –	 рисование / перерисовка растровых и векторных изображений;
  –	 применение эффектов к изображениям и объектам, их составляющим;
  –	 импорт и экспорт изображений;
  –	 преобразование форматов цифровых изображений;
  –	 векторизация растровых изображений;
  –	 растеризация векторных изображений;
  –	 создание альбомов и архивов, локальных и в Интернете.
  Исследования:
  –	 Художественное и социально-экономическое влияние цифровых изображений.
  –	 Эволюция цифровых фотоаппаратов.
  –	 Эволюция графических редакторов в бесплатном распространении.
  –	 Эволюция проприетарных графических редакторов.
  –	 Веб-платформы для цифровых изображений.
  –	 Веб-сервисы для цифровых альбомов.
  –	 Графические средства выделения актуальности и важности идей и отражения
     настроений.
  –	 Художественные трансформации форм в процессе создания и редактирования
     изображений.
  –	 Художественная и эстетическая ценность цифровых изображений, часто встре-
     чающихся в повседневной жизни.
  –	 Реализм и абстракционизм цифровых изображений.
  –	 «Воровство» и «вдохновение» в цифровых изображениях.
  –	 Защита авторских прав на цифровые изображения.
  –	 Компьютерная графика и цифровая этика.
  Проекты:
  –	 Тематические выставки цифровой графики.
  –	 Цифровые альбомы: моя школа, мой город, мои друзья, праздничные мероприя-
     тия, развлекательные мероприятия, спортивные состязания.
  –	 Художественные тексты: замечательные цитаты, цитаты с выделением основной
     идеи, эпиграфы.
  –	 Профили выдающихся личностей.
  –	 Генеалогическое древо одного из знаменитостей-земляков.

182
   –	 Флаеры, тематические постеры, плакаты (права детей, гражданская активность,
      волонтерство, здоровый образ жизни, экология, свободная тема).
   –	 Цифровые коллекции указателей, знаков (дорожных, по охране труда, предупре-
      ждающих, информационных).
   –	 Рисунки для разных школьных предметов.



   4.3.Цифровая фотография
   Термин фотография имеет тройное значение. Под ним мы понимаем: (а) технику
создания изображений под действием света; (б) изображение, полученное с помощью
этой техники; и (в) отрасль графического искусства, в которой используется эта техника.
   Изначально фотографическая техника была основана на использовании светочув-
ствительных материалов, но с развитием информационных и коммуникационных
технологий изображения стали получать с помощью матриц, состоящих из светочув-
ствительных ячеек, называемых пикселями.
   Современные цифровые камеры используют матрицы, содержащие десятки и сотни
миллионов пикселей, и хранят эти изображения в графических файлах. Простая циф-
ровая обработка фотографий выполняется компьютерами, встроенными в камеры, но
более сложная обработка выполняется с помощью графических редакторов, работающих
на персональных компьютерах.
   Отметим тот факт, что цифровые фотографии можно получать не только с помо-
щью самих фотоаппаратов, но и с помощью камер, встроенных в мобильные телефоны
и персональные планшеты. Безусловно, качество цифровых фотографий зависит в
первую очередь от используемого оборудования, поскольку фотографии, сделанные с
помощью мобильных телефонов, планшетов и камер для любителей, по качеству ниже,
чем цифровые фотографии, сделанные с помощью камер для профессионалов. Более
того, в случае изобразительного искусства некоторые профессиональные фотографы
предпочитают использовать классические пленочные фотоаппараты, а проявленные
изображения впоследствии сканируются и обрабатываются с помощью графических
редакторов.
   Очевидно, что цифровые фотографии можно отображать на экранах цифрового
оборудования, проецировать с помощью мультимедийных устройств, печати и рас-
печатывания на различных статических носителях, таких как бумага, ткань, фольга,
керамические предметы и т. д.
   Развитие навыков создания цифровых фотографий основано на изучении следую-
щих тем.
   1. Основы цифровой фотографии: размер, разрешение, разрешающая способность,
цветовые схемы, графические форматы.
   2. Классификация и технические характеристики цифровых фотоаппаратов.
   3. Устройство и работа цифровых фотоаппаратов.
   4. Оборудование для цифровых фотоаппаратов: объективы, фильтры, вспышки,
штативы, фотометрические приборы, аксессуары.
   5. Факторы качества: композиция, фокус, глубина, выдержка.

                                                                                   183
   6. Техника цифровой фотографии: портреты и люди, натюрморты, репортажи, ар-
хитектура, пейзажи, спорт, животные, абстрактные сюжеты.
   7. Программные продукты для технической и художественной обработки цифровых
фотографий.
   8. Методы цифровой обработки фотографий. Преобразования: форматные, геоме-
трические, колористические, художественные.
   9. Хранение и распространение цифровых фотографий: архивирование, подготовка
к печати, организация в локальных альбомах и / или в Интернете.
  Упражнения:
  –	 выявление открытых образовательных ресурсов для изучения цифровой фото-
     графии;
  –	 определение свойств цифровых фотографий, предложенных преподавателем, и
     фотографий, загруженных из Интернета;
  –	 идентификация компонентов и элементов управления цифровых фотоаппаратов;
  –	 съемка и последующее управление файлами с помощью элементов управления
     цифрового фотоаппарата;
  –	 подсчет количества информации в цифровых фотографиях;
  –	 расчет возможных разрешений для фотографий;
  –	 изменение размера цифровых фотографий;
  –	 вырезка и редактирование фрагментов цифровых фотографий;
  –	 изменение цветовых схем, контрастности, кривых интенсивности основных
     цветов;
  –	 определение соотношения размеров экрана и физических размеров фотографии
     после печати;
  –	 нанесение эффектов витража, кристаллизации, ветра, дождя, плаката;
  –	 редактирование цифровых фотографий;
  –	 художественная обработка цифровых фотографий: пейзаж, индивидуальный
     портрет, групповой портрет, натюрморт, репортажи, путешествия, архитектурные
     объекты, спортивные соревнования, животные, абстрактная фотография;
  –	 идентификация знаков, декларирующих авторские права;
  –	 разъяснение правил соблюдения авторских прав;
  –	 использование лицензий на распространение.
  Исследования:
  –	 История фотографии.
  –	 История цифровой фотографии.
  –	 Художественное и социально-экономическое влияние цифровой фотографии.
  –	 Эволюция цифровых фотоаппаратов.
  –	 Специфика цифровых зеркальных фотоаппаратов DSLR (digital single-lens reflex –
     цифровой однообъективный зеркальный).
  –	 Факторы, влияющие на качество цифровых фотографий.
  –	 «Воровство» и «вдохновение» в цифровой фотографии.
  –	 Защита авторских прав на цифровые фотографии.
  –	 Цифровая фотография и этика Интернета.
  –	 Десять самых удачных фотографических портретов.

184
  –	   Животные в природе.
  –	   Самые экзотические цветы.
  –	   Впечатляющие фотоотчеты.
  –	   Карнавалы в картинках.
   Проекты:
   –	 Фотоотчеты с праздничных мероприятий, школьных конкурсов, творческих
      мероприятий, развлекательных мероприятий, общественных мероприятий, во-
      лонтерской деятельности.
   –	 Тематические выставки цифровых фотографий.
   –	 Цифровые альбомы: школьная жизнь, жизнь класса, праздники, моя деревня /
      город, портреты, натюрморты, отчеты, путешествия, архитектурные объекты,
      пейзажи, спортивные соревнования, животные, абстрактная фотография.
   –	 Коллекции цифровых фото для школьного музея, музея родного села / города.
   –	 Коллекции дидактических цифровых фотографий по различным школьным
      предметам.
   –	 Коллекции цифровых фотографий для индивидуальных интернет-профилей.
   Рекомендуем ученикам загрузить из Интернета наиболее подходящие для каждого из
них открытые образовательные ресурсы в области цифровой фотографии, руководства
по использованию цифровой фотоаппаратуры и программные продукты цифровой
графики. В процессе создания, редактирования и распространения фотографий особое
внимание необходимо уделить соблюдению правил интернет-безопасности, цифровой
этики, авторского права.




                                                                             185
  Ответы на задания из тестов для самопроверки

  Тест № 1


  1. a, c, d − верно; b, e, f, g − ошибочно.
  2.
                       <Команда>
                                                 вверх

                                                  вниз

                                                вправо

                                                 влево


                        <Оператор>

                                 Команда                    Число



                       <Программа>
                              начало                                     конец


                                                     Оператор




  3. a, c, e, f, h, i, m, o − верно; b, d, g, j, k, l, n − ошибочно.
  4. 	<Восьмеричная цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
  	<Восьмеричное число> ::= [+|–]<Восьмеричная цифра>{<Восьмеричная цифра>}

  5.	 <Цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
 	<Буква> ::= 	 a | b | c | d | e | f | g | h | i | j | k | l |
 		             m | n | o | p | q | r | s | t | u | v | w | x |	
		              y | z
  	<Идентификатор> ::= <Буква> { <Буква> | <Цифра> }
  6.
  	 1)	 x1	                                                  3)	 Delta

  	 2)	 x2	                                                  4)	 UnghiulAlfa

186
  	 5)	 UnghiulBeta	                                         8)	 Vocala
  	 6)	 DistantaParcursa	                                    9)	 Pixel

  	 7)	 ListaElevilor	                                      10)	 Culoare

  7.
  	 a)	 3.14	                        f)	 -984.52	                       k)	 -3628.297e12
  	 b)	 265	                         g)	 -523	                          l)	 -38.00001
  	 c)	 23.4635	                     h)	 +28	                           m)	 35728.345452e-8
  	 d)	 +0.000001	                   i)	 +28000000	                     n)	 24815
  	 e)	 6.1532e-5	                   j)	 614.45e-12	                    o)	 -296.0020001

  8.
  	 a)	 6124,485;	                   f)	 –0,03428⋅10–8;	                k)	 2005;
  	 b)	 +18,315;	                    g)	 232847,5213;	                  l)	 +23,08⋅10–5;
  	 c)	 –218,034⋅10–3;	              h)	 –0000012 ⋅10+2;	               m)	 –17502;
  	 d)	 193526;	                     i)	 18,45;	                        n)	 +1;
  	 e)	 1000,01⋅1023;	               j)	 623,495⋅10–6;	                 o)	 –46341,2⋅10–6.

  9. 	Ключевые слова: Program, var, begin, if, then, end, and.
  	 Специальные символы: ; , , , : , ( , ) , <> , := , / , ’ , = , . .
  	Идентификаторы: TA1, a, b, x, real, readln, writeln.
  	Числа: 0.
  	 Строки символов: 	 ’Уравнение имеет единственный корень’,
  		                    ’Уравнение имеет бесконечное множество корней’,
  		                    ’Множество корней уравнения пусто’.
   10. Строка 1 − заголовок; Строка 2 − раздел объявлений; Строки 3–15 − раздел
операторов.
  11. Ошибки будут распознаны компилятором интегрированной среды развития
программ на языке ПАСКАЛЬ.



  1. a, c, d – верно; b, e, f, g – ошибочно.
  2. Совпадает с рисунком из ответа на задание № 2, язык ПАСКАЛЬ (см. страницу 186)
  3. a, c, e, f , h, i, m, o – верно; b, d, g, j, k, l, n – ошибочно.
  4. <Восьмеричная цифра> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
  <Восьмеричное число> ::= [+|–]<Восьмеричная цифра>{<Восьмеричная цифра>}

                                                                                             187
  5. <Цифра> ::=	        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
 <Буква> ::= 	 a | b | c | d | e | f | g | h | i | j | k | l | m |
 		            n | o | p | q | r | s | t | u | v | w | x | y | z
  <Идентификатор> ::= <Буква> { <Буква> | <Цифра> }
  6.
  1)	 x1	                6)	 DistantaParcursa

  2)	 x2	                7)	 ListaElevilor

  3)	 Delta	             8)	 Vocala

  4)	 UnghiulAlfa	 9)	 Pixel

  5)	 UnghiulBeta	 10)	Culoare

  7.
  a)	 3.14	              f)	 –984.52	            k)	 –3628.297e12

  b)	 265	               g)	 –523	               l)	 –38.00001

  c)	 23.4635	           h)	 +28	                m)	35728.345452e-8

  d)	 +0.000001	         i)	 +28000000	          n)	 24815

  e)	 6.1532e-5	         j)	 614.45e–12	         o)	 –296.0020001

  8.
  a)	 6124,485;	         f)	 –0,03428 ∙ 10-8;	   k)	 2005;

  b)	 +18,315;	          g)	 232847,5213;	       l)	 +23,08 ∙10-5;

  c)	 –218,034 ∙10-3;	   h)	 –0000012 ∙ 10+2;	   m)	–17502;

  d)	 193526;	           i)	 18,45;	             n)	 +1;

  e)	 1000,01 ∙1023;	    j)	 623,495 ∙ 10-6;	    o)	 –46341,2 ∙10-6.

  9. Директивы: #include
  Ключевые слова: ussing, namespace, int, float, if, return
  Специальные символы: ;, ,, ==, !=, &&, (, ), {, }, <, >
  Идентификаторы: a, b, x, iostream
  Числа: 0.
  Строки символов:	 "Уравнение имеет единственный корень",
  			 "Уравнение имеет бесконечное множество корней",
  			 "Множество корней уравнения пусто".


188
   10. Строка 1 − директива; Строка 3 − основная функция; Строка 5 − декларативная
часть основной функции.
   11. Ошибки будут распознаны компилятором интегрированной среды для
разработки программ на языке C++.

  Тест № 2


   1. Под типом данных понимается множество значений и множество операций, ко-
торые могут выполняться с соответствующими значениями. Примеры типов данных:
integer, real, char. Значения 1, 2 и 3 – типа integer; Значения 1.0, 2.0
и 0.5e+07 – типа real, а значения ’A’, ’B’ и ’+’ – типа char.
   2. В программах на языке ПАСКАЛЬ величины являются объектами, предназначен-
ными для представления данных. Существуют величины двух видов: переменные и
константы. Значение любой переменной во время выполнения программы может быть
изменено, в то время как значения констант не могут быть модифицированы..
   3. i, j ↓ переменные типа integer; a, b, c↓ переменные типа real; s ↓
переменная типа char; p ↓ переменная типа boolean; 5, 9 ↓ константы типа
integer; 1.0, 1.0e-01, -2.001 ↓ константы типа real; ’A’ ↓ константа
типа char; true ↓ константа типа boolean.
   4. Множество значений типа данных integer состоит из целых чисел, которые
могут быть представлены в хост-компьютере языка программирования ПАСКАЛЬ.
Наибольшее допустимое значение можно узнать с помощью константы MaxInt, до-
ступной в любой программе ПАСКАЛЬ. Обычно наименьшее допустимое целое число
данного типа равно -MaxInt или – MaxInt+1). Примеры операций, допустимых над
целыми значениями: +, -, *, mod, div и др.
  5. Ошибки переполнения возникают в случае, если x*y>MaxInt. Например, для
MaxInt=32767 (версия Turbo PASCAL 7.0) ошибки переполнения возникают, если
пользователь вводит для x и y значения больше, чем 200.
   6. Множество значений типа данных real состоит из вещественных чисел, которые
могут быть представлены в хост-компьютере языка программирования ПАСКАЛЬ. Приме-
ры операций, допустимых над вещественными значениями: +, -, *, / (деление) и др.
Результаты данных операций являются приближенными вследствие ошибок округления.
   7. Ошибки переполнения появляются в случае, когда результат операции x*y
выходит за область значений типа данных real. В версии Turbo PASCAL 7.0 областью
значений типа real являются –1,7·1038, ..., +1,7·1038. Следовательно, ошибки пере-
полнения возникают в случае, если пользователь вводит для x и y значения больше,
                 20
например, чем 10 .
   8. Тип данных boolean включает значения истинности false и true. Предопре-
деленными операциями типа данных boolean являются логические операции not,
and и or.
  9. См. рис. 2.1.

                                                                              189
   10. Оператор readln(p, q) ошибочен вследствие того, что значения переменных
логического типа не могут быть считаны с клавиатуры.
   11. Множество значений типа char включает все печатные символы, упорядочен-
ные согласно таблице кодов ASCII. Примеры операций, допустимых над значениями
типа char: ord, pred, succ, операции отношения.
  12.
    Program RTA1;
      { Порядковые номера десятичных цифр }
    begin
    	writeln(ord(’0’));
    	writeln(ord(’1’));
    	writeln(ord(’2’));
    	writeln(ord(’3’));
    	writeln(ord(’4’));
    	writeln(ord(’5’));
    	writeln(ord(’6’));
    	writeln(ord(’7’));
    	writeln(ord(’8’));
    	writeln(ord(’9’));
    end.

   13. Множество значений перечисляемого типа данных задается списком идентифика-
торов. Первый в списке идентификатор задает минимальное значение, его порядковый
номер равен нулю. Второй идентификатор определяет значение с порядковым номером
один, третий – с номером два и т.д. Примеры операций, допустимые над значениями
перечисляемого типа: ord, pred, succ, операции отношения.

  14.
    Program RTA2;
      { Порядковые номера значений перечисляемого типа }
    type FunctiaOcupata = (Muncitor, SefDeEchipa, Maistru,
    	                        SefDeSantier, Director);
    	      StareaCivila = (Casatorit, Necasatorit);
    begin
    	writeln(ord(Muncitor));
    	writeln(ord(SefDeEchipa));
    	writeln(ord(Maistru));
    	writeln(ord(SefDeSantier));
    	writeln(ord(Director));
    	writeln(ord(Casatorit));
    	writeln(ord(Necasatorit));
    end.

   15. Интервальный тип определяет подмножество значений некоторого предопреде-
ленного типа: integer, boolean, char или перечисляемого, называемого базовым
типом. Над значениями интервального типа допустимы все операции базового типа.

190
  16. 	p –	интервальный тип, базовый тип char. Может принимать значения ’A’,
           ’B’, ’C’, ..., ’Z’;
  	q –	интервальный тип, базовый тип integer. Может принимать значения 1,
           2, 3, ..., 9;
  	r –	интервальный тип, базовый тип char. Может принимать значения ’0’,
           ’1’, ’2’, ..., ’9’;
  	s –	тип char. В качестве значения может принимать любой печатный символ ASCII;
  	t – 	тип integer. В качестве значения может принимать любое целое число,
           допустимое в конкретной машинной реализации языка;
  	u –	перечисляемый тип. Может принимать значения Alfa, Beta, Gama,
           Delta.
   17. Порядковые типы данных: integer, b o o l e a n , c h a r , перечисляемый,
интервальный. Общие свойства:
   a)	 любое значение порядкового типа имеет порядковый номер, который можно
       узнать с помощью предопределенной функции ord;
   b)	 к значениям любого порядкового типа можно применить операции отношения;
   c)	 для порядковых типов существуют предопределенные функции pred (предше-
       ствующий) и succ (последующий).
  18. Построчно будут выведены следующие значения:
  	     Y	        E          -6          10	          1	          3
  19. Построчно будут выведены следующие значения:
  	     1	        0	          2         true        false       true
  20.	 Два типа являются идентичными, если они описаны тем же именем.
   Два типа являются совместимыми в случае истинности одного из следующих
утверждений:
   a)	 рассматриваемые типы идентичны;
   b)	 один тип является интервальным типом второго;
   c)	 оба типа являются интервальными, с одинаковыми базовыми типами.
   Тип данных является анонимным, если он описан неявно при объявлении
переменных.
  21.	 Идентичные типы:: a) T1, integer şi T2; b) T3 şi T4;
       Совместимые типы: a) T1, integer, T2, T3, T4, T5 şi 1..100; b) T6, T7 şi T8;
       c) T9 şi T10.
  	    Анонимные типы: a) 1..100; b) (Alfa, Beta, Gama, Delta).
   22. Alfa – integer; Beta – real; Indicator – boolean; Mesaj –
строка символов; Semn – char; Inscris – строка символов.
  23.
  	 const 	a = 3.14;
  			 b = 9.8;
  	var 	i, j : integer;
  		    x, y : real;

                                                                               191
   1. Под типом данных подразумевается множество значений и множество операций,
которые могут быть выполнены с этими значениями. Примеры типов данных: int,
double, char. Значения 1, 2 и 3 относятся к целочисленному типу int; значения
1.0, 2.0 и 0.5e + 07 относятся к вещественному типу double, а значения ’A’,
’B’ и ’+’ − к типу char.
   2. В программе на C++ величины – это объекты, предназначенные для представле-
ния данных. Есть два вида величин: переменные и константы (постоянные). Во время
выполнения программы значение любой переменной можно изменить, а значения
констант изменить нельзя.
   3. i, j − переменные типа int; a, b, c − переменные типа double; s − перемен-
ная типа char; p − переменная типа bool; 5, 9 − константы типа int; 1.0, 1.0e-01,
-2.001 − константы типа double; ‘A’ − константа типа char; true − логическая
константа.
   4. Множество значений типа данных int состоит из целых чисел, которые могут
быть представлены на хост-компьютере языка программирования. Максимальное
значение указывает константа INT_MAX, известная любой программе на C++. Обычно
минимальное значение, допустимое для этого типа данных, составляет (INT_MAX+1).
С целочисленными значениями можно выполнять следующие операции: +, -, *,% и др.
   5. Ошибки переполнения будут возникать, когда x*y>INT_MAX. Например, для
компиляторов, выделяющих 2 байта (16 бит), INT_MAX = 32767, ошибки пере-
полнения будут возникать, если пользователь введет значения x и y больше 200.
Для компиляторов, выделяющих для типа данных int 4 байта (32 бита), INT_MAX
= 2147483647, ошибки переполнения будут возникать, если пользователь введет
значения x и y больше 46350.
   6. Множество значений рассматриваемого типа данных состоит из вещественных
чисел, которые могут быть представлены на хост-компьютере языка. Операции, кото-
рые могут быть выполнены с вещественными значениями: +, -, *, / (деление) и т. д. Ре-
зультаты этих операций обычно являются приблизительными из-за ошибок округления.
   7. Ошибки переполнения будут возникать, когда результат операции x*y не попадет
в диапазон значений типа данных double. Для компиляторов, которые выделяют 8
байтов для типа данных double, его диапазон значений составляет -1,7·10 ...
                                                                             308
         308
+1,7·10 . Поэтому ошибки переопределения будут возникать, когда пользователь
                                                    160
введет для x и y значения большие, чем, например, 10 .
   8. Тип данных bool включает значения истинности false и true. Предопреде-
ленные операции с типом данных bool: !, && и ||.
   9. См. рис. 2.1.
   10. При выполнении оператора cin>>p>>q логическим переменным с клавиату-
ры могут быть присвоены только числовые значения: 0 (вместо false) или 1 (вместо
true).
   11. Множество значений типа данных char включает все печатные символы, от-
сортированные в соответствии с таблицей кодов ASCII. Со значениями типа данных
char можно выполнять операции отношения.

192
   12.
    //Программа RTA1
    // порядковые номера десятичных чисел
    #include <iostream>
    using namespace std;
    int main()
    {
    cout<<int('0')<<endl;
    cout<<int('1')<<endl;
    cout<<int('2')<<endl;
    cout<<int('3')<<endl;
    cout<<int('4')<<endl;
    cout<<int('5')<<endl;
    cout<<int('6')<<endl;
    cout<<int('7')<<endl;
    cout<<int('8')<<endl;
    cout<<int('9')<<endl;
    return 0;
    }
   13. Множество значений любого перечисляемого типа данных определяется списком
идентификаторов. Первый идентификатор в списке обозначает наименьшее значение с
нулевым порядковым номером. Второй идентификатор будет иметь порядковый номер
один, третий – порядковый номер два и так далее. В C++ перечисляемые типы являются
целочисленными типами, и идентификаторы перечисляемого типа могут использоваться
так же, как целочисленные переменные. В языке C++ нет предопределенных функций
для прямого определения последующего или предшествующего значения. В арифме-
тических выражениях любые данные перечисляемого типа обрабатываются как целые
числа, причем преобразование в int является неявным, но преобразование целого
числа в перечисляемый тип должно быть запрошено явно. Таким образом, для перехода к
последующему или предшествующему элементу будут применяться операции изменения
типа с использованием так называемых операторов преобразования. Например, пусть x
будет целым числом, с помощью (char)x (или char(x)) мы изменим тип x с int на char.
   14.
    //Программа RTA2
    //Порядковые номера значений перечисляемого
    #include <iostream>
    using namespace std;
    int main()
    {
      enum FunctiaOcupata {Muncitor, SefDeEchipa, Maistru,
       SefDeSantier, Director};
      enum StareaCivila {Casatorit, Necasatorit};
       cout<<Muncitor<<endl;
       cout<<SefDeEchipa<<endl;
       cout<<Maistru<<endl;
       cout<<SefDeSantier<<endl;

                                                                               193
       cout<<Director<<endl;
       cout<<Casatorit<<endl;
       cout<<Necasatorit<<endl;
      return 0;
  }
   15. p – T1 это тип char. В качестве значения может принимать любой печатный
символ ASCII;
   q – T2 – это тип int. В качестве значения может принимать любое целое число,
       которое может быть представлено на хост-компьютере языка программирования;
   r – T3 – это тип char. В качестве значения может принимать любой печатный
       символ ASCII;
   s – типа char. В качестве значения может принимать любой печатный символ ASCII;
   t – типа int. В качестве значения может принимать любое целое число, которое
       может быть представлено на хост-компьютере языка программирования;
   u – перечисляемого типа. Может принимать значения Alfa, Beta, Gama, Delta.
  16. Порядковые типы данных: int, bool, char, enum. Общие свойства:
  a) любое значение порядкового типа имеет порядковый номер, который можно
      узнать с помощью оператора преобразования (int)x или int(x), (x –
      принадлежит порядковому типу);
  b) над значениями любого порядкового типа данных допустимы операции
      отношения.
  17. Построчно будут выведены следующие значения:
      	Y	          E	          -6	          10	           1	          3
  18. Построчно будут выведены следующие значения:
      	
      1	0	2	1	0	1
  19. Два типа являются идентичными, если они были определены одинаковым
именем или если у них имена разные, однако типы эквивалентны через транзитивность.
  Компиляторы проверяют совместимость типов в следующих случаях:
  –	 при присваивании
  –	 при передаче параметров
  –	 при вычислении значений выражений.
  Тип данных является анонимным, если он был определен по умолчанию, в
объявлении переменных.
  20.	 Идентичные типы: a) T1, T2, T3, T4, T5 și int; b) T6,T7 и T8; c) T9, T10 și char;
  	    Анонимные типы: (Alfa, Beta, Gama, Delta).
  21. Alfa – int; Beta – float; Indicator – bool; Mesaj – строка символов;
Semn – char; Inscris – строка символов.
  22.
      const float a = 3.14, b = 9.8;
      int i, j;
      float x, y;

194
Тест № 3


1.
a)	 (a+b)-2*a*b;	                             d) 	2*Alfa*Beta-5*Pi*r;

b)	 6*sqr(a)+15*a*b-13*sqr(b);	               e)	Pi*sqr(r)+Alfa*sqr(Beta);

c)	 (a+b)*(a-b);	                             f) 	x and y or x and z.

2.
a)	           ;	                              d)	       ;	


b)	      ;	                                   e)	            ;


c)	                ;	                         f)	 (x ≠ 0) & (q < p).

3. a, c, e, f ↓ правильно; b, d ↓ ошибочно.
4. a) 14; b) 6; c) –4; d) false; e) true; f) true.
5.
a)	 integer	                                  e)	 integer

b)	 real	                                     f)	 integer		

c)	 real	                                     g)	 boolean

d)	 integer	                                  h)	 char

6.

     Program RTA3;
     var	 i : integer;
     	    x, y : real;
     begin
     	writeln(’Введите i=’); readln(i);
     	writeln(’Введите x=’); readln(x);
     	writeln(’Введите y=’); readln(y);
     	writeln(15*i*(x+y));
     	readln;
     end.


                                                                         195
  7. a, c, e, f ↓ правильно; b, d ↓ ошибочно.
  8.
       Program RTA4;
       var x, y : real;
       begin
       	 write(’x=’); readln(x);
       	 if x>15	 then y:=9*x+3*sqr(x)
       		         else y:=3*x-5*sqrt(x+28);
       	 writeln(’y=’, y);
       	readln;
       end.

  9.
       Program RTA5;
       var i : integer;
       begin
       	write(’Введите числовое значение монеты: ’);
       	readln(i);
       	 case i of
       		 1 : writeln(’один бан’);
       		 5 : writeln(’пять банов’);
       		 10 : writeln(’десять банов’);
       		 25 : writeln(’двадцать пять банов’);
       		 50 : writeln(’пятьдесят банов’);
       	 	else writeln(’недопустимое значение’);
       	 end;
       	readln;
       end.

  10.
       Program RTA6;
       var	 n, i : integer;
       	    s, p : real;
       begin
       	write(’n=’); readln(n);
       	 s:=0; p:=1;
       	 for i:= 1 to n do
       	 	begin
       			s:=s+(1/i); p:=p*(1/i);
       	 	 end;
       	writeln(’s=’, s);
       	writeln(’p=’, p);
       	readln;
       end.

196
11.
     Program RTA7;
     var y, x, x1, x2, deltaX : real;
     begin
     	 write(’x1=’); readln(x1);
     	 write(’x2=’); readln(x2);
     	 write(’deltaX=’); readln(deltaX);
     	 writeln(’x’:10, ’y’:20);
     	writeln;
     	x:=x1;
     	 while x<=x2 do
     	    begin
     	    	if x>=4 then y:=2*sqrt(x+6) else y:=3-abs(x);
     		 writeln(x:20, y:20);
     		x:=x+deltaX;
     	    end;
     	readln;
     end.

12.
     Program RTA8;
     var	 c : char; { символ, считываемый с клавиатуры }
     	    n : integer; { количество цифр в сообщении }
     begin
     	n:=0;
     	writeln(’Введите сообщение:’);
     	 repeat
     		read(c);
     	 	if (c<>’*’) and (c<>’#’) then n:=n+1;
     	 until c=’#’;
     	writeln(’количество цифр n=’, n);
     readln;
     end.




1.
a)	 (a+b)-2*a*b;	                 d) 	2*Alfa*Beta-5*Pi*r;
     6*pow(a,2)+15*a*b-
b)	 	                             e)	Pi*pow(r,2)+Alfa*pow(Beta,2);
     13*pow(b,2);
c)	 (a+b)*(a-b);	                 f) 	x && y || x && z.


                                                                197
  2.
  a)	            ;	                             d)	       ;	


  b)	       ;	                                  e)	            ;


  c)	                 ;	                        f)	 (x ≠ 0) & (q < p).

  3. a, c, d, e, f ↓ правильно; b ↓ ошибочно.
  4. a) 14; b) 6; c) –4; d) 0; e) 1; f) 1.
  5.
  a)	   int;	                                   e)	   int;
  b)	   int;	                                   f)	   int;
  c)	   double;	                                g)	   bool;
  d)	   int;	                                   h)	   char.

  6.
       // Programul RTA3
       #include <iostream>
       using namespace std;
       int main()
       {
       int i;
       double x, y;
       cout<<″Dati i=″; cin>>i;
       cout<<″Dati x=″; cin>>x;
       cout<<″Dati y=″; cin>>y;
       cout<<15*i*(x+y);
       return 0;
       }
  7. a, c, ↓ правильно; b, e, f ↓ ошибочно.
  8.
       // Программа RTA4
       #include <iostream>
       #include <cmath>
       using namespace std;
       int main()
       {
       double x, y;
       cout<<″x=″; cin>>x;

198
     if (x>15) {y=9*x+3*pow(x,2);} else {y=3*x-5*sqrt(x+28);}
     cout<<″y=″<<y<<endl;
     return 0;
     }

9.
     // Программа RTA5
     #include <iostream>
     using namespace std;
     int main()
     {
     int i;
     cout<<″Введите значение монеты: ″;
     cin>>i;
     switch (i)
     {
         case 1 : cout<<″один бан″; break;
         case 5 : cout<<″пять банов″; break;
         case 10 : cout<<″десять банов″; break;
         case 25 : cout<<″двадцать пять банов″; break;
         case 50 : cout<<″пятьдесят банов″; break;
         default : cout<<″недопустимое значение″;
     }
       return 0;
     }

10.
     // Программа RTA6
     #include <iostream>
     using namespace std;
     int main()
     {
     int n, i;
     double s, p;
     cout<<″n=″; cin>>n;
     s=0; p=1;
     for (i=1; i<=n; i++)
     {s=s+(double)1/i; p=p*(double)1/i;}
     cout<< ″s=″<<s<<endl;
     cout<<″p=″<<p;
     return 0;
     }


                                                                199
  11.
      // Программа RTA7
      #include <iostream>
      #include <cmath>
      #include <iomanip>
      using namespace std;
      int main()
      {
      double y, x, x1, x2, deltaX;
      cout<<″x1=″; cin>>x1;
      cout<<″x2=″; cin>>x2;
      cout<<″deltaX=″; cin>>deltaX;
      cout<<setw(10)<<’x’<<setw(10)<<’y’<<endl;
      x=x1;
      while (x<=x2)
      {
          if (x>=4) {y=2*sqrt(x+6);} else {y=3-abs(x);}
          cout<<setw(10)<<x<<setw(10)<<y<<endl;
          x=x+deltaX;
      }
      return 0;
      }

  12.
      // Программа RTA8
      #include <iostream>
      using namespace std;
      int main()
      {
      char c;     // читается символ с клавиатуры
      int n; // количество цифр в сообщении
      n=0;
      cout<<″Введите сообщение:″<<endl;
      do
      {cin>>c;
      if ((c!=’*’)&&(c!=’#’)) { n=n+1;}
      }
      while (c!=’#’);
      cout<<″Количество цифр n=″<<n<<endl;
      return 0;
      }


200
   Приложение 1. Словарь языка ПАСКАЛЬ
   1. <Буква> ::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
   2. <Цифра> ::= 0|1|2|3|4|5|6|7|8|9
   3. <Специальный символ> ::= +|-
                   |*|/|=|<|>|]|[|,|(|)|:|;|^|.|@|{|}|$|#|<=|>=|
                   <> | := |..| <Ключевое слово> | <Эквивалентный символ>
   4. <Эквивалентный символ> ::= (*|*)|(.|.)
   5. <Ключевое слово> ::= 	and | array |   begin | case| const | div | do       |
   	                       downto | else    | end | file | for | function        |
   	                       goto | if | in   | label | mod | nil | not | of       |
   	                       or | packed |    procedure | program | record         |
   	                       repeat | set |   then | to | type | until | var       |
   	                       while |with
   6. <Идентификатор> ::= <Буква> { <Буква> | <Цифра> }
   7. <Директива> ::= <Буква> {<Буква> | <Цифра>}
   8. <Целое без знака> ::= <Цифра> {<Цифра>}
   9. <Знак> ::= + | –
   10. <Целое число> ::= [ <Знак> ] <Целое без знака>
   11. <Масштабный множитель> ::= <Целое число>
12. <Вещественное число> ::= <Целое число> e <Масштабный множитель> |
		<Целое число>.<Целое без знака>
		[e <Масштабный множитель> ]
   13. <Число> ::= <Целое число> | <Вещественное число>
   14. <Строка символов> ::= ’<Элемент строки> { <Элемент строки> } ’
   15. <Элемент строки> ::= ’’| <Любой печатный символ>
   16. <Метка> ::= <Целое без знака>
   17. <Комментарий> ::= (* <Любая последовательность символов, заключенная внутри
фигурных скобок> *)



  Примечание. Терминальные символы { и } из формулы (17) переданы эквивалент-
ными символами (* и *) соответственно.


                                                                               201
    Приложение 2. Синтаксис языка ПАСКАЛЬ
    1. <Программа> ::= 	 <Заголовок программы>
	                    <Тело>.
  2. <Заголовок программы> ::= Program <Идентификатор> [(<Идентификатор> {,
<Идентификатор>})];
    3. <Тело> ::= 	<Объявления>
	                  <Составной оператор>
4. <Объявления> ::= 	[<Метки>]
	[<Константы>]
	[<Типы>]
	[<Переменные>]
	[<Подпрограммы>]
    5. <Метки> ::= label <Метка> {, <Метка>};
   6. <Константы> ::= const <Определение константы>; { <Определение
константы>;}
    7. <Определение константы> ::= <Идентификатор> = <Константа>
  8. <Константа> ::= [+ | -] <Число без знака> | [+ | -] <Имя константы> |
<Строка символов>
    9. <Типы > ::= type <Описание типа>; { <Описание типа>;}
    10. <Описание типа> ::= <Идентификатор> = <Тип>
    11. <Переменные> ::= var <Объявление переменных>; {<Объявление переменных>;}
    12. <Объявление переменных> ::= <Идентификатор> {, <Идентификатор>} : <Тип>
    13. <Подпрограммы> ::= { <Функция>; | <Процедура>; }
    14. <Тип> ::= 	<Идентификатор> |
	                  <Перечисляемый тип> |
	                  <Интервальный тип> |
	                  <Тип-массив> |
	                  <Тип-запись> |
	                  <Тип-множество> |
	                  <Файловый тип> |
	                  <Ссылочный тип>
    15. <Перечисляемый тип> ::= (<Идентификатор> {, <Идентификатор>})
    16. <Интервальный тип> ::= <Константа>..<Константа>
    17. <Тип-массив> ::= [ packed ] array (. <Тип> {, <Тип> } .) of <Тип>
    18. <Тип-множество> ::= [ packed ] set of <Тип>
    19. <Файловый тип> ::= [ packed ] file of <Тип>
    20. <Ссылочный тип> ::= ^<Тип>

202
  21. <Тип-запись> ::= [ packed ] record <Список полей> [;] end
  22. <Список полей> ::= <Фиксированная часть> [; <Область вариантов> ] |
<Область вариантов>
  23. <Фиксированная часть> ::= <Раздел записи> { ; <Раздел записи> }
  24. <Раздел записи> ::= <Имя поля> {, <Имя поля> } : <Тип>
  25. <Область вариантов> ::= case [ <Идентификатор> : ] <Тип> of <Вариант> {;
<Вариант> }
  26. <Вариант> ::= <Константа> {, <Константа> } : ( [ <Список полей> ] [;] )
27. <Функция> ::= <Заголовок функции>; <Тело> | <Заголовок функции>;
	<Директива> | function <Идентификатор> ; <Тело>
  28. <Заголовок функции> ::= function <Идентификатор>
  			                   [<Список формальных параметров>] : <Идентификатор>
  29. <Процедура>::=<Заголовок процедуры>;<Тело> | <Заголовок процедуры>;
  			<Директива> | procedure <Идентификатор> ; <Тело>
  30. <Заголовок процедуры> := procedure <Идентификатор>
  				[<Список формальных параметров>]
  31. <Список формальных параметров> ::= (<Формальный параметр> {;
  					                                   <Формальный параметр>})
  32. <Формальный параметр> ::= [var] <Идентификатор> {, <Идентификатор>} :
<Идентификатор> |<Заголовок функции> | <Заголовок процедуры>
  33. <Оператор> ::= [ <Метка> : ] <Оператор без метки>
34. <Оператор без метки> ::= <Присваивание> | <Вызов процедуры> |
	<Составной Оператор> |
	<Оператор if> | <Оператор case> |
	<Оператор while> | <Оператор repeat> |
	<Оператор for> | <Оператор with> |
	<Оператор goto> | <Пустой оператор>
  35. <Присваивание> ::= <Переменная> := <Выражение> | <Имя функции> :=
  			<Выражение>
  36. <Вызов процедуры> ::= <Имя процедуры> [ <Список актуальных параметров> |
  	                                           <Список параметров вывода> ]
  37. <Список актуальных параметров> ::= (<Актуальный параметр >
  						{,<Актуальный параметр>})
  38. <Актуальный параметр > ::= <Выражение> | <Переменная> | <Имя функции> |
  				<Имя процедуры >
  39. <Имя функции> ::= <Идентификатор>
  40. <Имя процедуры> ::= <Идентификатор>
  41. <Список параметров вывода> ::= (<Параметр вывода> { , <Параметр вывода> })
  42. <Параметр вывода> ::= <Выражение> [ :<Выражение> [ : <Выражение> ]]

                                                                                203
    43. <Составной Оператор> ::= begin <Оператор> { ; <Оператор> } end
    44. <Оператор if > ::= if <Логическое выражение> then <Оператор>
    		[else <Оператор>]
    45. <Оператор case> ::= case <Выражение> of [<Вариант>{; <Вариант>}] [;] end
    46. <Вариант> ::= <Константа> {, <Константа>} : <Оператор>
    47. <Оператор while> ::= while <Логическое выражение> do <Оператор>
    48. <Оператор repeat> ::= repeat <Оператор> {;<Оператор>}
    	until <Логическое выражение>
    49. <Логическое выражение> ::= <Выражение>
    50. <Оператор for> ::= for <Переменная> := <Выражение> <Шаг> <Выражение>
    	                       do <Оператор>
    51. <Шаг> ::= to | downto
    52. <Оператор with> ::= with <Переменная> {,<Переменная>} do <Оператор>
    53. <Оператор goto> ::= goto <Метка>
    54. <Пустой оператор> ::=
    55. <Переменная> ::= <Идентификатор> | <Переменная> (. <Выражение> { ,
	                        <Выражение> } .) | <Переменная>.<Имя поля> | <Переменная>
    56. <Имя поля> ::= <Идентификатор>
57. <Выражение> ::= <Простое выражение>{<Оператор отношения>
			<Простое выражение>}
    58. <Оператор отношения> ::= < | <= | = | >= | > | <> | in
    59. <Простое выражение> ::= [+ | —]<Терм>{<Аддитивный оператор> <Терм>}
    60. <Аддитивный оператор> ::= + | – | or
    61. <Терм> ::= <Фактор> {<Мультипликативный оператор> <Фактор>}
    62. <Мультипликативный оператор> ::= * | / | div | mod | and
    63. <Фактор> ::= <Переменная> | <Константа без знака> | <Вызов функции> |
	                    not <Фактор> |(<Выражение>)|<Конструктор множества>
    64. <Вызов функции> ::= <Имя функции> [ <Список актуальных параметров> ]
65. <Константа без знака> ::= <Число без знака> | <Строка символов> |
				<Идентификатор> | nil
66. <Конструктор множества> ::= (. [ <Спецификация элемента> { ,
					<Спецификация элемента> } ] .)
    67. <Спецификация элемента> ::= <Выражение> [ .. <Выражение> ]




   Примечание. Терминальные символы [ и ] из формул (17), (55) и (66) переданы
эквивалентными символами (. и .) соответственно.

204
  Приложение 3. Компиляция и отладка программ
  на языке ПАСКАЛЬ
   После написания программы на языке ПАСКАЛЬ она редактируется, компилируется
и отлаживается.
   Редактирование заключается во вводе программы в компьютер. Введенные програм-
мы можно хранить в текстовых файлах с расширением .pas.
   Компиляция ‒ это процесс автоматического перевода программы, написанной на
языке ПАСКАЛЬ, в программу, написанную на компьютерном языке. После компиляции
программу на машинном языке можно запустить или сохранить в исполняемом файле
с расширением .exe.
   Отладка ‒ это процесс обнаружения и исправления синтаксических и семантических
ошибок в программе на языке ПАСКАЛЬ.
   Обычно все эти операции выполняются с помощью специальных программ, называ-
емых интегрированными средами разработки (IDE Integrated Development Environment).
   В случае интегрированных сред разработки взаимодействие пользователя с компью-
тером осуществляется с использованием графических интерфейсов, которые отобра-
жают на экране окна приложений, диалоговые окна, окна навигации, окна проводника
и окна документов.




   Как правило, окна интегрированной среды разработки программ содержат
стандартные графические элементы, изученные в предыдущих классах: строка меню,
меню, команды, кнопки, курсоры, текстовые поля и т. д.
   Представим далее часто используемые команды из меню программных средств Turbo
PASCAL и Free PASCAL, установленных в большинстве компьютерных классов в школах
Республики Молдова.

  Меню File (Файл)
   New (Новый) − создает новое окно, в котором пользователь может вводить
и редактировать текст, обычно это программа на языке ПАСКАЛЬ.

                                                                              205
   Open... (Открыть...) − читает указанный пользователем файл и
отображает его содержимое в новом окне. Затем это содержимое может быть
обработано по желанию.
   Save (Сохранить) − сохраняет содержимое текущего окна в ранее открытый
с помощью команды Open файл. Однако, если текущее окно было создано
с помощью команды New, будет создан новый файл, и пользователю будет
предложено дать ему имя.
   Save as... (Сохранить как...) − сохраняет содержимое текущего окна
в новый файл. Пользователю предлагается дать имя для вновь созданного
файла.
   Print (Печать) − печать содержимого текущего окна на принтере.
   Exit (Выход) − выход из интегрированной среды разработки программ.
Перед выходом из программы приложение предложит пользователю сохранить
содержимое открытых окон.

  Меню Edit (Редактирование)
   Cut (Вырезать) − вырезает выделенный фрагмент текста. Вырезанный
фрагмент помещается в буфер памяти.
   Copy (Копировать) − копирует выделенный фрагмент текста. Скопиро-
ванный фрагмент помещается в буфер памяти.
   Paste (Вставить) − фрагмент текста в буфере памяти вставляется в место
нахождения курсора.
   Clear (Очистить) − удаляет выделенный фрагмент текста, не помещая
его в буфер памяти.

  Меню Search (Поиск)
   Find (Найти) − ищет, начиная с текущей позиции курсора, фрагмент тек-
ста, обозначенный в текстовом поле диалогового окна.
   Replace (Заменить) − заменяет выбранный фрагмент текста на фрагмент,
указанный пользователем.

  Меню Run (Запуск)
   Run (Выполнить) − компилирует и запускает программу на языке ПА-
СКАЛЬ из текущего окна. Если программа содержит синтаксические ошибки,
отобразится сообщение с указанием типа и места возникновения ошибки.

  Меню Compile (Компиляция)
   Compile (Компилировать) − компилирует программу на языке ПАСКАЛЬ
из текущего окна, но не запускает ее на выполнение.
   Build (Создать) − компилирует программу на языке ПАСКАЛЬ из теку-
щего окна и сохраняет результат компиляции в исполняемом файле.

   Меню Windows содержит команды, обеспечивающие расположение окон и пе-
реключение между ними, а также команды меню Help, обеспечивающие доступ
к справочному руководству.

206
  Приложение 4. Словарь языка C++
  1. <Буква> ::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
  2. <Цифра> ::= 0|1|2|3|4|5|6|7|8|9
 3. <Специальный символ> ::= + | – | * | / | = | < | > | ] | [ | ,
								 | ( | ) | : | ; | ” | . | \ | { | } | $ |
								 # | <= | >= | == | != | % | &
 4. <Ключевое слово>::=	 auto | asm | bool | break |case | catch| char |
								const | continue | class | default | delete | do |
								double | else | enum | extern | float | for |
								friend | goto | if | inline | int | long |
								namespace | new | operator | private | public |
								protected | plate | register | return | short |
								signed | sizeof | static | struct | switch |
								typedef | union | unsigned | using | void |
								volatile | virtual | while
  5. <Идентификатор> ::= <Буква> { <Буква> | <Цифра> }
 6. <Директива> ::= # <Ключевое слово> <Исходный файл>| # <Ключевое слово>
						<Идентификатор> [<Число>|<Строка символов>]
  7. <Целое без знака> ::= <Цифра> {<Цифра>}
  8. <Знак> ::= + | –
  9. <Целое число> ::= [ <Знак> ] <Целое без знака>
  10. <Масштабный множитель> ::= <Целое число>
 11. <Вещественное число> ::=	 <Целое число> e <Масштабный множитель> |
										<Целое число>.<Целое без знака> [e
 										<Масштабный множитель> ]
  12. <Число> ::= <Целое число> | <Вещественное число>
  13. <Строка символов> ::= “<Элемент строки> { <Элемент строки> } ”
  14. <Элемент строки> ::= “ ”| <Любой печатный символ>
  15. <Метка> ::= <Идентификатор> <:>
  16. <Комментарий> ::= // <Любая последовательность символов и конец строки >
  								| /* < Любая последовательность символов >*/



                                                                          207
  Приложение 5. Компиляция и отладка программ C++

   Программа – это исполняемый файл в двоичном коде. Текстовый файл, со-
держащий реализацию программы на языке программирования, представляет
собой файл исходного кода или просто исходный код, например, исходный
код C++, исходный код Java и т. д. Процесс записи файла исходного кода назы-
вается написанием исходного кода или написанием кода.
   После написания программы на C++ она редактируется, компилируется,
компонуется и выполняется.
   Редактирование заключается во вводе программы в компьютер. Введенные
программы можно хранить в текстовых файлах с расширением .cpp.
   Компиляция – это процесс автоматического перевода программы, написан-
ной на C++, в программу, написанную на компьютерном языке (машинном
коде). Процесс компиляции выполняется с помощью компилятора. В варианте
языка C++ на первом этапе компиляции вызывается препроцессор. Сначала
он распознает и анализирует директивы процессора. Затем проверяется ис-
ходный код, чтобы убедиться, что он соответствует синтаксису и семантике
языка. Если есть ошибки, о них пользователю выдаются сообщения. Поль-
зователь должен исправить ошибки (изменив исходную программу). Только
после этого исходный код переводится в код ассемблера и, наконец, в двоичный
машинный код, соответствующий компьютеру. Этот двоичный код называется
объектным кодом и обычно хранится в другом файле, называемом объектным
файлом. Объектный файл обычно имеет то же имя, что и исходный файл, и
расширение .obj.
   Компоновка. После того как исходная программа была переведена в объ-
ектную программу, она будет подвергнута операции компоновки. Цель этой
операции – получить окончательную форму программы для ее выполнения.
Компоновщик «связывает» объектные модули, выполняет ссылки на внешние
функции и процедуры в библиотеках и создает исполняемый код, хранящийся
в другом файле, который называется исполняемым файлом с тем же именем
и расширением .exe.
   Выполнение. Запуск на выполнение заключается в загрузке исполняемой
программы в память и ее выполнении.
   Обычно все эти операции выполняются с помощью специальных программ,
называемых интегрированными средами разработки (IDE – Integrated
Development Environment).
   При использовании интегрированных сред разработки взаимодействие
пользователя с компьютером осуществляется с помощью графических интер-
фейсов, которые отображают на экране окна приложений, диалоговые окна,
окна навигации, окна проводника и окна документов.
   Если интегрированная среда не используется, программист вызовет (в ко-
мандной строке) текстовый редактор, компилятор, компоновщик. Запуск на
выполнение также будет производиться из командной строки.

208
   Мы будем использовать интегрированные среды разработки. Как прави-
ло, окна интегрированных сред разработки программ содержат стандартную
графику, изученную в предыдущих классах: строка меню, меню, команды,
кнопки, курсоры, текстовые поля и т. д.
   Представляем далее часто используемые команды из меню среды програм-
мирования Code :: Blocks, которую можно скачать из Интернета по адресу
http://www.codeblocks.org/. Этот продукт представляет собой бесплатную интегри-
рованную среду разработки (IDE), которая содержит все, что нужно программисту
для создания приложений. Перечислим некоторые из необходимых инструментов:
   1) Текстовые редакторы. Необходимы для написания программы или исход-
ного кода – файлы с расширением .c (для языка C) или .cpp (для языка C++);
   2) Компиляторы. Необходимы для преобразования исходного кода в коман-
ды, понятные процессору, и создания исполняемой программы или скомпили-
рованных файлов. Существует несколько компиляторов для языков C / C++,
наиболее часто используемый – gcc (GNU C Compiler).
   3) Библиотеки – файлы заголовков, содержащие описание определенных
функций, наиболее распространенными из которых являются чтение и отобра-
жение данных (файл iostream). Любые дополнительные функции могут быть
добавлены путем установки плагинов (например, компиляторов).
   Написание программы на языке C++ предполагает выполнение следующих
шагов.
   Шаг 1. Запуск среды программирования. Осуществляется выбором соот-
ветствующей команды из меню Start операционной системы либо двойным
щелчком на пиктограмму Code::Blocks на рабочем столе.
   Шаг 2. Создание нового проекта. В окне приложения, которое появляется
сразу после запуска среды программирования, выберите Create a new project.




  Шаг 3. Выбор типа приложения. В целом среда разработки программ
Code :: Blocks дает пользователям возможность создавать разные типы
приложений, такие как Консольное приложение, Библиотека динамической
компоновки (Dynamic Link Library), Arduino (программы для роботов) и др.
Очевидно, что в нашем случае будет выбран вариант Консольного приложения
(Console application):
  Шаг 4. Выбор языка, на котором будет написана программа. Конечно, в
нашем случае необходимо выбрать язык C ++.
  Шаг 5. Определение названия проекта и места, где он будет сохранен.

                                                                           209
   Например, на приведенном рисунке проект называется primul_program и
сохраняется в папке C:\Users\User\Desktop\programe\
   Шаг 6. Редактирование программы. Редактирование производится в глав-
ном окне среды разработки программ.
   Это окно имеет стандартную структуру и включает:
   −	 Строку меню, содержащую в том числе наиболее часто используемые
      в процессе изучения языка C++ меню: File, Edit, Build (Построение),
      Debug (Отладка).
   −	 Строки/панели, содержащие часто используемые команды, обозначенные
      пиктограммами;
   −	 Панель управления, в которой отображается древовидная структура
      проекта;

210
  −	 Окно редактирования, в котором пишутся разрабатываемые программы;
  −	 Окно, содержащее вкладки, показывающие сообщения об ошибках,
     значения переменных, команды, выполняемые в пошаговом режиме.
     Вкладка для отображения выбирается с помощью закладок из верхней
     части этого окна.
  Подчеркнем, что пользователь может настроить главное окно с помощью
команд в меню View (Просмотр).




   Шаг 7. Компиляция и выполнение программы. Основные инструменты,
используемые при компиляции, выполнении и сохранении программы, нахо-
дятся в меню Build, а наиболее часто используемые обозначаются значками
из соответствующей панели:




  Результат выполнения программы будет выведен на экран:




                                                                    211
   Если же программа содержит синтаксические ошибки, соответствующие
сообщения выводятся в специальной области, отмеченной на нижеследующем
рисунке.




   После исправления ошибок программу необходимо опять запустить на ком-
пиляцию и выполнение.
   Шаг 8. Отладка программы (устранение неполадок в программе). За
исключением некоторых очень простых программ, разрабатываемые про-
граммы содержат не только синтаксические, но и логические ошибки. Среды
разработки программ не могут автоматически обнаруживать такие ошибки,
но они предоставляют пользователю инструменты, облегчающие этот процесс.
   Чтобы обнаружить возможные логические ошибки, программист должен подгото-
вить набор тестов. Каждый из этих тестов содержит исходные данные и стандартные
ответы. Запуская программу для каждого из разработанных тестов, пользователь
сравнивает ответы, предоставленные программой, со стандартными ответами.
В случае несоответствий программист может выполнить операторы программы
в пошаговом режиме и отобразить текущие значения переменных в программе.
   Операции по устранению неполадок выполняются с помощью следующих
команд:
   a) Debug → Debugging windows → Watches позволяет обзор значений
переменных в реальном режиме времени.
   b) Debug → Step into позволяет построчно/пошагово увидеть, как работает
ваша программа.
   Вообще говоря, обнаружение логических ошибок требует от программиста особого
внимания. Даже в случае программ, разработанных для учебных целей, их напи-
сание занимает около 30% рабочего времени ученика, а отладка этих программ −
остальные 70%. Поэтому в процессе изучения информатики ученикам рекомендуется
распределять время на обучение таким образом, чтобы у них была возможность не
только писать, но и устранять неполадки в разработанных ими программах.
   Более подробную информацию о среде разработки программы можно найти
в руководстве пользователя, доступном по адресу http://www.codeblocks.org/
user-manual

212
