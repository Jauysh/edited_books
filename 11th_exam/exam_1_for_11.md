
# Глава 1
## СОСТАВНЫЕ ТИПЫ ДАННЫХ
### 1.1. Простые и составные типы данных
Мы уже знаем, что информация, которую может обрабатывать компьютер, должна быть представлена в виде данных. Данные состоят из цифр, букв, знаков, чисел, строк символов и т. д.
  
В машинном коде данные представляются в виде последовательностей двоичных цифр. Например, на уровне процессора натуральное число 1039 в двоичной системе счисления представляется как:
`10000001111`

Чтобы избавить пользователя от всех деталей, связанных с внутренним представлением данных, языки программирования используют различные типы данных. Напомним, что тип данных означает множество значений и множество операций, которые могут быть выполнены с этими значениями.

В предыдущих классах вы изучили следующие типы данных:

*   `integer/int`, предназначенный для компьютерной обработки целых чисел;
*   `real/float`, предназначенный для обработки вещественных чисел;
*   `boolean/bool` используется при обработке значений истинности;
*   `char/char`, предназначенный для представления и обработки символов;
*   `перечисляемый (enum)`, который включает упорядоченный набор значений, определенных идентификаторами;
*   `интервальный (только на языке ПАСКАЛЬ)`, который включает подмножество значений типа integer, boolean, char или перечисляемого.

С точки зрения языков программирования, целые числа, вещественные числа, значения истинности, символы, упорядоченные значения, заданные идентификаторами, называются простыми данными, а вышеперечисленные типы – простыми типами данных.

В общем, простых данных недостаточно для представления и эффективной обработки с помощью компьютера информации из окружающего мира.

Например, в случае обработки текстов операции удаления, копирования и перемещения выполняются не только на уровне символов (простой тип данных char), но также на уровне слов, предложений, строк, абзацев и даже целых страниц. Очевидно, что слово или предложение можно представить как последовательность символов, то есть через структуру, состоящую из последовательности простых данных типа char. Для описания таких структур языки программирования высокого уровня используют типы данных, называемые строками символов. Следовательно, буквы латинского алфавита A, a, B, b, C, c,…, Z, z представлены на компьютере простыми данными типа char, а слова, образованные из них, например Liceu, Patrie, Informatica и т. д. ― с помощью составных данных типа строка символов.

Другой пример, иллюстрирующий необходимость использования составных данных, – это обработка информации о ежедневном потреблении электроэнергии в домашнем хозяйстве. Объем потребления, в кВт·ч, может быть представлен на компьютере вещественным числом (простой тип данных `real` или `float`). Однако если мы хотим проанализировать изменения суточного потребления электроэнергии в течение месяца, нам придется представить соответствующие данные в виде одномерной таблицы, состоящей из одной строки:

| День месяца | 1    | 2    | 3    | ... | 31   |
|-------------|------|------|------|-----|------|
| Ежедневное потребление, кВт·ч | 13,4 | 18,6 | 9,4 | ... | 15,0 |


В первой ячейке этой таблицы будет содержаться потребление, в кВт·ч, в первый день месяца; во второй ячейке ― потребление во второй день месяца и так далее до ячейки 31, в зависимости от количества дней в рассматриваемом месяце.

При анализе суточного потребления электроэнергии в течение года нам придется использовать таблицу, состоящую из 12 строк и 31 столбца, то есть двумерную таблицу:

| День месяца | 1    | 2    | 3    | ... | 31   |
|-------------|------|------|------|-----|------|
| Январь      | 13,4 | 18,6 | 9,4  | ... | 15,0 |
| Февраль     | 12,9 | 14,3 | 21,7 | ... | ...  |
| ...         | ...  | ...  | ...  | ... | ...  |
| Декабрь     | 11,7 | 10,4 | 3,4  | ... | 25,3 |


Первая строка такой таблицы будет содержать потребление для каждого из дней января; вторая строка ― потребление для каждого дня февраля и так далее до строки, соответствующей декабрю.

Можно заметить, что приведенные выше таблицы представляют собой составные данные, состоящие из простых данных типа real / float. Обычно на компьютере соответствующие таблицы представляются с помощью специальных типов составных данных, называемых массивами.

Подчеркнем, что массивы содержат только данные в ячейках, без имен строки столбцов. На компьютере эти имена представлены другими величинами, называемыми индексами. Очевидно, что в случае одномерных массивов требуется только один индекс, а в случае двумерных массивов ― два.

Например, в случае одномерного массива, который представляет на компьютере ежедневное потребление электроэнергии в течение месяца, в качестве индекса используется целая величина, которая может принимать только значения 1, 2, 3,…, 31.

В случае двумерного массива, который представляет ежедневное потребление электроэнергии в течение года, необходимы два индекса: один для строк и один для столбцов. Перечисляемый тип, который принимает значения Ianuarie, Februarie, Martie, …, Decembrie, используется в качестве индекса для строк. Для индекса столбца используется целочисленная величина, которая принимает значения 1, 2, 3,… 31.

Данные, сформированные путем агрегирования (объединения в единое целое) простых данных, называются составными данными. Типы данных, используемые для определения таких данных, называются составными типами данных.
   
В дополнение к строкам символов и массивам, вышеописанным в общих чертах, языки программирования предлагают специалистам возможность использовать и другие составные типы данных, наиболее часто используемые,
― записи, множества и файлы.

##Вопросы и упражнения
1.   Объясните значения термина тип данных. Приведите примеры.
2.   В чем отличие между простыми и составными типами данных?
3.   Приведите примеры простых типов данных и составных типов данных.
4. ОБРАТИТЕ ВНИМАНИЕ! Определите, какой тип, простой или составной, имеют данные в нижеследующих примерах:

 1.	   `138`
 2.	   `3.14`
 3.	   `Munteanu Elena`
 4. 	 `Clasa a 11-a`
 5.	   `12   |   6   | 231  |  5`
 6.	   `32.51    |   149,28 | 318,56 | 20013.9 |  0.4536  |  721.3`
 7.	           
|   4  |  635 |  -8  | +27  |

|  72  |   41 |  319 | 432  |

|  16  |  -20 |   45 | 1830 |

В случае составных данных укажите тип простых данных, входящих в их состав.
Примеры ответов:

* Простое данное типа целое число.
* Составное данное типа одномерный массив, состоящий из целых чисел.

5.	 ТВОРИТЕ! Составьте одномерную таблицу, содержащую ежемесячные платежи за электроэнергию, потребленную вашей семьей в течение последнего календарного года. Используйте для этой цели информацию в счетах на оплату, выставленных компанией-поставщиком электроэнергии. Какие типы данных вы будете применять для представления информации в этой таблице на компьютере?


6. ИССЛЕДУЙТЕ! На сайте Национального банка Молдовы размещена информация о средних официальных курсах валютного обмена (обменном курсе). Например, в январе 2019 года средний официальный обменный курс единой валюты Европейского союза составлял: 1 евро = 19,6501 молдавских леев. Составьте:
* одномерную таблицу, содержащую официальные среднемесячные курсы этой валюты за последний календарный год;
* двумерную таблицу, содержащую официальные среднемесячные обменные курсы этой валюты за последние три года.

Какие типы данных вы будете использовать для представления информации в этих таблицах на компьютере?


7. ТВОРИТЕ! После посещения знаменитых Криковских подвалов, во время которого ученый-информатик имел возможность путешествовать по подземным галереям этого важного туристического объекта, ученый сконструировал робота, который находит кратчайший путь из одного выставочного зала в другой. В памяти компьютера, управляющего действиями робота, план галерей представлен прямоугольником, разделенным на квадраты (см. рисунок ниже).

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|---|
| 1 | x | x | x | x | x | x | x | x | x |
| 2 | x |   |   | x |   |   |   |   | x |
| 3 | x |   | x |   |   | x |   | x | x |
| 4 | x |   |   |   | x |   |   |   | x |
| 5 | x |   | x |   | x |   | x |   | x |
| 6 | x |   |   |   |   |   | x |   | x |
| 7 | x |  Вход | x | x | x | x | x |  Выход | x |
                   
Закрашенные квадраты представляют препятствия (стены галерей и выставочных залов, стенды с экспонатами), не закрашенные ― свободные пространства. Робот может выполнять только команды ВВЕРХ, ВНИЗ, НАПРАВО, НАЛЕВО, согласно которым он перемещается в один из соседних квадратов. Если в этом квадрате есть препятствие, например стена или стенд, робот останавливается и не реагирует ни на какие команды. Разработайте структуру данных, необходимую для представления плана Криковских подвалов на компьютере. Убедитесь, что продуманная структура содержит всю информацию о плане: препятствия, свободные пространства, квадраты, в которых находятся начальное положение робота, вход и выход.

8. УЧИТЕСЬ УЧИТЬСЯ! Вы уже знаете, что составные данные получаются путем агрегирования (объединения в единое целое) простых данных. Языки ПАСКАЛЬ и C++ позволяют агрегировать не только простые данные, но и составные. Например, в ячейках таблицы можно хранить не только простые данные (целые числа, действительные числа, символы и т. д.), но и составные данные, такие как строки.

Дан список учеников лицейского класса:
* Мунтяну Ион
* Флоря Елена
* …
* Присэкару Александра

Разработайте структуру данных, необходимую для представления такого списка на компьютере. Убедитесь, что продуманная структура позволяет сортировать список учащихся по алфавиту.




###     1.2. Тип данных массив

В языке программирования C++ тип данных одномерный массив определяется конструкцией вида:

**typedef** <Тип компонентов> <Имя типа массив> [<Количество компонентов>];
где <Тип компонентов> – это тип компонентов массива, который может быть практически любым типом данных, а <Количество компонентов> указывает количество компонентов массива.

Индексы компонентов массива могут принимать только последовательные целочисленные значения, начиная с нуля: 0, 1, 2,…, <Количество компонентов> - 1.

Примеры:
1.	itypedef int Vector[5];
    Vector V;
2.	typedef char Simbol[10];
    Simbol S;
3.	typedef float Acceleratie[45];
    Acceleratie A;

Структура данных из рассмотренных примеров представлена на рисунке 1.1*.
```
typedef int Vector [5]
Индексы      0   1   2   3   4
Компоненты  int int int int int

typedef char Simbol [10]
Индексы     0    1    2    3    4    5    6    7    8    9
Компоненты char char char char char char char char char char

typedef float Acceleratie [45]
Индексы        0     1      2   ...    43        44               
Компоненты   float float  float ...   float     float
```
Рис. 1.1* Структура данных типа Vector, Simbol и Acceleratie

Каждый компонент переменной одномерного массива можно указать явно, определив имя переменной, за которым следует соответствующий индекс, заключенный в квадратные скобки. Индексы должны быть целочисленными выражениями.

Примеры:
```
1.	V[1], V[4];	
2.	S[0], S[5], S[9];	
3.	A[0], A[44], A[23];
```
Над компонентами данных одномерного массива могут выполняться все операции, допустимые над их базовым типом. Следующая программа отображает на экране сумму компонентов переменной одномерного массива V. Значения компонентов V[0], V[1], ..., V[4] считываются с клавиатуры.

```cpp
// Программа P78
// Сумма компонентов переменной V типа Vector
// Фиксированное количество компонентов
#include <iostream>
using namespace std;

int main() {
    typedef int Vector[5];
    Vector V;
    int i, S;

    cout << "Введите 5 целых чисел:" << endl;
    for (i = 0; i < 5; i++) cin >> V[i];

    cout << "Были введены:" << endl;
    for (i = 0; i < 5; i++) cout << V[i] << ' ';
    cout << endl;

    S = 0;
    for (i = 0; i < 5; i++) S = S + V[i];

    cout << "Сумма= " << S;
    return 0;
}
```

Чтобы расширить область действия программы, рекомендуется указывать количество компонентов данных типа массив через константы. Это дает большую гибкость программам на C++, поскольку они могут применяться для обработки массивов, количество компонентов которых на момент написания программы неизвестно.

Например, программа P78 может быть изменена таким образом, чтобы она вычисляла сумму n целых чисел, n ≤ 100. Конкретное количество значений n, которые будут сохранены в одномерном массиве V, считывается с клавиатуры.

```cpp
// Программа P79
// Сумма компонентов переменной V типа Vector
// Переменное количество компонентов
#include <iostream>
using namespace std;

int main() {
    const int nmax = 100;
    typedef int Vector[nmax];
    Vector V;
    int n, i, S;

    cout << "Введите n= ";
    cin >> n;
    cout << "Введите " << n << " целых чисел:" << endl;
    for (i = 0; i < n; i++) cin >> V[i];

    cout << "Были введены:" << endl;
    for (i = 0; i < n; i++) cout << V[i] << ' ';
    cout << endl;

    S = 0;
    for (i = 0; i < n; i++) S = S + V[i];

    cout << "Сумма= " << S;
    return 0;
}
```

В информатике одномерные массивы часто используются для сортировки данных в определенном порядке, например в порядке возрастания. Для такой сортировки используется следующий метод:
1. каждый компонент массива, начиная с первого, последовательно сравнивается с каждым из следующих за ним компонентов;
2. если в результате сравнения компонентов выясняется, что текущий компонент больше того, с которым он сравнивается, компоненты меняются местами;
3. процесс обхода массива продолжается до сравнения последнего и предпоследнего компонентов.

На обыденном языке информатиков такая сортировка называется пузырьковой сортировкой, потому что компоненты массива меняют свое положение, как пузырьки в жидкости: самые легкие поднимаются на поверхность, а самые тяжелые уходят на дно.

Например, в следующей программе пузырьковый метод используется для сортировки компонентов массива A в порядке возрастания. Компоненты этого массива считываются с клавиатуры, а фактическая сортировка выполняется в таблице B.

``` cpp
// Программа P80
// Сортировка пузырьковым методом
#include <iostream>
using namespace std;

int main() {
    const int nmax = 100;
    typedef int Tablou[nmax];
    Tablou A, B;
    int n, i, j, x;

    cout << "Введите количество компонентов n= ";
    cin >> n;

    cout << "Введите компоненты массива A:\n";
    for (i = 0; i < n; i++) 
        cin >> A[i];

    // Копируем массив A в B
    for (i = 0; i < n; i++) 
        B[i] = A[i];

    // Сортировка пузырьком
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (B[i] > B[j]) {
                x = B[i];
                B[i] = B[j];
                B[j] = x;
            }

    cout << "Исходный массив:\n";
    for (i = 0; i < n; i++) 
        cout << A[i] << " ";
    cout << endl;

    cout << "Отсортированный массив:\n";
    for (i = 0; i < n; i++) 
        cout << B[i] << " ";
    cout << endl;

    return 0;
}
```

Тип данных двумерный массив определяется грамматической конструкцией вида:

typedef <Тип компонентов > <Имя типа массив>[<Количество строк>] [<Количество столбцов>];

В качестве примера на рис. 1.2* представлена структура данных типа Matrice:

```cpp
typedef double Matrice[3][4];
```

|       | 0       | 1       | 2       | 3       |
|-------|---------|---------|---------|---------|
| **0** | double  | double  | double  | double  |
| **1** | double  | double  | double  | double  |
| **2** | double  | double  | double  | double  |

Рис. 1.2 *. Структура данных типа Matrice

Компоненты переменных типа двумерный массив явно указываются именем переменной, за которым следуют соответствующие индексы в квадратных скобках.
   
Например, при наличии объявления переменной M
```cpp
Matrice M;
```

обозначение M[1,1] указывает компонент из строки с номером 1 и столбца с номером 1 (см. рис. 1.2*); обозначение M[1,2] указывает компонент из строки 1 и столбца 2; обозначение M[i,j] указывает компонент из строки i и столбца j.

Следующая программа отображает на экране сумму компонентов переменной M типа Matrice. Значения компонентов M[0,0], M[0,1], ..., M[2,3] считываются с клавиатуры.

```cpp
// Программа P81
// Сумма компонентов переменной M типа Matrice
#include <iostream>
using namespace std;

int main() {
    typedef double Matrice[3][4];
    Matrice M;
    int i, j;
    double S;

    cout << "Введите компоненты M[i,j]: " << endl;
    for (i = 0; i < 3; i++)
        for (j = 0; j < 4; j++) {
            cout << "M[" << i << ',' << j << "] = ";
            cin >> M[i][j];
        }

    cout << "Были введены:" << endl;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++)
            cout << M[i][j] << ' ';
        cout << endl;
    }

    S = 0;
    for (i = 0; i < 3; i++)
        for (j = 0; j < 4; j++)
            S += M[i][j];

    cout << "Сумма = " << S << endl;

    return 0;
}
```

В момент объявления компоненты массива можно инициализировать, например:
```cpp
int T[4]={2,5,9,-4};
int M[3][2]={{9,7}, {-12,8}, {0,-4}};
```
   
Подчеркнем, что в языке C++ индексы компонентов массива могут принимать только последовательные целочисленные значения, начиная с нуля: 0, 1, 2,…, <Количество компонентов> – 1. Иногда это может создавать определенные неудобства.

Таким образом, в случае примера суточного потребления электроэнергии в течение месяца (см. предыдущий параграф) соответствующая таблица может быть представлена на компьютере с помощью следующего типа данных одномерный массив:
```cpp
typedef float Consum[31];
Consum C;
```

Индекс массива C может принимать только значения 0, 1, 2,… 30, а компоненты массива специфицируются как C[0], C[1],…, C[30]. Очевидно, что индекс последнего дня месяца, т. е. 31-го не будет соответствовать какому-либо компоненту массива, а попытка использовать спецификацию C[31] в определенных ситуациях может вызвать ошибку выполнения. Несомненно, мы могли бы пронумеровать дни месяца не начиная с «1», а с «0», но это может сделать программы на C++ менее интуитивно понятными.

Чтобы избежать таких ситуаций, рекомендуется увеличить количество компонентов массива на одну единицу по сравнению с количеством, требуемым для представления составных данных на компьютере.
   
Например, в случае ежедневного потребления электроэнергии в течение месяца мы можем использовать следующий тип данных:
```cpp
typedef float Consum[32];
Consum C;
```
где первый день месяца будет соответствовать компоненту C[1], второй день ― компоненту C[2], третий день ― компоненту C[3] и так далее, а компонент C[0] останется неиспользованным.
   
Аналогичным образом можно использовать следующие типы данных для представления в компьютере ежедневного потребления электроэнергии в течение года:
```cpp
typedef float Consum[13][32];
Consum C;
```
где дни января будут соответствовать компонентам C[1,1],…, C[1,31]; дни февраля ― компонентам C[2,1],…, C[2,31], дни декабря ― компонентам C[12,1],…, C[12,31]. Очевидно, что некоторые компоненты таблицы C, особенно в строке и столбце 0, останутся неиспользованными. Однако поскольку читабельность и правильность программ гораздо важнее, чем неиспользование определенных компонентов, большинство информатиков считают, что этот прием не ухудшает качество программ на C++.



### Вопросы и упражнения
1. ОБРАТИТЕ ВНИМАНИЕ! Определите тип индексов и тип компонент в следующих объявлениях:

```cpp
typedef int P[5];

enum Culoare { Galben, Verde, Albastru, Violet };
typedef Culoare R[3];

typedef bool S[4][3];

typedef double T[2][5];
```
Нарисуйте структуры данных типа P, R, S и T (см. вышеприведенные соответствующие рисунки).

4. ПРОАНАЛИЗИРУЙТЕ! Определите, какие из нижеприведенных объявлений корректны:
```cpp

int a[30];
char a[10];
float a[10];  // C++ does not support non-integer indices like 1.10..10.00
char a[50];
```

5. УПРАЖНЯЙТЕСЬ! Даны объявления:
```cpp
typedef double Vector[5];
Vector x, y;
```
Напишите арифметическое выражение, значением которого является:
а. сумма первых трех компонентов переменной х;
б. сумма всех компонентов переменной у;
в. произведение всех компонентов переменной х;
г. абсолютное значение третьего компонента переменной у;
д. сумма первых компонентов переменных х и у.

6. ПРОАНАЛИЗИРУЙТЕ! Даны описания и операторы:

| № | Объявления       | Оператор                     | Результат          |
|---|-----------------|-------------------------------|------------------|
| 1 | unsigned char a[5]; | for (i=0; i<5; i++) a[i]=i; | a) 1 1 1 1 1<br>b) 0 0 0 0 0<br>c) 0 1 2 3 4<br>d) 1 2 3 4 0 |
| 2 | int v[4];        | for (i=0; i<5; i++) v[i]=2*i; | a) 2 4 6 8 10<br>b) 0 2 4 6 8<br>c) 0 1 2 3 4<br>d) 1 2 3 4 5 |

Выберите из списков справа варианты, содержащие правильные результаты выполнения соответствующих операторов.

7. РЕШИТЕ! Даны объявления:
```cpp
enum Zi { L, Ma, Mi, J, Vi, S, D };
typedef double Venit[7];
Venit v;
```
Компоненты переменной v представляют собой ежедневный доход предприятия. Напишите программу, которая:
а. вычисляет еженедельный доход предприятия;
б. подсчитывает средний ежедневный доход;
в. определяет день, когда был получен наибольший доход;
г. определяет день, когда был получен наименьший доход.

8. РЕШИТЕ! Даны объявления:
```cpp
typedef int Ora;
typedef int Temperatura[24];
Temperatura t;
```
Компоненты переменной t представляют собой значения температуры, измеряемой каждый час в течение 24 часов. Напишите программу, которая:
а. вычисляет среднюю температуру;
б. определяет минимальное и максимальное значения температуры;
в. определяет час (часы), в который была зарегистрирована максимальная температура;
г. определяет час (часы), в который была зарегистрирована минимальная температура.
д. вычисляет количество дней, в течение которых была зафиксирована тeмпература ниже нуля градусов;
е. вычисляет количество дней, в которые были зарегистрированы температуры выше средней за неделю.

9. Даны объявления:
```cpp
enum Oras { Chisinau, Orhei, Balti, Tighina, Tiraspol };
enum Zi { L, Ma, Mi, J, Vi, S, D };

typedef double Consum[5][7];
Consum C;

Oras r;
Zi z;
```

Компонент C[r, z] / C[r][z] в C++ переменной C представляет собой потребление электроэнергии города r в день z. Напишите программу, которая:
a. вычисляет количество электроэнергии, потребляемой каждым городом за неделю;
б. вычисляет количество электроэнергии, потребляемой данными городами ежедневно;
в. определяет город с максимальным еженедельным потреблением электро-энергии;
г. определяет город с минимальным еженедельным потреблением электро-энергии;
д. определяет день, в который города потребили наибольшее количество электроэнергии;
е. определяет день с наименьшим потреблением электроэнергии.


10. Даны объявления:
```cpp
typedef float Vector[5];
typedef bool Matrice[3][4];
typedef float Linie[4];
typedef Linie Tabel[3];

Vector V;
Matrice M;
Linie L;
Tabel T;
float x;
int i;
```

Какие из следующих операторов присваивания корректны?
```cpp
a)  T[3] = T[1];
b)  M = T;
c)  L = V;
d)  L[3] = x;
e)  x = i;
f)  i = x;
g)  L[3] = i;
h)  i = M[1][2];
i)  x = V[4];
j)  L[3] = V[4];
k)  T[1] = 4;
l)  T[2] = V;
m)  L = T[3];
n)  T[1][2] = M[1][2];
o)  T[2][1] = M[1][2];
p)  M[1] = 4;
q)  M[1][3] = L[2];
r)  x = T[1][2];
s)  x = M[1];
t)  L = M[1];
u)  V[5] = M[3][4];
v)  L = M[3][4];
```


11. РЕШИТЕ! С клавиатуры считываются компоненты одномерного массива, состоящего из n целых чисел, n≤10. Напишите программу, которая:

а. отображает на экране компоненты массива с интервалом в 5 позиций;
б. отображает на экране компоненты в порядке, обратном их введению в компьютер;
в. сортирует компоненты массива в порядке убывания;
г. отображает на экране только четные компоненты;
д. отображает на экране среднее арифметическое четных компонентов;
е. отображает на экране только нечетные компоненты;
ж. отображает на экране только те компоненты, которые больше x и не делятся на y (значения x и y считываются с клавиатуры);
з. отображает на экране только те компоненты, которые больше x и меньше y (значения x и y считываются с клавиатуры);
и. отображает на экране позиции (индексы) отрицательных нечетных компонентов;
к. отображает на экране позиции (индексы) компонентов, которые содержат только две значащие цифры;
л. заменяет первый компонент данного массива на компонент этого массива с минимальным значением;
м. заменяет компонент с минимальным значением данного массива на его первый компонент;
н. создает новый массив, состоящий только из четных компонентов массива, введенного с клавиатуры;
о. создает новый массив, состоящий только из делимых на 3 компонентов массива, введенного с клавиатуры.
п. создает новый массив, состоящий только из тех компонентов массива, вводимых с клавиатуры, которые имеют не более четырех делителей.

12. РЕШИТЕ! Человек намеревается купить n различных продуктов, пронумерованных i = 1, 2, 3,…, n. Каждый из этих продуктов можно купить в любом из k доступных магазинов, отмеченных j = 1, 2, 3,… , k. Очевидно, что покупатель выбирает магазины с самыми низкими ценами. Разработайте программу, которая определяет для каждого продукта i магазин j, в котором он должен быть приобретен, а также общую стоимость покупок C, сделанных таким образом.

Входные данные: двумерный массив P, в котором компонент P[i][j] представляет цену продукта i в магазине j.

Выходные данные: общая стоимость покупок C и одномерный массив M, в котором компонент M[i] представляет магазин j, в котором будет приобретен продукт i.

Ограничения: 1 ≤ n ≤ 10, 1 ≤ k ≤ 5. Цены указываются вещественными чиcлами с двумя цифрами после десятичной точки.

13. ТЕМАТИЧЕСКОЕ ИССЛЕДОВАНИЕ. Разработайте структуры данных типа массив, необходимые для представления в программах ПАСКАЛЬ/C++ массивов, содержащих информацию о суточном потреблении электроэнергии в течение месяца и соответственно за год, описанных в этом параграфе. Проанализируйте, как количество компонентов в объявлениях массива влияет на понимание пользователями программ.

14. УЧИТЕСЬ УЧИТЬСЯ! Двумерные массивы с одинаковым количеством строк и столбцов называются квадратными массивами. Набор компонентов, у которых индекс строки равен индексу столбца, образует главную диагональ квадратного массива. Очевидно, что этот набор можно обозначить воображаемой линией, соединяющей компонент в верхнем левом углу с компонентом в правом нижнем углу квадратного массива. Аналогичным образом может быть определена вторичная диагональ квадратного массива, которая также может быть обозначена воображаемой линией, соединяющей компонент в нижнем левом углу с компонентом в правом верхнем углу.

Разработайте программу, которая считывает с клавиатуры квадратный массив с n строками, 2 ≤ n ≤ 10, и отображает на экране сумму компонентов, которые находятся:
а. на главной диагонали;
б. на вторичной диагонали;
в. над главной диагональю;
г. ниже главной диагонали;
д. над вторичной диагональю;
е. ниже вторичной диагонали.

Считается, что компоненты квадратного массива являются целыми числами, которые вводятся с клавиатуры.

15. ИЗУЧИТЕ! Язык C++ предоставляет альтернативный тип двумерных массивов, определенных в библиотеке <array>. Изучите эту библиотеку и перепишите программы из этого параграфа, используя возможности, которые она предлагает. Чем эти два способа определения массивов похожи и различны?

### 1.3. Типы данных строка символов
Особое значение имеют методы представления и обработки строк символов, поскольку многие объекты реального мира описываются не только числами, но и самыми разнообразными текстами. Обычно в современных средах разработки программ строки символов могут быть представлены несколькими структурами данных. Далее мы изучим следующие типы данных, используемые для представления строк символов:
* одномерные массивы с компонентами типа char (символы);
* string-и.

Напоминаем, что в случае языков программирования английское слово string имеет значение строки, ряда, последовательности символов.


#### Строки символов типа одномерный массив
В программах C++ строки символов могут быть представлены с помощью одномерных массивов с компонентами типа char. Такие типы объявляются грамматическими конструкциями вида:
```cpp
typedef char <Имя типа строка символов> [nmax];
```
где nmax указывает максимальное количество символов, которое могут иметь строки этого типа.

Набор значений типа данных <Имя типа строка символов> состоит из строк, содержащих до nmax символов. Поскольку во внутреннем представлении один из компонентов одномерного массива, представляющего строку, используется для обозначения конца строки, длина строки будет составлять не более nmax–1 значащих символов.

Примеры:
1.	 
```cpp
typedef char Nume[20];
Nume N;
```
2.	 
```cpp
typedef char Prenume[10];
Prenume P;
```
3.	 
```cpp
typedef char Companie[45];
Companie C;
```
Как было отмечено ранее, во внутреннем представлении конец строки указывается специальным символом, а именно символом escape '\0'.

Например, если переменная P типа Prenume содержит строку символов "Ion", соответствующий массив имеет вид:
```cpp
0   1   2   3    4   5   6   7   8    9
I   o   n   \0
```
Если та же переменная P содержит строку символов "Cristina", соответствующий массив будет иметь вид:
```cpp
0   1   2   3    4   5   6   7   8    9
C   r   i   s    t   i   n   a   \0
```
Поэтому, несмотря на то что в объявлении типа данных Prenume указано 10 символов, строки этого типа могут содержать до 9 значащих символов.
  
В принципе, строки, представленные одномерными массивами, могут обрабатываться путем прямого доступа к их компонентам.

Например, если вы хотите ввести строку "Ion" в переменную P, для этой цели можно использовать следующие операторы:
```cpp
P[0]=   'I';
P[1]=   'o';
P[2]=   'n';
P[3]=   '\0';
```
Подчеркнем, что указание конца строки с помощью escape-символа '\0' обязательно. В противном случае возникнут ошибки выполнения.

Значения строковых переменных ― одномерных массивов можно отобразить на экране с помощью оператора передачи данных << в потоке вывода cout.

Пример:
```cpp
// Программа P82_a
// Строки символов типа одномерный массив
#include <iostream>
using namespace std;

int main()
{
    typedef char Nume[20];
    Nume N;
    typedef char Prenume[10];
    Prenume P;

    N[0]='L'; N[1]='u'; N[2]='p'; N[3]='u'; N[4] = '\0';
    P[0]='I'; P[1]='o'; P[2]='n'; P[3]='\0';

    cout << N << endl;
    cout << P << endl;

    return 0;
}

```

Результаты, отображаемые на экране:
```
Lupu
Ion
```   
При чтении строк символов с клавиатуры необходимо иметь в виду, что стандартный ввод рассматривается как источник, обеспечивающий непрерывный поток символов cin. Чтобы иметь возможность извлечь нужные строки из этого потока, программа должна знать, какой символ их разделяет. Обычно в качестве разделителя используются так называемые белые символы (пробел, табуляция, конец строки), но программист может использовать и другие символы.

Оператор >> используется для чтения строк, разделенных белыми символами. Оператор << используется для отображения/вывода строк.

Пример:
```cpp
// Программа P82_b
// Считывание строк символов
// Разделители: пробел либо конец строки
#include <iostream>
using namespace std;
int main()
{
    typedef char Nume[20];
    Nume N;
    typedef char Prenume[10];
    Prenume P;
    cin >> N; // считывается строка символов N
    cin >> P; // считывается строка символов P
    cout << N << endl; // вывод строки символов              N
    cout << P << endl; // вывод строки символов              P
    return 0;
}

```
Предположим, что пользователь после запуска программы на выполнение вводит с клавиатуры:
```
Маркова<ENTER>
Кристина<ENTER>
```
В этом случае введенный cin имеет следующий вид:
```
Маркова<ENTER>Кристина<ENTER>
```   
 где символ  представляет его курсор. Изначально курсор находится в начале потока, то есть перед буквой M.
   
В процессе выполнения оператора cin>>N программа, начиная с текущей позиции курсора, обходит входной поток слева направо, смещая курсор после каждого прочитанного символа и помещая этот символ в переменную N. Как только курсор достигает разделителя конец строки <ENTER>, оператор cin>>N записывает в переменную N escape-символ '\0' и заканчивает считывание первой строки символов. После выполнения команды cin>>N переменная N примет значение "Маркова", а курсор окажется перед символом К.

Аналогичным образом оператор cin>>P продолжает обход входного потока, перемещая курсор и помещая считанные символы один за другим в переменную P. Как только курсор достигает разделителя конца строки <ENTER>, оператор cin>>P вводит escape-символ '\0' в переменную P и завершает чтение второй строки. После выполнения оператора cin>>P переменная P получит значение "Кристина", а курсор окажется в конце потока.

В результате программа отобразит на экране:
```
Маркова
Кристина
```
Подчеркнем, что операторы для чтения данных из входного потока cin>> используют в качестве разделителя не только конец строки <ENTER>, но и пробел. Таким образом, если пользователь наберет:
```
Маркова Кристина Лупу Ион <ENTER>
```                          
 переменная N получит значение "Маркова", переменная P ― значение "Кристина", а курсор будет перед символом Л. Остальные символы в потоке данных, а именно "Лупу Ион", останутся сохраненными во входном потоке.

Для чтения строк, разделенных только концом строки, т. е. нажатием клавиши <ENTER>, используется функция cin.getline. Вызов этой функции имеет вид:
```
cin.getline (S, n);
```
где
S ― переменная, в которую будет помещена строка символов из входного потока;
n ― максимальное количество символов, которые можно считать из входного потока.

Пример:
```cpp
// Программа P82_c
// Считывание строк символов
// Разделитель: конец строки
#include <iostream>
using namespace std;

int main()
{
    typedef char NumePrenume[30];
    NumePrenume NP;
    cin.getline(NP, 30); // Разделитель: конец строки NP
    cout << NP << endl;
    return 0;
}
```

Если в процессе выполнения вышеприведенной программы пользователь введет:
```
Пэдурару Елена - Переведена<ENTER>
```
переменная NP получит значение "Пэдурару Елена - Переведена".

Другой способ прочитать строку символов, которая может содержать пробелы, ― использовать функцию get().

Поскольку обработка строк путем доступа к каждому из компонентов этих массивов затруднительна, язык C++ содержит набор предопределенных функций, упрощающих этот процесс. Вот некоторые из них:
   
strcpy(S1, S2) ― копирует строку символов S2 в строку S1;
strcat(S1, S2) ― приклеивает к строке S1 строку символов S2;
strlen(S) ― возвращает длину строки символов S.

Среды разработки программ на C++ содержат и другие предопределенные функции, предназначенные для обработки строк. Описание и способы использования этих функций можно найти в системах поддержки этих сред.

Для использования этих функций в разрабатываемую программу должна быть включена следующая директива:
```cpp
#include <cstring>;
```
Пример:
```cpp
// Программа P82_d
/* Предопределенные функции для обработки */
/* строк символов типа одномерный массив */
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    typedef char Nume[20];
    Nume N;
    typedef char Prenume[10];
    Prenume P;

    strcpy(N, "Мунтяну");
    cout << N << "    " << strlen(N) << endl;

    strcpy(P, "Михай");
    cout << P << "   " << strlen(P) << endl;

    strcat(N, " ");
    cout << strcat(N, P) << "   " << strlen(N) << endl;

    return 0;
}
```

Отображенные на экране результаты:
```
Мунтяну     7
Михай    5
Мунтяну Михай    13
```
В случае представления строк одномерными массивами они могут быть инициализированы во время объявления. Однако следует иметь в виду, что эти массивы должны содержать escape-символ '\0' (конец строки).
Примеры:
1.	 char S[]={’I’, ’o’, ’n’, ’\0’};
2.	 char S[]=”Ion”;
3.	 char T[]={’E’, ’l’, ’e’, ’n’, ’a’, ’\0’};

##### Строка символов типа string
Мы уже знаем, что строки символов типа char <Имя типа строка символов>[nmax] могут содержать не более чем nmax–1 значимых символов. Но очень часто на момент написания программ на C++ значение nmax неизвестно, это усложняет процесс программирования.

Чтобы упростить работу программистов, язык программирования C++ содержит предопределенный тип строковых данных string, который позволяет объявлять строки без указания их максимально возможной длины. Для использования этого типа в декларативную часть программы на C++ необходимо добавить директиву:
```cpp
#include <string>;
```
Строки типа string могут появляться в операторах присваивания, и с ними может выполняться операция конкатенации (склеивания), обозначенная символом «+».

Пример:
```cpp
// Программа P83_a
// Строка символов типа string
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string N;             // Фамилия
    string P;             // Имя
    string NP;            // Фамилия и имя
    N = "Olaru";          // присваивание
    P = "Andrei";         // присваивание
    NP = N + " " + P;     // склеивание и присваивание
    cout << N << endl;
    cout << P << endl;
    cout << NP << endl;
    return 0;
}
```
Эта программа отобразит на экране:
```
Olaru
Andrei
Olaru Andrei
```   
Над строками символов можно выполнять следующие операции отношения: <, <=, ==, >=, >, !=. Строки сравниваются посимвольно слева направо в соответствии с положением символов в типе char.

Например, результат операции
```
’AC’ < ’BA’
```
равен true, а результат операции
```
’AAAAC’ < ’AAAAB’
```
равен false.

Переменная типа строка символов может быть использована целиком или частично, ссылаясь на символ в строке.

Например, после выполнения последовательности операторов
```cpp
P=”Mihai”;
P[0]=’P’; P[1]=’e’; P[2]=’t’; P[3]=’r’; P[4]=’u’;
```
переменная P получит значение ”Petru”.

Обычно чтение введенной с клавиатуры строки в переменную S типа string выполняется с помощью оператора вида:
```cpp
getline(cin, S);
```
Длина l строки символов S типа string определяется с помощью оператора вида:
```cpp
l = S.length();
```
где S ― это обрабатываемая строка символов.

Следующая программа считывает с клавиатуры произвольные строки символов и отображает на экране количество пробелов в каждой считанной строке. Программа заканчивается после введения строки ’Конец’.
```cpp
// Программа P83_b
// Количество пробелов в строке символов
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string Sir; // Считываемая с клавиатуры строка символов
    int L;      // Длина строки символов
    int n;      // Количество пробелов в считанной строке
    int i;

Repeta:
    cout << "Введите строку символов:" << endl;
    getline(cin, Sir); // Считывание строки
    L = Sir.length();   // Длина строки
    cout << "Lungimea sirului = " << L << endl;

    n = 0;
    for (i = 0; i < L; i++)
        if (Sir[i] == ' ') n++;

    cout << "Количество пробелов в строке = " << n << endl;

    if (Sir != "Конец") goto Repeta;

    return 0;
}
```

Стандартные библиотеки C++ дают программисту возможность использовать оба представления строковых данных как через массивы, так и в виде string.

Преобразование string в массив можно выполнить с помощью оператора вида:
```cpp
S.c_str();
```
где S ― это переменная типа string.

Преобразование массива символов в string можно сделать простым присваиванием вида S = T.

Пример:
```cpp
// Программа P83_c
// Преобразования string <--> массив символов
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    char A[20]; // A массив символов
    string B;    // B – string

    // Преобразование строки типа string B в массив A
    B = "Informatica";
    strcpy(A, B.c_str());
    cout << A << endl;

    // Преобразование массива A в string-ul B
    A[0] = 'A'; A[1] = 'd'; A[2] = 'm'; A[3] = 'i'; A[4] = 's'; A[5] = '\0';
    B = A;
    cout << B << endl;

    return 0;
}
```



 ### Вопросы и упражнения
1. Как определяется тип данных строка символов? Каковы два способа представления строк в программах на языке ПАСКАЛЬ/C++?
2. Какие операции можно выполнять со строками, представленными одномерными массивами? А с данными типа string?
3. ПРОГРАММИРУЙТЕ! Разработайте программу, которая запросит ввести с клавиатуры в две строки:
* имя и фамилию ученика/ученицы;
* профессию, к которой он/она стремится.
Используйте наводящие вопросы и организуйте диалог человека с компьютером в соответствии со следующей моделью:
```
Как тебя зовут (имя и фамилия)?
Пэдурару Елена
Кем ты хочешь стать в будущем?
врачом
Тебя зовут Пэдурару Елена
Ты хочешь стать врачом
```
В данной модели данные, которые ввел пользователь, выделены жирным шрифтом.
4. ОБРАТИТЕ ВНИМАНИЕ! Прокомментируйте следующую программу:
```cpp
// Программа P84
#include <iostream>
using namespace std;

int main()
{
    char S[] = "12345";
    cout << S << endl;
    S = "Sfat";
    cout << S;
    return 0;
}
```
5. ЭКСПЕРИМЕНТИРУЙТЕ! Добавьте перед оператором „return 0;” из программы P82_b последовательность операторов:
```cpp
cin >> N;
cin >> P;
cout << N << endl;
cout << P << endl;
```
Запустите программу на выполнение и введите строку:
```cpp
Маркова Кристина Лупу Ион Ion<ENTER>
```
Объясните отображенные на экране сообщения.
6.ПРОАНАЛИЗИРУЙТЕ! Даны строки символов типа string . Укажите результаты операций отношения:

a. 'B' < 'A'
b. "BB" > "AA"
c. "BAAAA" < "AAAAA"
d. "CCCCD" > "CCCCA"
e. "A" == "AA"
f. "BB " < "B B"
g. "A" == "a"
h. "Aa" > "aA"
i. "123" == "321"
j. "12345" > "12345"


7. РЕШИТЕ! Разработайте программу, которая считывает с клавиатуры строку символов S и на экране отобразится:
а. количество вхождений символа ’A’ в строке S;
б. строка, полученная заменой символа ’A’ на символ ’*’;
в. строка, полученная удалением из строки S всех вхождений символа ’B’;
г. количество появлений слога MA в строке S;
д. строка, полученная заменой всех вхождений в строке S слога MA на слог TA;
е. строка, полученная удалением из строки S всех вхождений слога ТО;
ж. обратная запись строки S;
з. true, если строка S палиндром, и false в противном случае;
и. строка, полученная преобразованием всех строчных букв в составе строки S в прописные;
к. строка, полученная преобразованием первой буквы каждого слова в составе строки S в заглавную букву;
л. строка, полученная путем сортировки в алфавитном порядке символов в строке S.
8. ПРОГРАММИРУЙТЕ! Даны строки символов, состоящие из заглавных букв латинского алфавита и пробелов. Напишите программу, которая шифрует данные строки по следующим правилам:
– каждая буква от ’A’ до ’Y’ заменяется на следующую за ней в алфавите букву;
– каждая буква ’Z’ заменяется на букву ’A’;
– каждый пробел заменяется на ’-’.
9. ПРОГРАММИРУЙТЕ! Напишите программу, которая расшифрует строки символов, зашифрованные по правилам из предыдущего упражнения.
10. ПРОГРАММИРУЙТЕ! Разработайте программу, которая считывает с клавиатуры строку символов S, состоящую из n символов, n ≤ 30, и отобразит на экране все строки, получаемые путем удаления из строки S последних k символов, k = 0, 1, 2, .., n – 1. Например, для S = Test программа отобразит на экране:
```cpp
Test
Tes
Te
T
```
11. ТВОРИТЕ! Разработайте программу, которая:
– считает с клавиатуры m, m ≤ 100, строк символов, состоящих из строчных букв латинского алфавита;
– отсортирует строки в алфавитном порядке;
– отобразит на экране отсортированные строки.
12. ПРОГРАММИРУЙТЕ! Строка S состоит из нескольких предложений. Предложения заканчиваются точкой, восклицательным или вопросительным знаком. Разработайте программу, которая отобразит:
−	 количество предложений в строке, введенной с клавиатуры;
−	 количество слов в каждом из предложений.
13. УЧИТЕСЬ УЧИТЬСЯ! Известно, что современные компиляторы содержат несколько предопределенных функций для обработки строк символов, например функций конкатенации, копирования, упорядочения, вставки или удаления определенных символов и т. д. Описание этих функций можно найти в системах поддержки интегрированных сред разработки программ.

Изучите индивидуально или в команде предопределенные функции обработки строк и заполните таблицу:
| Функция | Описание | Примеры |
|---------|----------|---------|
|         |          |         |
|         |          |         |
|         |          |         |
|         |          |         |
|         |          |         |

Перепишите программы из этого параграфа, применив соответствующие функции. Оцените, в какой степени использование этих функций облегчает процесс разработки программ на языке ПАСКАЛЬ/C++.
14. ИССЛЕДУЙТЕ! Кроме функции cin.getline, для считывания строк символов можно использовать функцию cin.get. Изучите самостоятельно или совместно с одноклассниками эту функцию. Узнайте, в чем состоит различие между функциями cin.getline и cin.get. Определите, в каких случаях рекомендуется использование функции cin.getline и в каких ― использование функции cin.get.

Используя функцию cin.get, разработайте программу, считывающую с клавиатуры строку символов и выводящую на экран ее длину. Строка может содержать один или более пробелов, а ее конец указывается символом ’x’.

